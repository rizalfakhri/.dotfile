import * as shared from '@volar/shared';
import type * as ts from 'typescript/lib/tsserverlibrary';
import type { TextDocument } from 'vscode-languageserver-textdocument';
import type * as vscode from 'vscode-languageserver';
export declare type Projects = ReturnType<typeof createProjects>;
export declare function createProjects(options: shared.ServerInitializationOptions, ts: typeof import('typescript/lib/tsserverlibrary'), tsLocalized: ts.MapLike<string> | undefined, connection: vscode.Connection, documents: vscode.TextDocuments<TextDocument>, rootPaths: string[], inferredCompilerOptions: ts.CompilerOptions): {
    projects: Map<string, {
        update: () => Promise<void>;
        onDocumentUpdated: (document: TextDocument) => Promise<void>;
        getLanguageService: () => {
            doValidation: (uri: string, response: (result: vscode.Diagnostic[]) => void, isCancel?: (() => Promise<boolean>) | undefined) => Promise<Promise<vscode.Diagnostic[] | undefined>>;
            findDefinition: (uri: string, position: vscode.Position) => Promise<vscode.Location[] | vscode.LocationLink[]>;
            findReferences: (uri: string, position: vscode.Position) => Promise<vscode.Location[]>;
            findTypeDefinition: (uri: string, position: vscode.Position) => Promise<vscode.LocationLink[]>;
            callHierarchy: {
                doPrepare: (uri: string, position: vscode.Position) => Promise<vscode.CallHierarchyItem[]>;
                getIncomingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyIncomingCall[]>;
                getOutgoingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyOutgoingCall[]>;
            };
            prepareRename: (uri: string, position: vscode.Position) => Promise<vscode.Range | vscode.ResponseError<void> | undefined>;
            doRename: (uri: string, position: vscode.Position, newName: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getEditsForFileRename: (oldUri: string, newUri: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getSemanticTokens: (uri: string, range?: vscode.Range | undefined, cancle?: vscode.CancellationToken | undefined, resultProgress?: vscode.ResultProgressReporter<vscode.SemanticTokensPartialResult> | undefined) => Promise<vscode.SemanticTokens | undefined>;
            doHover: (uri: string, position: vscode.Position) => Promise<vscode.Hover | undefined>;
            doComplete: (uri: string, position: vscode.Position, context?: vscode.CompletionContext | undefined, getNameCases?: ((uri: string) => Promise<{
                tagNameCase: "both" | "kebabCase" | "pascalCase";
                attrNameCase: "kebabCase" | "camelCase";
            }>) | undefined) => Promise<Promise<import("vscode-languageserver-types").CompletionList | undefined>>;
            getCodeActions: (uri: string, range: vscode.Range, context: vscode.CodeActionContext) => Promise<Promise<vscode.CodeAction[]>>;
            doCodeActionResolve: (codeAction: import("vscode-languageserver-types").CodeAction) => Promise<Promise<import("vscode-languageserver-types").CodeAction>>;
            doCompletionResolve: (item: vscode.CompletionItem, newPosition?: vscode.Position | undefined) => Promise<Promise<vscode.CompletionItem>>;
            doCodeLensResolve: (codeLens: vscode.CodeLens, canShowReferences?: boolean | undefined) => Promise<vscode.CodeLens>;
            getSignatureHelp: (uri: string, position: vscode.Position, context?: vscode.SignatureHelpContext | undefined) => Promise<vscode.SignatureHelp | undefined>;
            getCodeLens: (uri: string) => Promise<vscode.CodeLens[] | undefined>;
            findDocumentHighlights: (uri: string, position: vscode.Position) => Promise<vscode.DocumentHighlight[] | undefined>;
            findDocumentLinks: (uri: string) => Promise<Promise<vscode.DocumentLink[] | undefined>>;
            dispose: () => void;
            __internal__: {
                rootPath: string;
                tsPlugin: Partial<ts.LanguageService>;
                tsProgramProxy: any;
                context: import("vscode-vue-languageservice").ApiLanguageServiceContext;
                onInitProgress(cb: (p: number) => void): void;
                checkProject: () => Promise<boolean>;
                getGlobalDocs: () => TextDocument[];
                getContext: () => Promise<import("vscode-vue-languageservice").ApiLanguageServiceContext>;
                getD3: (document: TextDocument) => Promise<Promise<string>>;
                executeCommand: (uri: string, command: string, args: any[] | undefined, connection: vscode.Connection) => Promise<Promise<void>>;
                detectTagNameCase: (uri: string) => Promise<{
                    tag: "both" | "kebabCase" | "pascalCase" | "unsure";
                    attr: "kebabCase" | "unsure" | "camelCase";
                }>;
                doRefAutoClose: (document: TextDocument, position: vscode.Position) => Promise<string | null | undefined>;
            };
        };
        getLanguageServiceDontCreate: () => {
            doValidation: (uri: string, response: (result: vscode.Diagnostic[]) => void, isCancel?: (() => Promise<boolean>) | undefined) => Promise<Promise<vscode.Diagnostic[] | undefined>>;
            findDefinition: (uri: string, position: vscode.Position) => Promise<vscode.Location[] | vscode.LocationLink[]>;
            findReferences: (uri: string, position: vscode.Position) => Promise<vscode.Location[]>;
            findTypeDefinition: (uri: string, position: vscode.Position) => Promise<vscode.LocationLink[]>;
            callHierarchy: {
                doPrepare: (uri: string, position: vscode.Position) => Promise<vscode.CallHierarchyItem[]>;
                getIncomingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyIncomingCall[]>;
                getOutgoingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyOutgoingCall[]>;
            };
            prepareRename: (uri: string, position: vscode.Position) => Promise<vscode.Range | vscode.ResponseError<void> | undefined>;
            doRename: (uri: string, position: vscode.Position, newName: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getEditsForFileRename: (oldUri: string, newUri: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getSemanticTokens: (uri: string, range?: vscode.Range | undefined, cancle?: vscode.CancellationToken | undefined, resultProgress?: vscode.ResultProgressReporter<vscode.SemanticTokensPartialResult> | undefined) => Promise<vscode.SemanticTokens | undefined>;
            doHover: (uri: string, position: vscode.Position) => Promise<vscode.Hover | undefined>;
            doComplete: (uri: string, position: vscode.Position, context?: vscode.CompletionContext | undefined, getNameCases?: ((uri: string) => Promise<{
                tagNameCase: "both" | "kebabCase" | "pascalCase";
                attrNameCase: "kebabCase" | "camelCase";
            }>) | undefined) => Promise<Promise<import("vscode-languageserver-types").CompletionList | undefined>>;
            getCodeActions: (uri: string, range: vscode.Range, context: vscode.CodeActionContext) => Promise<Promise<vscode.CodeAction[]>>;
            doCodeActionResolve: (codeAction: import("vscode-languageserver-types").CodeAction) => Promise<Promise<import("vscode-languageserver-types").CodeAction>>;
            doCompletionResolve: (item: vscode.CompletionItem, newPosition?: vscode.Position | undefined) => Promise<Promise<vscode.CompletionItem>>;
            doCodeLensResolve: (codeLens: vscode.CodeLens, canShowReferences?: boolean | undefined) => Promise<vscode.CodeLens>;
            getSignatureHelp: (uri: string, position: vscode.Position, context?: vscode.SignatureHelpContext | undefined) => Promise<vscode.SignatureHelp | undefined>;
            getCodeLens: (uri: string) => Promise<vscode.CodeLens[] | undefined>;
            findDocumentHighlights: (uri: string, position: vscode.Position) => Promise<vscode.DocumentHighlight[] | undefined>;
            findDocumentLinks: (uri: string) => Promise<Promise<vscode.DocumentLink[] | undefined>>;
            dispose: () => void;
            __internal__: {
                rootPath: string;
                tsPlugin: Partial<ts.LanguageService>;
                tsProgramProxy: any;
                context: import("vscode-vue-languageservice").ApiLanguageServiceContext;
                onInitProgress(cb: (p: number) => void): void;
                checkProject: () => Promise<boolean>;
                getGlobalDocs: () => TextDocument[];
                getContext: () => Promise<import("vscode-vue-languageservice").ApiLanguageServiceContext>;
                getD3: (document: TextDocument) => Promise<Promise<string>>;
                executeCommand: (uri: string, command: string, args: any[] | undefined, connection: vscode.Connection) => Promise<Promise<void>>;
                detectTagNameCase: (uri: string) => Promise<{
                    tag: "both" | "kebabCase" | "pascalCase" | "unsure";
                    attr: "kebabCase" | "unsure" | "camelCase";
                }>;
                doRefAutoClose: (document: TextDocument, position: vscode.Position) => Promise<string | null | undefined>;
            };
        } | undefined;
        getParsedCommandLine: () => ts.ParsedCommandLine;
        dispose: () => void;
    }>;
    inferredProjects: Map<string, {
        update: () => Promise<void>;
        onDocumentUpdated: (document: TextDocument) => Promise<void>;
        getLanguageService: () => {
            doValidation: (uri: string, response: (result: vscode.Diagnostic[]) => void, isCancel?: (() => Promise<boolean>) | undefined) => Promise<Promise<vscode.Diagnostic[] | undefined>>;
            findDefinition: (uri: string, position: vscode.Position) => Promise<vscode.Location[] | vscode.LocationLink[]>;
            findReferences: (uri: string, position: vscode.Position) => Promise<vscode.Location[]>;
            findTypeDefinition: (uri: string, position: vscode.Position) => Promise<vscode.LocationLink[]>;
            callHierarchy: {
                doPrepare: (uri: string, position: vscode.Position) => Promise<vscode.CallHierarchyItem[]>;
                getIncomingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyIncomingCall[]>;
                getOutgoingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyOutgoingCall[]>;
            };
            prepareRename: (uri: string, position: vscode.Position) => Promise<vscode.Range | vscode.ResponseError<void> | undefined>;
            doRename: (uri: string, position: vscode.Position, newName: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getEditsForFileRename: (oldUri: string, newUri: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getSemanticTokens: (uri: string, range?: vscode.Range | undefined, cancle?: vscode.CancellationToken | undefined, resultProgress?: vscode.ResultProgressReporter<vscode.SemanticTokensPartialResult> | undefined) => Promise<vscode.SemanticTokens | undefined>;
            doHover: (uri: string, position: vscode.Position) => Promise<vscode.Hover | undefined>;
            doComplete: (uri: string, position: vscode.Position, context?: vscode.CompletionContext | undefined, getNameCases?: ((uri: string) => Promise<{
                tagNameCase: "both" | "kebabCase" | "pascalCase";
                attrNameCase: "kebabCase" | "camelCase";
            }>) | undefined) => Promise<Promise<import("vscode-languageserver-types").CompletionList | undefined>>;
            getCodeActions: (uri: string, range: vscode.Range, context: vscode.CodeActionContext) => Promise<Promise<vscode.CodeAction[]>>;
            doCodeActionResolve: (codeAction: import("vscode-languageserver-types").CodeAction) => Promise<Promise<import("vscode-languageserver-types").CodeAction>>;
            doCompletionResolve: (item: vscode.CompletionItem, newPosition?: vscode.Position | undefined) => Promise<Promise<vscode.CompletionItem>>;
            doCodeLensResolve: (codeLens: vscode.CodeLens, canShowReferences?: boolean | undefined) => Promise<vscode.CodeLens>;
            getSignatureHelp: (uri: string, position: vscode.Position, context?: vscode.SignatureHelpContext | undefined) => Promise<vscode.SignatureHelp | undefined>;
            getCodeLens: (uri: string) => Promise<vscode.CodeLens[] | undefined>;
            findDocumentHighlights: (uri: string, position: vscode.Position) => Promise<vscode.DocumentHighlight[] | undefined>;
            findDocumentLinks: (uri: string) => Promise<Promise<vscode.DocumentLink[] | undefined>>;
            dispose: () => void;
            __internal__: {
                rootPath: string;
                tsPlugin: Partial<ts.LanguageService>;
                tsProgramProxy: any;
                context: import("vscode-vue-languageservice").ApiLanguageServiceContext;
                onInitProgress(cb: (p: number) => void): void;
                checkProject: () => Promise<boolean>;
                getGlobalDocs: () => TextDocument[];
                getContext: () => Promise<import("vscode-vue-languageservice").ApiLanguageServiceContext>;
                getD3: (document: TextDocument) => Promise<Promise<string>>;
                executeCommand: (uri: string, command: string, args: any[] | undefined, connection: vscode.Connection) => Promise<Promise<void>>;
                detectTagNameCase: (uri: string) => Promise<{
                    tag: "both" | "kebabCase" | "pascalCase" | "unsure";
                    attr: "kebabCase" | "unsure" | "camelCase";
                }>;
                doRefAutoClose: (document: TextDocument, position: vscode.Position) => Promise<string | null | undefined>;
            };
        };
        getLanguageServiceDontCreate: () => {
            doValidation: (uri: string, response: (result: vscode.Diagnostic[]) => void, isCancel?: (() => Promise<boolean>) | undefined) => Promise<Promise<vscode.Diagnostic[] | undefined>>;
            findDefinition: (uri: string, position: vscode.Position) => Promise<vscode.Location[] | vscode.LocationLink[]>;
            findReferences: (uri: string, position: vscode.Position) => Promise<vscode.Location[]>;
            findTypeDefinition: (uri: string, position: vscode.Position) => Promise<vscode.LocationLink[]>;
            callHierarchy: {
                doPrepare: (uri: string, position: vscode.Position) => Promise<vscode.CallHierarchyItem[]>;
                getIncomingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyIncomingCall[]>;
                getOutgoingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyOutgoingCall[]>;
            };
            prepareRename: (uri: string, position: vscode.Position) => Promise<vscode.Range | vscode.ResponseError<void> | undefined>;
            doRename: (uri: string, position: vscode.Position, newName: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getEditsForFileRename: (oldUri: string, newUri: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getSemanticTokens: (uri: string, range?: vscode.Range | undefined, cancle?: vscode.CancellationToken | undefined, resultProgress?: vscode.ResultProgressReporter<vscode.SemanticTokensPartialResult> | undefined) => Promise<vscode.SemanticTokens | undefined>;
            doHover: (uri: string, position: vscode.Position) => Promise<vscode.Hover | undefined>;
            doComplete: (uri: string, position: vscode.Position, context?: vscode.CompletionContext | undefined, getNameCases?: ((uri: string) => Promise<{
                tagNameCase: "both" | "kebabCase" | "pascalCase";
                attrNameCase: "kebabCase" | "camelCase";
            }>) | undefined) => Promise<Promise<import("vscode-languageserver-types").CompletionList | undefined>>;
            getCodeActions: (uri: string, range: vscode.Range, context: vscode.CodeActionContext) => Promise<Promise<vscode.CodeAction[]>>;
            doCodeActionResolve: (codeAction: import("vscode-languageserver-types").CodeAction) => Promise<Promise<import("vscode-languageserver-types").CodeAction>>;
            doCompletionResolve: (item: vscode.CompletionItem, newPosition?: vscode.Position | undefined) => Promise<Promise<vscode.CompletionItem>>;
            doCodeLensResolve: (codeLens: vscode.CodeLens, canShowReferences?: boolean | undefined) => Promise<vscode.CodeLens>;
            getSignatureHelp: (uri: string, position: vscode.Position, context?: vscode.SignatureHelpContext | undefined) => Promise<vscode.SignatureHelp | undefined>;
            getCodeLens: (uri: string) => Promise<vscode.CodeLens[] | undefined>;
            findDocumentHighlights: (uri: string, position: vscode.Position) => Promise<vscode.DocumentHighlight[] | undefined>;
            findDocumentLinks: (uri: string) => Promise<Promise<vscode.DocumentLink[] | undefined>>;
            dispose: () => void;
            __internal__: {
                rootPath: string;
                tsPlugin: Partial<ts.LanguageService>;
                tsProgramProxy: any;
                context: import("vscode-vue-languageservice").ApiLanguageServiceContext;
                onInitProgress(cb: (p: number) => void): void;
                checkProject: () => Promise<boolean>;
                getGlobalDocs: () => TextDocument[];
                getContext: () => Promise<import("vscode-vue-languageservice").ApiLanguageServiceContext>;
                getD3: (document: TextDocument) => Promise<Promise<string>>;
                executeCommand: (uri: string, command: string, args: any[] | undefined, connection: vscode.Connection) => Promise<Promise<void>>;
                detectTagNameCase: (uri: string) => Promise<{
                    tag: "both" | "kebabCase" | "pascalCase" | "unsure";
                    attr: "kebabCase" | "unsure" | "camelCase";
                }>;
                doRefAutoClose: (document: TextDocument, position: vscode.Position) => Promise<string | null | undefined>;
            };
        } | undefined;
        getParsedCommandLine: () => ts.ParsedCommandLine;
        dispose: () => void;
    }>;
    get: (uri: string) => {
        tsConfig: string;
        service: {
            doValidation: (uri: string, response: (result: vscode.Diagnostic[]) => void, isCancel?: (() => Promise<boolean>) | undefined) => Promise<Promise<vscode.Diagnostic[] | undefined>>;
            findDefinition: (uri: string, position: vscode.Position) => Promise<vscode.Location[] | vscode.LocationLink[]>;
            findReferences: (uri: string, position: vscode.Position) => Promise<vscode.Location[]>;
            findTypeDefinition: (uri: string, position: vscode.Position) => Promise<vscode.LocationLink[]>;
            callHierarchy: {
                doPrepare: (uri: string, position: vscode.Position) => Promise<vscode.CallHierarchyItem[]>;
                getIncomingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyIncomingCall[]>;
                getOutgoingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyOutgoingCall[]>;
            };
            prepareRename: (uri: string, position: vscode.Position) => Promise<vscode.Range | vscode.ResponseError<void> | undefined>;
            doRename: (uri: string, position: vscode.Position, newName: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getEditsForFileRename: (oldUri: string, newUri: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
            getSemanticTokens: (uri: string, range?: vscode.Range | undefined, cancle?: vscode.CancellationToken | undefined, resultProgress?: vscode.ResultProgressReporter<vscode.SemanticTokensPartialResult> | undefined) => Promise<vscode.SemanticTokens | undefined>;
            doHover: (uri: string, position: vscode.Position) => Promise<vscode.Hover | undefined>;
            doComplete: (uri: string, position: vscode.Position, context?: vscode.CompletionContext | undefined, getNameCases?: ((uri: string) => Promise<{
                tagNameCase: "both" | "kebabCase" | "pascalCase";
                attrNameCase: "kebabCase" | "camelCase";
            }>) | undefined) => Promise<Promise<import("vscode-languageserver-types").CompletionList | undefined>>;
            getCodeActions: (uri: string, range: vscode.Range, context: vscode.CodeActionContext) => Promise<Promise<vscode.CodeAction[]>>;
            doCodeActionResolve: (codeAction: import("vscode-languageserver-types").CodeAction) => Promise<Promise<import("vscode-languageserver-types").CodeAction>>;
            doCompletionResolve: (item: vscode.CompletionItem, newPosition?: vscode.Position | undefined) => Promise<Promise<vscode.CompletionItem>>;
            doCodeLensResolve: (codeLens: vscode.CodeLens, canShowReferences?: boolean | undefined) => Promise<vscode.CodeLens>;
            getSignatureHelp: (uri: string, position: vscode.Position, context?: vscode.SignatureHelpContext | undefined) => Promise<vscode.SignatureHelp | undefined>;
            getCodeLens: (uri: string) => Promise<vscode.CodeLens[] | undefined>;
            findDocumentHighlights: (uri: string, position: vscode.Position) => Promise<vscode.DocumentHighlight[] | undefined>;
            findDocumentLinks: (uri: string) => Promise<Promise<vscode.DocumentLink[] | undefined>>;
            dispose: () => void;
            __internal__: {
                rootPath: string;
                tsPlugin: Partial<ts.LanguageService>;
                tsProgramProxy: any;
                context: import("vscode-vue-languageservice").ApiLanguageServiceContext;
                onInitProgress(cb: (p: number) => void): void;
                checkProject: () => Promise<boolean>;
                getGlobalDocs: () => TextDocument[];
                getContext: () => Promise<import("vscode-vue-languageservice").ApiLanguageServiceContext>;
                getD3: (document: TextDocument) => Promise<Promise<string>>;
                executeCommand: (uri: string, command: string, args: any[] | undefined, connection: vscode.Connection) => Promise<Promise<void>>;
                detectTagNameCase: (uri: string) => Promise<{
                    tag: "both" | "kebabCase" | "pascalCase" | "unsure";
                    attr: "kebabCase" | "unsure" | "camelCase";
                }>;
                doRefAutoClose: (document: TextDocument, position: vscode.Position) => Promise<string | null | undefined>;
            };
        };
    } | undefined;
};
