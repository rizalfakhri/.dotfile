"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getScriptText = exports.createProject = exports.renameFileContentCache = exports.fileRenamings = void 0;
const shared = require("@volar/shared");
const vue = require("vscode-vue-languageservice");
const configs_1 = require("./configs");
const schemaRequestService_1 = require("./schemaRequestService");
const tsConfigs = require("./tsConfigs");
const ShPlugin = require("typescript-vscode-sh-plugin");
exports.fileRenamings = new Set();
exports.renameFileContentCache = new Map();
function createProject(ts, options, rootPath, tsConfig, tsLocalized, documents, onFileUpdated, workDoneProgress, connection) {
    let projectVersion = 0;
    let parsedCommandLine;
    let vueLs;
    const snapshots = new shared.FsPathMap();
    const scripts = new shared.FsPathMap();
    const extraScripts = new shared.FsPathMap();
    const languageServiceHost = createLanguageServiceHost();
    const disposables = [];
    update();
    return {
        update,
        onDocumentUpdated,
        getLanguageService,
        getLanguageServiceDontCreate: () => vueLs,
        getParsedCommandLine: () => parsedCommandLine,
        dispose,
    };
    function getLanguageService() {
        if (!vueLs) {
            let numOfFeatures = 0;
            if (options.languageFeatures) {
                for (let feature in options.languageFeatures) {
                    if (!!options.languageFeatures[feature]) {
                        numOfFeatures++;
                    }
                }
            }
            vueLs = vue.createLanguageService({ typescript: ts }, languageServiceHost);
            vueLs.__internal__.onInitProgress(p => {
                if (p === 0) {
                    workDoneProgress.begin(`Initializing Vue language features (${numOfFeatures} features)`);
                }
                if (p < 1) {
                    workDoneProgress.report(p * 100);
                }
                else {
                    workDoneProgress.done();
                }
            });
        }
        return vueLs;
    }
    async function update() {
        var _a, _b;
        await Promise.all([...exports.fileRenamings]);
        parsedCommandLine = createParsedCommandLine();
        const fileNames = new shared.FsPathSet(parsedCommandLine.fileNames);
        let changed = false;
        for (const [_, { fileWatcher }] of extraScripts) {
            fileWatcher.close();
        }
        extraScripts.clear();
        const removeKeys = [];
        for (const [key, { fileName, fileWatcher }] of scripts) {
            if (!fileNames.has(fileName)) {
                fileWatcher.close();
                removeKeys.push(key);
                changed = true;
            }
        }
        for (const removeKey of removeKeys) {
            scripts.delete(removeKey);
        }
        for (const fileName of parsedCommandLine.fileNames) {
            if (!scripts.has(fileName)) {
                const fileWatcher = ts.sys.watchFile(fileName, onDriveFileUpdated);
                scripts.set(fileName, {
                    fileName,
                    version: (_b = (_a = documents.get(shared.fsPathToUri(fileName))) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : 0,
                    fileWatcher,
                });
                changed = true;
            }
        }
        if (changed) {
            onProjectFilesUpdate(undefined);
        }
    }
    async function onDocumentUpdated(document) {
        await Promise.all([...exports.fileRenamings]);
        const fileName = shared.uriToFsPath(document.uri);
        const snapshot = snapshots.get(fileName);
        if (snapshot) {
            const snapshotLength = snapshot.snapshot.getLength();
            const documentText = document.getText();
            if (snapshotLength === documentText.length
                && snapshot.snapshot.getText(0, snapshotLength) === documentText) {
                return;
            }
        }
        const script = scripts.get(fileName);
        const extraScript = extraScripts.get(fileName);
        if (script) {
            script.version = document.version;
        }
        if (extraScript) {
            extraScript.version = document.version;
        }
        if (!!script || !!extraScript) {
            onProjectFilesUpdate(fileName);
        }
    }
    async function onDriveFileUpdated(fileName, eventKind) {
        if (eventKind !== ts.FileWatcherEventKind.Changed) {
            return;
        }
        await Promise.all([...exports.fileRenamings]);
        fileName = shared.normalizeFileName(fileName);
        const uri = shared.fsPathToUri(fileName);
        if (documents.get(uri)) {
            // this file handle by vscode event
            return;
        }
        const script = scripts.get(fileName);
        if (script) {
            script.version++;
        }
        onProjectFilesUpdate(fileName);
    }
    async function onProjectFilesUpdate(changedFileName) {
        projectVersion++;
        onFileUpdated(changedFileName);
    }
    function createLanguageServiceHost() {
        var _a;
        const host = {
            // vue
            createTsLanguageService(host) {
                return shared.createTsLanguageService(ts, ShPlugin, host);
            },
            getEmmetConfig: configs_1.getEmmetConfiguration,
            schemaRequestService: ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.schemaRequestService) ? schemaRequestService_1.getSchemaRequestService(connection, options.languageFeatures.schemaRequestService) : undefined,
            getPreferences: (document) => tsConfigs.getPreferences(connection, document),
            getFormatOptions: (document, options) => tsConfigs.getFormatOptions(connection, document, options),
            getParsedCommandLine: () => parsedCommandLine,
            // ts
            getNewLine: () => ts.sys.newLine,
            useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,
            readFile: ts.sys.readFile,
            writeFile: ts.sys.writeFile,
            directoryExists: ts.sys.directoryExists,
            getDirectories: ts.sys.getDirectories,
            readDirectory: ts.sys.readDirectory,
            realpath: ts.sys.realpath,
            // custom
            fileExists,
            getDefaultLibFileName: options => ts.getDefaultLibFilePath(options),
            getProjectVersion: () => projectVersion.toString(),
            getScriptFileNames: () => [
                ...parsedCommandLine.fileNames,
                ...[...extraScripts.values()].map(file => file.fileName).filter(fileName => fileName.endsWith('.vue')), // create virtual files from extra vue scripts
            ],
            getCurrentDirectory: () => rootPath,
            getCompilationSettings: () => parsedCommandLine.options,
            getScriptVersion,
            getScriptSnapshot,
        };
        if (tsLocalized) {
            host.getLocalizedDiagnosticMessages = () => tsLocalized;
        }
        return host;
        function fileExists(fileName) {
            var _a, _b, _c, _d, _e, _f, _g;
            fileName = shared.normalizeFileName((_c = (_b = (_a = ts.sys).realpath) === null || _b === void 0 ? void 0 : _b.call(_a, fileName)) !== null && _c !== void 0 ? _c : fileName);
            const fileExists = !!((_e = (_d = ts.sys).fileExists) === null || _e === void 0 ? void 0 : _e.call(_d, fileName));
            if (fileExists
                && !scripts.has(fileName)
                && !extraScripts.has(fileName)) {
                const fileWatcher = ts.sys.watchFile(fileName, (_, eventKind) => {
                    const extraFile = extraScripts.get(fileName);
                    if (eventKind === ts.FileWatcherEventKind.Changed) {
                        if (extraFile) {
                            extraFile.version++;
                        }
                    }
                    if (eventKind === ts.FileWatcherEventKind.Deleted) {
                        fileWatcher === null || fileWatcher === void 0 ? void 0 : fileWatcher.close();
                        extraScripts.delete(fileName);
                        snapshots.delete(fileName);
                    }
                    onProjectFilesUpdate(fileName);
                });
                extraScripts.set(fileName, {
                    fileName: fileName,
                    version: (_g = (_f = documents.get(shared.fsPathToUri(fileName))) === null || _f === void 0 ? void 0 : _f.version) !== null && _g !== void 0 ? _g : 0,
                    fileWatcher: fileWatcher,
                });
            }
            return fileExists;
        }
        function getScriptVersion(fileName) {
            var _a, _b, _c, _d;
            return (_d = (_b = (_a = scripts.get(fileName)) === null || _a === void 0 ? void 0 : _a.version.toString()) !== null && _b !== void 0 ? _b : (_c = extraScripts.get(fileName)) === null || _c === void 0 ? void 0 : _c.version.toString()) !== null && _d !== void 0 ? _d : '';
        }
        function getScriptSnapshot(fileName) {
            const version = getScriptVersion(fileName);
            const cache = snapshots.get(fileName);
            if (cache && cache.version === version) {
                return cache.snapshot;
            }
            const text = getScriptText(ts, documents, fileName);
            if (text !== undefined) {
                const snapshot = ts.ScriptSnapshot.fromString(text);
                snapshots.set(fileName, {
                    version: version.toString(),
                    snapshot,
                });
                return snapshot;
            }
        }
    }
    function dispose() {
        for (const [_, { fileWatcher }] of scripts) {
            fileWatcher.close();
        }
        for (const [_, { fileWatcher }] of extraScripts) {
            fileWatcher.close();
        }
        if (vueLs) {
            vueLs.dispose();
        }
        for (const disposable of disposables) {
            disposable.dispose();
        }
    }
    function createParsedCommandLine() {
        const parseConfigHost = {
            ...ts.sys,
            readDirectory: (path, extensions, exclude, include, depth) => {
                return ts.sys.readDirectory(path, [...extensions, '.vue'], exclude, include, depth);
            },
        };
        if (typeof tsConfig === 'string') {
            return shared.createParsedCommandLine(ts, parseConfigHost, tsConfig);
        }
        else {
            const content = ts.parseJsonConfigFileContent({}, parseConfigHost, rootPath, tsConfig, 'tsconfig.json');
            content.options.outDir = undefined; // TODO: patching ts server broke with outDir + rootDir + composite/incremental
            content.fileNames = content.fileNames.map(shared.normalizeFileName);
            return content;
        }
    }
}
exports.createProject = createProject;
function getScriptText(ts, documents, fileName) {
    const doc = documents.get(shared.fsPathToUri(fileName));
    if (doc) {
        return doc.getText();
    }
    if (ts.sys.fileExists(fileName)) {
        return ts.sys.readFile(fileName, 'utf8');
    }
    return exports.renameFileContentCache.get(shared.fsPathToUri(fileName));
}
exports.getScriptText = getScriptText;
//# sourceMappingURL=project.js.map