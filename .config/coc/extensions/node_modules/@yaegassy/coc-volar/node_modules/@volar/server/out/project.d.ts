import * as shared from '@volar/shared';
import * as vue from 'vscode-vue-languageservice';
import type * as ts from 'typescript/lib/tsserverlibrary';
import type { TextDocument } from 'vscode-languageserver-textdocument';
import type * as vscode from 'vscode-languageserver';
export declare type Project = ReturnType<typeof createProject>;
export declare const fileRenamings: Set<Promise<void>>;
export declare const renameFileContentCache: Map<string, string>;
export declare function createProject(ts: vue.Modules['typescript'], options: shared.ServerInitializationOptions, rootPath: string, tsConfig: string | ts.CompilerOptions, tsLocalized: ts.MapLike<string> | undefined, documents: vscode.TextDocuments<TextDocument>, onFileUpdated: (changedFileName: string | undefined) => any, workDoneProgress: vscode.WorkDoneProgressServerReporter, connection: vscode.Connection): {
    update: () => Promise<void>;
    onDocumentUpdated: (document: TextDocument) => Promise<void>;
    getLanguageService: () => {
        doValidation: (uri: string, response: (result: vscode.Diagnostic[]) => void, isCancel?: (() => Promise<boolean>) | undefined) => Promise<Promise<vscode.Diagnostic[] | undefined>>;
        findDefinition: (uri: string, position: vscode.Position) => Promise<vscode.Location[] | vscode.LocationLink[]>;
        findReferences: (uri: string, position: vscode.Position) => Promise<vscode.Location[]>;
        findTypeDefinition: (uri: string, position: vscode.Position) => Promise<vscode.LocationLink[]>;
        callHierarchy: {
            doPrepare: (uri: string, position: vscode.Position) => Promise<vscode.CallHierarchyItem[]>;
            getIncomingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyIncomingCall[]>;
            getOutgoingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyOutgoingCall[]>;
        };
        prepareRename: (uri: string, position: vscode.Position) => Promise<vscode.Range | vscode.ResponseError<void> | undefined>;
        doRename: (uri: string, position: vscode.Position, newName: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
        getEditsForFileRename: (oldUri: string, newUri: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
        getSemanticTokens: (uri: string, range?: vscode.Range | undefined, cancle?: vscode.CancellationToken | undefined, resultProgress?: vscode.ResultProgressReporter<vscode.SemanticTokensPartialResult> | undefined) => Promise<vscode.SemanticTokens | undefined>;
        doHover: (uri: string, position: vscode.Position) => Promise<vscode.Hover | undefined>;
        doComplete: (uri: string, position: vscode.Position, context?: vscode.CompletionContext | undefined, getNameCases?: ((uri: string) => Promise<{
            tagNameCase: "both" | "kebabCase" | "pascalCase";
            attrNameCase: "kebabCase" | "camelCase";
        }>) | undefined) => Promise<Promise<import("vscode-languageserver-types").CompletionList | undefined>>;
        getCodeActions: (uri: string, range: vscode.Range, context: vscode.CodeActionContext) => Promise<Promise<vscode.CodeAction[]>>;
        doCodeActionResolve: (codeAction: import("vscode-languageserver-types").CodeAction) => Promise<Promise<import("vscode-languageserver-types").CodeAction>>;
        doCompletionResolve: (item: vscode.CompletionItem, newPosition?: vscode.Position | undefined) => Promise<Promise<vscode.CompletionItem>>;
        doCodeLensResolve: (codeLens: vscode.CodeLens, canShowReferences?: boolean | undefined) => Promise<vscode.CodeLens>;
        getSignatureHelp: (uri: string, position: vscode.Position, context?: vscode.SignatureHelpContext | undefined) => Promise<vscode.SignatureHelp | undefined>;
        getCodeLens: (uri: string) => Promise<vscode.CodeLens[] | undefined>;
        findDocumentHighlights: (uri: string, position: vscode.Position) => Promise<vscode.DocumentHighlight[] | undefined>;
        findDocumentLinks: (uri: string) => Promise<Promise<vscode.DocumentLink[] | undefined>>;
        dispose: () => void;
        __internal__: {
            rootPath: string;
            tsPlugin: Partial<ts.LanguageService>;
            tsProgramProxy: any;
            context: vue.ApiLanguageServiceContext;
            onInitProgress(cb: (p: number) => void): void;
            checkProject: () => Promise<boolean>;
            getGlobalDocs: () => TextDocument[];
            getContext: () => Promise<vue.ApiLanguageServiceContext>;
            getD3: (document: TextDocument) => Promise<Promise<string>>;
            executeCommand: (uri: string, command: string, args: any[] | undefined, connection: vscode.Connection) => Promise<Promise<void>>;
            detectTagNameCase: (uri: string) => Promise<{
                tag: "both" | "kebabCase" | "pascalCase" | "unsure";
                attr: "kebabCase" | "unsure" | "camelCase";
            }>;
            doRefAutoClose: (document: TextDocument, position: vscode.Position) => Promise<string | null | undefined>;
        };
    };
    getLanguageServiceDontCreate: () => {
        doValidation: (uri: string, response: (result: vscode.Diagnostic[]) => void, isCancel?: (() => Promise<boolean>) | undefined) => Promise<Promise<vscode.Diagnostic[] | undefined>>;
        findDefinition: (uri: string, position: vscode.Position) => Promise<vscode.Location[] | vscode.LocationLink[]>;
        findReferences: (uri: string, position: vscode.Position) => Promise<vscode.Location[]>;
        findTypeDefinition: (uri: string, position: vscode.Position) => Promise<vscode.LocationLink[]>;
        callHierarchy: {
            doPrepare: (uri: string, position: vscode.Position) => Promise<vscode.CallHierarchyItem[]>;
            getIncomingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyIncomingCall[]>;
            getOutgoingCalls: (item: vscode.CallHierarchyItem) => Promise<vscode.CallHierarchyOutgoingCall[]>;
        };
        prepareRename: (uri: string, position: vscode.Position) => Promise<vscode.Range | vscode.ResponseError<void> | undefined>;
        doRename: (uri: string, position: vscode.Position, newName: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
        getEditsForFileRename: (oldUri: string, newUri: string) => Promise<Promise<vscode.WorkspaceEdit | undefined>>;
        getSemanticTokens: (uri: string, range?: vscode.Range | undefined, cancle?: vscode.CancellationToken | undefined, resultProgress?: vscode.ResultProgressReporter<vscode.SemanticTokensPartialResult> | undefined) => Promise<vscode.SemanticTokens | undefined>;
        doHover: (uri: string, position: vscode.Position) => Promise<vscode.Hover | undefined>;
        doComplete: (uri: string, position: vscode.Position, context?: vscode.CompletionContext | undefined, getNameCases?: ((uri: string) => Promise<{
            tagNameCase: "both" | "kebabCase" | "pascalCase";
            attrNameCase: "kebabCase" | "camelCase";
        }>) | undefined) => Promise<Promise<import("vscode-languageserver-types").CompletionList | undefined>>;
        getCodeActions: (uri: string, range: vscode.Range, context: vscode.CodeActionContext) => Promise<Promise<vscode.CodeAction[]>>;
        doCodeActionResolve: (codeAction: import("vscode-languageserver-types").CodeAction) => Promise<Promise<import("vscode-languageserver-types").CodeAction>>;
        doCompletionResolve: (item: vscode.CompletionItem, newPosition?: vscode.Position | undefined) => Promise<Promise<vscode.CompletionItem>>;
        doCodeLensResolve: (codeLens: vscode.CodeLens, canShowReferences?: boolean | undefined) => Promise<vscode.CodeLens>;
        getSignatureHelp: (uri: string, position: vscode.Position, context?: vscode.SignatureHelpContext | undefined) => Promise<vscode.SignatureHelp | undefined>;
        getCodeLens: (uri: string) => Promise<vscode.CodeLens[] | undefined>;
        findDocumentHighlights: (uri: string, position: vscode.Position) => Promise<vscode.DocumentHighlight[] | undefined>;
        findDocumentLinks: (uri: string) => Promise<Promise<vscode.DocumentLink[] | undefined>>;
        dispose: () => void;
        __internal__: {
            rootPath: string;
            tsPlugin: Partial<ts.LanguageService>;
            tsProgramProxy: any;
            context: vue.ApiLanguageServiceContext;
            onInitProgress(cb: (p: number) => void): void;
            checkProject: () => Promise<boolean>;
            getGlobalDocs: () => TextDocument[];
            getContext: () => Promise<vue.ApiLanguageServiceContext>;
            getD3: (document: TextDocument) => Promise<Promise<string>>;
            executeCommand: (uri: string, command: string, args: any[] | undefined, connection: vscode.Connection) => Promise<Promise<void>>;
            detectTagNameCase: (uri: string) => Promise<{
                tag: "both" | "kebabCase" | "pascalCase" | "unsure";
                attr: "kebabCase" | "unsure" | "camelCase";
            }>;
            doRefAutoClose: (document: TextDocument, position: vscode.Position) => Promise<string | null | undefined>;
        };
    } | undefined;
    getParsedCommandLine: () => ts.ParsedCommandLine;
    dispose: () => void;
};
export declare function getScriptText(ts: vue.Modules['typescript'], documents: vscode.TextDocuments<TextDocument>, fileName: string): string | undefined;
