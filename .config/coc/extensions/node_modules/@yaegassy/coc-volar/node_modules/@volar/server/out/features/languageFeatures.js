"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared = require("@volar/shared");
const vue = require("vscode-vue-languageservice");
const vscode = require("vscode-languageserver");
const project_1 = require("../project");
function register(ts, connection, documents, projects, features) {
    connection.onCompletion(async (handler) => {
        var _a;
        return await ((_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.doComplete(handler.textDocument.uri, handler.position, handler.context, async (uri) => {
            var _a;
            if ((_a = features.completion) === null || _a === void 0 ? void 0 : _a.getDocumentNameCasesRequest) {
                return await connection.sendRequest(shared.GetDocumentNameCasesRequest.type, { uri });
            }
            return {
                tagNameCase: features.completion.defaultTagNameCase,
                attrNameCase: features.completion.defaultAttrNameCase,
            };
        }));
    });
    connection.onCompletionResolve(async (item) => {
        var _a, _b, _c, _d;
        const uri = (_a = item.data) === null || _a === void 0 ? void 0 : _a.uri;
        if (!uri)
            return item;
        const activeSel = ((_b = features.completion) === null || _b === void 0 ? void 0 : _b.getDocumentSelectionRequest)
            ? await connection.sendRequest(shared.GetEditorSelectionRequest.type)
            : undefined;
        const newPosition = (activeSel === null || activeSel === void 0 ? void 0 : activeSel.textDocument.uri.toLowerCase()) === uri.toLowerCase() ? activeSel.position : undefined;
        return (_d = (_c = projects.get(uri)) === null || _c === void 0 ? void 0 : _c.service.doCompletionResolve(item, newPosition)) !== null && _d !== void 0 ? _d : item;
    });
    connection.onHover(handler => {
        var _a;
        return (_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.doHover(handler.textDocument.uri, handler.position);
    });
    connection.onSignatureHelp(handler => {
        var _a;
        return (_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.getSignatureHelp(handler.textDocument.uri, handler.position, handler.context);
    });
    connection.onPrepareRename(handler => {
        var _a;
        return (_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.prepareRename(handler.textDocument.uri, handler.position);
    });
    connection.onRenameRequest(async (handler) => {
        var _a;
        return await ((_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.doRename(handler.textDocument.uri, handler.position, handler.newName));
    });
    connection.onCodeLens(handler => {
        var _a;
        return (_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.getCodeLens(handler.textDocument.uri);
    });
    connection.onCodeLensResolve(codeLens => {
        var _a, _b, _c;
        const uri = (_a = codeLens.data) === null || _a === void 0 ? void 0 : _a.uri;
        return (_c = (_b = projects
            .get(uri)) === null || _b === void 0 ? void 0 : _b.service.doCodeLensResolve(codeLens, typeof features.codeLens === 'object' && features.codeLens.showReferencesNotification)) !== null && _c !== void 0 ? _c : codeLens;
    });
    connection.onExecuteCommand(handler => {
        var _a, _b;
        const uri = (_a = handler.arguments) === null || _a === void 0 ? void 0 : _a[0];
        return (_b = projects
            .get(uri)) === null || _b === void 0 ? void 0 : _b.service.__internal__.executeCommand(uri, handler.command, handler.arguments, connection);
    });
    connection.onCodeAction(async (handler) => {
        const uri = handler.textDocument.uri;
        const project = projects.get(uri);
        if (project) {
            const codeActions = await project.service.getCodeActions(uri, handler.range, handler.context);
            for (const codeAction of codeActions) {
                if (codeAction.data && typeof codeAction.data === 'object') {
                    codeAction.data.uri = uri;
                }
                else {
                    codeAction.data = { uri };
                }
            }
            return codeActions;
        }
    });
    connection.onCodeActionResolve(async (codeAction) => {
        var _a;
        const uri = (_a = codeAction.data) === null || _a === void 0 ? void 0 : _a.uri;
        const project = uri ? projects.get(uri) : undefined;
        if (project) {
            return await project.service.doCodeActionResolve(codeAction);
        }
        return codeAction;
    });
    connection.onReferences(async (handler) => {
        var _a, _b;
        const result = await ((_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.findReferences(handler.textDocument.uri, handler.position));
        if (result && ((_b = documents.get(handler.textDocument.uri)) === null || _b === void 0 ? void 0 : _b.languageId) !== 'vue') {
            return result.filter(loc => loc.uri.endsWith('.vue'));
        }
        return result;
    });
    connection.onDefinition(async (handler) => {
        var _a, _b;
        const result = await ((_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.findDefinition(handler.textDocument.uri, handler.position));
        if (result && ((_b = documents.get(handler.textDocument.uri)) === null || _b === void 0 ? void 0 : _b.languageId) !== 'vue') {
            return result.filter(loc => {
                if (vscode.Location.is(loc))
                    return loc.uri.endsWith('.vue');
                else
                    return loc.targetUri.endsWith('.vue');
            });
        }
        return result;
    });
    connection.onTypeDefinition(handler => {
        var _a;
        return (_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.findTypeDefinition(handler.textDocument.uri, handler.position);
    });
    connection.onDocumentHighlight(handler => {
        var _a;
        return (_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.findDocumentHighlights(handler.textDocument.uri, handler.position);
    });
    connection.onDocumentLinks(async (handler) => {
        var _a;
        return await ((_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.findDocumentLinks(handler.textDocument.uri));
    });
    connection.languages.callHierarchy.onPrepare(async (handler) => {
        var _a;
        const items = await ((_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.callHierarchy.doPrepare(handler.textDocument.uri, handler.position));
        if (items) {
            for (const item of items) {
                if (typeof item.data !== 'object')
                    item.data = {};
                item.data.__uri = handler.textDocument.uri;
            }
        }
        return (items === null || items === void 0 ? void 0 : items.length) ? items : null;
    });
    connection.languages.callHierarchy.onIncomingCalls(handler => {
        var _a, _b, _c;
        const data = handler.item.data;
        const uri = (_a = data === null || data === void 0 ? void 0 : data.__uri) !== null && _a !== void 0 ? _a : handler.item.uri;
        return (_c = (_b = projects
            .get(uri)) === null || _b === void 0 ? void 0 : _b.service.callHierarchy.getIncomingCalls(handler.item)) !== null && _c !== void 0 ? _c : [];
    });
    connection.languages.callHierarchy.onOutgoingCalls(handler => {
        var _a, _b, _c;
        const data = handler.item.data;
        const uri = (_a = data === null || data === void 0 ? void 0 : data.__uri) !== null && _a !== void 0 ? _a : handler.item.uri;
        return (_c = (_b = projects
            .get(uri)) === null || _b === void 0 ? void 0 : _b.service.callHierarchy.getOutgoingCalls(handler.item)) !== null && _c !== void 0 ? _c : [];
    });
    connection.languages.semanticTokens.on(async (handler, token, _, resultProgress) => {
        var _a, _b;
        const result = await ((_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.getSemanticTokens(handler.textDocument.uri, undefined, token, resultProgress));
        return {
            resultId: result === null || result === void 0 ? void 0 : result.resultId,
            data: (_b = result === null || result === void 0 ? void 0 : result.data) !== null && _b !== void 0 ? _b : [],
        };
    });
    connection.languages.semanticTokens.onRange(async (handler, token, _, resultProgress) => {
        var _a, _b;
        const result = await ((_a = projects
            .get(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.service.getSemanticTokens(handler.textDocument.uri, handler.range, token, resultProgress));
        return {
            resultId: result === null || result === void 0 ? void 0 : result.resultId,
            data: (_b = result === null || result === void 0 ? void 0 : result.data) !== null && _b !== void 0 ? _b : [],
        };
    });
    connection.workspace.onWillRenameFiles(async (handler) => {
        const hasTsFile = handler.files.some(file => file.newUri.endsWith('.vue') || file.newUri.endsWith('.ts') || file.newUri.endsWith('.tsx'));
        const config = await connection.workspace.getConfiguration(hasTsFile ? 'typescript.updateImportsOnFileMove.enabled' : 'javascript.updateImportsOnFileMove.enabled');
        if (config === 'always') {
            const renaming = new Promise(async (resolve) => {
                var _a, _b;
                for (const file of handler.files) {
                    const renameFileContent = project_1.getScriptText(ts, documents, shared.uriToFsPath(file.oldUri));
                    if (renameFileContent) {
                        project_1.renameFileContentCache.set(file.oldUri, renameFileContent);
                    }
                }
                await shared.sleep(0);
                const edit = await worker();
                if (edit) {
                    if (edit.documentChanges) {
                        for (const change of edit.documentChanges) {
                            if (vscode.TextDocumentEdit.is(change)) {
                                for (const file of handler.files) {
                                    if (change.textDocument.uri === file.oldUri) {
                                        change.textDocument.uri = file.newUri;
                                        change.textDocument.version = (_b = (_a = documents.get(file.newUri)) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : change.textDocument.version;
                                    }
                                }
                            }
                        }
                    }
                    connection.workspace.applyEdit(edit);
                }
                resolve();
            });
            project_1.fileRenamings.add(renaming);
            (async () => {
                await renaming;
                project_1.fileRenamings.delete(renaming);
                project_1.renameFileContentCache.clear();
            })();
        }
        if (config === 'prompt')
            return await worker();
        return null;
        async function worker() {
            const edits = (await Promise.all(handler.files
                .map(async (file) => {
                var _a;
                return await ((_a = projects.get(file.oldUri)) === null || _a === void 0 ? void 0 : _a.service.getEditsForFileRename(file.oldUri, file.newUri));
            }))).filter(shared.notEmpty);
            if (edits.length) {
                const result = edits[0];
                vue.margeWorkspaceEdits(result, ...edits.slice(1));
                return result;
            }
            return null;
        }
    });
}
exports.register = register;
//# sourceMappingURL=languageFeatures.js.map