"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSchemaRequestService = void 0;
const request_light_1 = require("request-light");
const vscode_uri_1 = require("vscode-uri");
const fs = require("fs");
const shared = require("@volar/shared");
function getHTTPRequestService() {
    return (uri, _encoding) => {
        const headers = { 'Accept-Encoding': 'gzip, deflate' };
        return request_light_1.xhr({ url: uri, followRedirects: 5, headers }).then(response => {
            return response.responseText;
        }, (error) => {
            return Promise.reject(error.responseText || request_light_1.getErrorStatusDescription(error.status) || error.toString());
        });
    };
}
function getFileRequestService() {
    return (location, encoding) => {
        return new Promise((c, e) => {
            const uri = vscode_uri_1.URI.parse(location);
            fs.readFile(uri.fsPath, encoding, (err, buf) => {
                if (err) {
                    return e(err);
                }
                c(buf.toString());
            });
        });
    };
}
const http = getHTTPRequestService();
const file = getFileRequestService();
function getSchemaRequestService(connection, options, handledSchemas = ['https', 'http', 'file']) {
    const builtInHandlers = {};
    for (let protocol of handledSchemas) {
        if (protocol === 'file') {
            builtInHandlers[protocol] = file;
        }
        else if (protocol === 'http' || protocol === 'https') {
            builtInHandlers[protocol] = http;
        }
    }
    return (uri) => {
        const protocol = uri.substr(0, uri.indexOf(':'));
        const builtInHandler = builtInHandlers[protocol];
        if (builtInHandler) {
            return builtInHandler(uri);
        }
        if (typeof options === 'object' && options.getDocumentContentRequest) {
            return connection.sendRequest(shared.GetDocumentContentRequest.type, { uri }).then(responseText => {
                return responseText;
            }, error => {
                return Promise.reject(error.message);
            });
        }
        else {
            return Promise.reject('clientHandledGetDocumentContentRequest is false');
        }
    };
}
exports.getSchemaRequestService = getSchemaRequestService;
//# sourceMappingURL=schemaRequestService.js.map