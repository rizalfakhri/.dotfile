"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPreferences = exports.getFormatOptions = void 0;
async function getFormatOptions(connection, document, options) {
    let config = await connection.workspace.getConfiguration({
        section: isTypeScriptDocument(document) ? 'typescript.format' : 'javascript.format',
        scopeUri: document.uri
    });
    config = config !== null && config !== void 0 ? config : {};
    return {
        tabSize: options === null || options === void 0 ? void 0 : options.tabSize,
        indentSize: options === null || options === void 0 ? void 0 : options.tabSize,
        convertTabsToSpaces: options === null || options === void 0 ? void 0 : options.insertSpaces,
        // We can use \n here since the editor normalizes later on to its line endings.
        newLineCharacter: '\n',
        insertSpaceAfterCommaDelimiter: config['insertSpaceAfterCommaDelimiter'],
        insertSpaceAfterConstructor: config['insertSpaceAfterConstructor'],
        insertSpaceAfterSemicolonInForStatements: config['insertSpaceAfterSemicolonInForStatements'],
        insertSpaceBeforeAndAfterBinaryOperators: config['insertSpaceBeforeAndAfterBinaryOperators'],
        insertSpaceAfterKeywordsInControlFlowStatements: config['insertSpaceAfterKeywordsInControlFlowStatements'],
        insertSpaceAfterFunctionKeywordForAnonymousFunctions: config['insertSpaceAfterFunctionKeywordForAnonymousFunctions'],
        insertSpaceBeforeFunctionParenthesis: config['insertSpaceBeforeFunctionParenthesis'],
        insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: config['insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis'],
        insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: config['insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets'],
        insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: config['insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces'],
        insertSpaceAfterOpeningAndBeforeClosingEmptyBraces: config['insertSpaceAfterOpeningAndBeforeClosingEmptyBraces'],
        insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: config['insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces'],
        insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: config['insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces'],
        insertSpaceAfterTypeAssertion: config['insertSpaceAfterTypeAssertion'],
        placeOpenBraceOnNewLineForFunctions: config['placeOpenBraceOnNewLineForFunctions'],
        placeOpenBraceOnNewLineForControlBlocks: config['placeOpenBraceOnNewLineForControlBlocks'],
        semicolons: config['semicolons'],
    };
}
exports.getFormatOptions = getFormatOptions;
async function getPreferences(connection, document) {
    var _a, _b, _c, _d, _e;
    let [config, preferencesConfig] = await connection.workspace.getConfiguration([
        {
            section: isTypeScriptDocument(document) ? 'typescript' : 'javascript',
            scopeUri: document.uri
        },
        {
            section: isTypeScriptDocument(document) ? 'typescript.preferences' : 'javascript.preferences',
            scopeUri: document.uri
        }
    ]);
    config = config !== null && config !== void 0 ? config : {};
    preferencesConfig = preferencesConfig !== null && preferencesConfig !== void 0 ? preferencesConfig : {};
    const preferences = {
        quotePreference: getQuoteStylePreference(preferencesConfig),
        importModuleSpecifierPreference: getImportModuleSpecifierPreference(preferencesConfig),
        importModuleSpecifierEnding: getImportModuleSpecifierEndingPreference(preferencesConfig),
        allowTextChangesInNewFiles: document.uri.startsWith('file://'),
        providePrefixAndSuffixTextForRename: ((_a = preferencesConfig['renameShorthandProperties']) !== null && _a !== void 0 ? _a : true) === false ? false : ((_b = preferencesConfig['useAliasesForRenames']) !== null && _b !== void 0 ? _b : true),
        // allowRenameOfImportPath: true,
        includeAutomaticOptionalChainCompletions: (_c = config['suggest.includeAutomaticOptionalChainCompletions']) !== null && _c !== void 0 ? _c : true,
        provideRefactorNotApplicableReason: true,
        // generateReturnInDocTemplate: config['suggest.jsdoc.generateReturns'] as boolean ?? true,
        includeCompletionsForImportStatements: (_d = config['suggest.includeCompletionsForImportStatements']) !== null && _d !== void 0 ? _d : true,
        includeCompletionsWithSnippetText: (_e = config['suggest.includeCompletionsWithSnippetText']) !== null && _e !== void 0 ? _e : true,
        displayPartsForJSDoc: true,
    };
    return preferences;
}
exports.getPreferences = getPreferences;
function getQuoteStylePreference(config) {
    switch (config['quoteStyle']) {
        case 'single': return 'single';
        case 'double': return 'double';
        default: return 'auto';
    }
}
function getImportModuleSpecifierPreference(config) {
    switch (config['importModuleSpecifier']) {
        case 'project-relative': return 'project-relative';
        case 'relative': return 'relative';
        case 'non-relative': return 'non-relative';
        default: return undefined;
    }
}
function getImportModuleSpecifierEndingPreference(config) {
    switch (config['importModuleSpecifierEnding']) {
        case 'minimal': return 'minimal';
        case 'index': return 'index';
        case 'js': return 'js';
        default: return 'auto';
    }
}
function isTypeScriptDocument(doc) {
    return ['typescript', 'typescriptreact'].includes(doc.languageId);
}
//# sourceMappingURL=tsConfigs.js.map