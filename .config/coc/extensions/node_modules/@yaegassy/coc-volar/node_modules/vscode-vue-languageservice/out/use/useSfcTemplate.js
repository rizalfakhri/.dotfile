"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSfcTemplate = void 0;
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const shared = require("@volar/shared");
const reactivity_1 = require("@vue/reactivity");
const SourceMaps = require("../utils/sourceMaps");
function useSfcTemplate(getUnreactiveDoc, template, context) {
    let version = 0;
    const textDocument = reactivity_1.computed(() => {
        if (template.value) {
            const vueDoc = getUnreactiveDoc();
            const langId = shared.syntaxToLanguageId(template.value.lang);
            const uri = vueDoc.uri + '.' + template.value.lang;
            const content = template.value.content;
            const document = vscode_languageserver_textdocument_1.TextDocument.create(uri, langId, version++, content);
            return document;
        }
    });
    const htmlDocument = reactivity_1.computed(() => {
        var _a;
        if (((_a = textDocument.value) === null || _a === void 0 ? void 0 : _a.languageId) === 'html') {
            return context.htmlLs.parseHTMLDocument(textDocument.value);
        }
    });
    const htmlSourceMap = reactivity_1.computed(() => {
        if (textDocument.value && textDocument.value && template.value && htmlDocument.value) {
            const vueDoc = getUnreactiveDoc();
            const sourceMap = new SourceMaps.HtmlSourceMap(vueDoc, textDocument.value, htmlDocument.value);
            sourceMap.add({
                data: undefined,
                mode: SourceMaps.Mode.Offset,
                sourceRange: {
                    start: template.value.loc.start,
                    end: template.value.loc.end,
                },
                mappedRange: {
                    start: 0,
                    end: template.value.loc.end - template.value.loc.start,
                },
            });
            return sourceMap;
        }
    });
    const pugDocument = reactivity_1.computed(() => {
        var _a;
        if (((_a = textDocument.value) === null || _a === void 0 ? void 0 : _a.languageId) === 'jade') {
            return context.pugLs.parsePugDocument(textDocument.value);
        }
    });
    const pugSourceMap = reactivity_1.computed(() => {
        if (textDocument.value && template.value && pugDocument.value) {
            const vueDoc = getUnreactiveDoc();
            const sourceMap = new SourceMaps.PugSourceMap(vueDoc, textDocument.value, pugDocument.value);
            sourceMap.add({
                data: undefined,
                mode: SourceMaps.Mode.Offset,
                sourceRange: {
                    start: template.value.loc.start,
                    end: template.value.loc.end,
                },
                mappedRange: {
                    start: 0,
                    end: template.value.loc.end - template.value.loc.start,
                },
            });
            return sourceMap;
        }
    });
    return {
        textDocument,
        htmlSourceMap,
        pugSourceMap,
        htmlDocument,
        pugDocument,
    };
}
exports.useSfcTemplate = useSfcTemplate;
//# sourceMappingURL=useSfcTemplate.js.map