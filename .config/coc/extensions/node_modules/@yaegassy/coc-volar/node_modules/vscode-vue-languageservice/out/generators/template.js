"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPatchForSlotNode = exports.generate = exports.transformContext = void 0;
const SourceMaps = require("../utils/sourceMaps");
const code_gen_1 = require("@volar/code-gen");
const shared_1 = require("@vue/shared");
const CompilerDOM = require("@vue/compiler-dom");
const CompilerCore = require("@vue/compiler-core");
const capabilitiesSet = {
    all: { basic: true, diagnostic: true, references: true, definitions: true, rename: true, completion: true, semanticTokens: true },
    noFormatting: { basic: true, diagnostic: true, references: true, definitions: true, rename: true, completion: true, semanticTokens: true },
    diagnosticOnly: { diagnostic: true, completion: true, },
    tag: { basic: true, diagnostic: true, references: true, definitions: true, rename: true, },
    attr: { basic: true, extraHoverInfo: true, diagnostic: true, references: true, definitions: true, rename: true, },
    scopedClassName: { references: true, definitions: true, rename: true, },
    slotName: { basic: true, diagnostic: true, references: true, definitions: true, completion: true, },
    slotNameExport: { basic: true, diagnostic: true, references: true, definitions: true, referencesCodeLens: true },
    referencesOnly: { references: true, definitions: true, },
};
const formatBrackets = {
    empty: ['', ''],
    round: ['(', ')'],
    curly: ['{', '}'],
    square: ['[', ']'],
};
const validTsVar = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
// @ts-ignore
exports.transformContext = {
    onError: () => { },
    helperString: str => str.toString(),
    replaceNode: node => { },
    cacheHandlers: false,
    prefixIdentifiers: false,
    scopes: {
        vFor: 0,
        vOnce: 0,
        vPre: 0,
        vSlot: 0,
    },
};
function generate(sourceLang, templateAst, isVue2, componentNames = [], setupReturns = [], cssScopedClasses = [], htmlToTemplate) {
    const tsCodeGen = code_gen_1.createCodeGen();
    const tsFormatCodeGen = code_gen_1.createCodeGen();
    const cssCodeGen = code_gen_1.createCodeGen();
    const usedComponents = new Set();
    const tagNames = new Set();
    const attrNames = new Set();
    const slots = new Map();
    const slotExps = new Map();
    const componentsMap = new Map();
    const componentNamesSet = new Set(componentNames);
    const setupReturnsSet = new Set(setupReturns);
    const cssScopedClassesSet = new Set(cssScopedClasses);
    for (const componentName of componentNames) {
        const variantName = shared_1.hyphenate(componentName);
        if (!shared_1.isHTMLTag(variantName)) {
            componentsMap.set(variantName, componentName);
        }
    }
    let elementIndex = 0;
    for (const childNode of templateAst.children) {
        tsCodeGen.addText(`{\n`);
        visitNode(childNode, undefined);
        tsCodeGen.addText(`}\n`);
    }
    tsCodeGen.addText(`declare const __VLS_slots:\n`);
    for (const [exp, slot] of slotExps) {
        tsCodeGen.addText(`Record<NonNullable<typeof ${exp}>, typeof ${slot.varName}> &\n`);
    }
    tsCodeGen.addText(`{\n`);
    for (const [name, slot] of slots) {
        writeObjectProperty(name, slot.loc, {
            vueTag: 'template',
            capabilities: capabilitiesSet.slotNameExport,
        });
        tsCodeGen.addText(`: typeof ${slot.varName},\n`);
    }
    tsCodeGen.addText(`};\n`);
    tsCodeGen.addText(`export default __VLS_slots;\n`);
    return {
        codeGen: tsCodeGen,
        formatCodeGen: tsFormatCodeGen,
        cssCodeGen: cssCodeGen,
        usedComponents,
        tagNames,
        attrNames,
    };
    function getComponentName(tagName) {
        var _a;
        return (_a = componentsMap.get(tagName)) !== null && _a !== void 0 ? _a : tagName;
    }
    function visitNode(node, parentEl) {
        var _a;
        if (node.type === 1 /* ELEMENT */) {
            const patchForNode = getPatchForSlotNode(node);
            if (patchForNode) {
                visitNode(patchForNode, parentEl);
                return;
            }
            if (node.tag !== 'template') {
                parentEl = node;
            }
            const componentName = getComponentName(node.tag);
            usedComponents.add(componentName);
            tagNames.add(node.tag);
            tsCodeGen.addText(`{\n`);
            {
                if (componentNamesSet.has(componentName) && setupReturnsSet.has(componentName)) {
                    tsCodeGen.addText(`${componentName}; // ignore unused in setup returns\n`);
                }
                writeInlineCss(node);
                if (parentEl)
                    writeImportSlots(node, parentEl);
                writeDirectives(node);
                writeElReferences(node); // <el ref="foo" />
                writeProps(node, true);
                writeProps(node, false);
                writeClassScopeds(node);
                writeEvents(node);
                writeOptionReferences(node);
                writeSlots(node);
                for (const childNode of node.children) {
                    visitNode(childNode, parentEl);
                }
            }
            tsCodeGen.addText('}\n');
        }
        else if (node.type === 12 /* TEXT_CALL */) {
            // {{ var }}
            visitNode(node.content, parentEl);
        }
        else if (node.type === 8 /* COMPOUND_EXPRESSION */) {
            // {{ ... }} {{ ... }}
            for (const childNode of node.children) {
                if (typeof childNode === 'object') {
                    visitNode(childNode, parentEl);
                }
            }
        }
        else if (node.type === 5 /* INTERPOLATION */) {
            // {{ ... }}
            const context = node.loc.source.substring(2, node.loc.source.length - 2);
            let start = node.loc.start.offset + 2;
            tsCodeGen.addText(`{`);
            writeCode(context, {
                start: start,
                end: start + context.length,
            }, SourceMaps.Mode.Offset, {
                vueTag: 'template',
                capabilities: capabilitiesSet.all,
            }, formatBrackets.curly);
            tsCodeGen.addText(`};\n`);
        }
        else if (node.type === 9 /* IF */) {
            // v-if / v-else-if / v-else
            for (let i = 0; i < node.branches.length; i++) {
                const branch = node.branches[i];
                if (i === 0)
                    tsCodeGen.addText('if');
                else if (branch.condition)
                    tsCodeGen.addText('else if');
                else
                    tsCodeGen.addText('else');
                if (((_a = branch.condition) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */) {
                    tsCodeGen.addText(` (`);
                    writeCode(branch.condition.content, {
                        start: branch.condition.loc.start.offset,
                        end: branch.condition.loc.end.offset,
                    }, SourceMaps.Mode.Offset, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.all,
                    }, formatBrackets.round);
                    tsCodeGen.addText(`)`);
                }
                tsCodeGen.addText(` {\n`);
                for (const childNode of branch.children) {
                    visitNode(childNode, parentEl);
                }
                tsCodeGen.addText('}\n');
            }
        }
        else if (node.type === 11 /* FOR */) {
            // v-for
            const source = node.parseResult.source;
            const value = node.parseResult.value;
            const key = node.parseResult.key;
            const index = node.parseResult.index;
            if (value
                && source.type === 4 /* SIMPLE_EXPRESSION */
                && value.type === 4 /* SIMPLE_EXPRESSION */) {
                let start_value = value.loc.start.offset;
                let start_source = source.loc.start.offset;
                const sourceVarName = `__VLS_${elementIndex++}`;
                const forOfItemName = `__VLS_${elementIndex++}`;
                // const __VLS_100 = 123;
                // const __VLS_100 = vmValue;
                tsCodeGen.addText(`const ${sourceVarName} = __VLS_getVforSourceType(`);
                writeCode(source.content, {
                    start: start_source,
                    end: start_source + source.content.length,
                }, SourceMaps.Mode.Offset, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.all,
                }, formatBrackets.round);
                tsCodeGen.addText(`);\n`);
                tsCodeGen.addText(`for (var ${forOfItemName} of ${sourceVarName}) { }\n`);
                tsCodeGen.addText(`for (const __VLS_${elementIndex++} in `);
                writeCode(sourceVarName, {
                    start: source.loc.start.offset,
                    end: source.loc.end.offset,
                }, SourceMaps.Mode.Totally, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.diagnosticOnly,
                });
                tsCodeGen.addText(`) {\n`);
                tsCodeGen.addText(`const `);
                writeCode(value.content, {
                    start: start_value,
                    end: start_value + value.content.length,
                }, SourceMaps.Mode.Offset, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.all,
                }, formatBrackets.empty);
                tsCodeGen.addText(` = __VLS_pickForItem(${sourceVarName}, ${forOfItemName}, ${sourceVarName}[__VLS_getVforKeyType(${sourceVarName})]);\n`);
                if (key && key.type === 4 /* SIMPLE_EXPRESSION */) {
                    let start_key = key.loc.start.offset;
                    tsCodeGen.addText(`const `);
                    writeCode(key.content, {
                        start: start_key,
                        end: start_key + key.content.length,
                    }, SourceMaps.Mode.Offset, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.all,
                    }, formatBrackets.empty);
                    tsCodeGen.addText(` = __VLS_getVforKeyType(${sourceVarName});\n`);
                }
                if (index && index.type === 4 /* SIMPLE_EXPRESSION */) {
                    let start_index = index.loc.start.offset;
                    tsCodeGen.addText(`const `);
                    writeCode(index.content, {
                        start: start_index,
                        end: start_index + index.content.length,
                    }, SourceMaps.Mode.Offset, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.all,
                    }, formatBrackets.empty);
                    tsCodeGen.addText(` = __VLS_getVforIndexType(${sourceVarName});\n`);
                }
                for (const childNode of node.children) {
                    visitNode(childNode, parentEl);
                }
                tsCodeGen.addText('}\n');
            }
        }
        else if (node.type === 2 /* TEXT */) {
            // not needed progress
        }
        else if (node.type === 3 /* COMMENT */) {
            // not needed progress
        }
        else {
            tsCodeGen.addText(`// Unprocessed node type: ${node.type} json: ${JSON.stringify(node.loc)}\n`);
        }
    }
    ;
    function writeInlineCss(node) {
        var _a, _b;
        for (const prop of node.props) {
            if (prop.type === 7 /* DIRECTIVE */
                && prop.name === 'bind'
                && ((_a = prop.arg) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */
                && ((_b = prop.exp) === null || _b === void 0 ? void 0 : _b.type) === 4 /* SIMPLE_EXPRESSION */
                && prop.arg.content === 'style'
                && prop.exp.constType === 3 /* CAN_STRINGIFY */) {
                const endCrt = prop.arg.loc.source[prop.arg.loc.source.length - 1]; // " | '
                const start = prop.arg.loc.source.indexOf(endCrt) + 1;
                const end = prop.arg.loc.source.lastIndexOf(endCrt);
                const content = prop.arg.loc.source.substring(start, end);
                const sourceRange = {
                    start: prop.arg.loc.start.offset + start,
                    end: prop.arg.loc.start.offset + end,
                };
                const newStart = htmlToTemplate(sourceRange.start, sourceRange.end);
                if (newStart === undefined)
                    continue;
                const offset = newStart - sourceRange.start;
                sourceRange.start += offset;
                sourceRange.end += offset;
                cssCodeGen.addText(`${node.tag} { `);
                cssCodeGen.addCode(content, sourceRange, SourceMaps.Mode.Offset, undefined);
                cssCodeGen.addText(` }\n`);
            }
        }
    }
    function writeImportSlots(node, parentEl) {
        var _a, _b;
        for (const prop of node.props) {
            if (prop.type === 7 /* DIRECTIVE */
                && prop.name === 'slot') {
                if (((_a = prop.exp) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */) {
                    tsCodeGen.addText(`const `);
                    writeCode(prop.exp.content, {
                        start: prop.exp.loc.start.offset,
                        end: prop.exp.loc.end.offset,
                    }, SourceMaps.Mode.Offset, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.all,
                    }, formatBrackets.round);
                    tsCodeGen.addText(` = `);
                }
                let slotName = 'default';
                let isStatic = true;
                if (((_b = prop.arg) === null || _b === void 0 ? void 0 : _b.type) === 4 /* SIMPLE_EXPRESSION */ && prop.arg.content !== '') {
                    isStatic = prop.arg.isStatic;
                    slotName = prop.arg.content;
                }
                const diagStart = tsCodeGen.getText().length;
                tsCodeGen.addText(`__VLS_components_0['${getComponentName(parentEl.tag)}'].__VLS_slots`);
                const argRange = prop.arg
                    ? {
                        start: prop.arg.loc.start.offset,
                        end: prop.arg.loc.end.offset,
                    } : {
                    start: prop.loc.start.offset,
                    end: prop.loc.start.offset + prop.loc.source.split('=')[0].length,
                };
                if (isStatic) {
                    writePropertyAccess(slotName, argRange, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.slotName,
                    });
                }
                else {
                    tsCodeGen.addText(`[`);
                    writeCode(slotName, {
                        start: argRange.start + 1,
                        end: argRange.end - 1,
                    }, SourceMaps.Mode.Offset, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.all,
                    });
                    tsCodeGen.addText(`]`);
                }
                const diagEnd = tsCodeGen.getText().length;
                addMapping(tsCodeGen, {
                    mappedRange: {
                        start: diagStart,
                        end: diagEnd,
                    },
                    sourceRange: argRange,
                    mode: SourceMaps.Mode.Totally,
                    data: {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.diagnosticOnly,
                    },
                });
                tsCodeGen.addText(`;\n`);
            }
        }
    }
    function writeOptionReferences(node) {
        var _a;
        // fix find references not work if prop has default value
        // fix emits references not work
        for (const prop of node.props) {
            if (prop.type === 7 /* DIRECTIVE */
                && prop.arg
                && (!prop.exp || prop.exp.type === 4 /* SIMPLE_EXPRESSION */)
                && prop.arg.type === 4 /* SIMPLE_EXPRESSION */
                && !(((_a = prop.exp) === null || _a === void 0 ? void 0 : _a.constType) === 3 /* CAN_STRINGIFY */) // ignore style, style='z-index: 2' will compile to {'z-index':'2'}
            ) {
                if (prop.name === 'bind' || prop.name === 'model') {
                    write('props', prop.arg.content, prop.arg.loc.start.offset, prop.arg.loc.end.offset);
                }
                else if (prop.name === 'on') {
                    write('emits', prop.arg.content, prop.arg.loc.start.offset, prop.arg.loc.end.offset);
                }
            }
            else if (prop.type === 7 /* DIRECTIVE */
                && prop.name === 'model') {
                write('props', getModelValuePropName(node, isVue2), prop.loc.start.offset, prop.loc.start.offset + 'v-model'.length, false, false);
            }
            else if (prop.type === 6 /* ATTRIBUTE */) {
                write('props', prop.name, prop.loc.start.offset, prop.loc.start.offset + prop.name.length);
            }
        }
        function write(option, propName, start, end, checking = false, rename = true) {
            const props = new Set();
            const emits = new Set();
            if (option === 'props') {
                props.add(propName);
                props.add(shared_1.camelize(propName));
            }
            else if (option === 'emits') {
                emits.add(propName);
                emits.add(shared_1.camelize(propName));
                props.add(shared_1.camelize('on-' + propName));
            }
            for (const name of props.values()) {
                // __VLS_options.props
                if (!checking)
                    tsCodeGen.addText(`// @ts-ignore\n`);
                tsCodeGen.addText(`__VLS_components_0['${getComponentName(node.tag)}'].__VLS_options.props`);
                writePropertyAccess(name, {
                    start,
                    end,
                }, {
                    vueTag: 'template',
                    capabilities: {
                        ...capabilitiesSet.attr,
                        basic: false,
                        rename: rename,
                    },
                    doRename: keepHyphenateName,
                });
                tsCodeGen.addText(`;\n`);
            }
            for (const name of emits.values()) {
                // __VLS_options.emits
                if (!checking)
                    tsCodeGen.addText(`// @ts-ignore\n`);
                tsCodeGen.addText(`__VLS_components_0['${getComponentName(node.tag)}'].__VLS_options.emits`);
                writePropertyAccess(name, {
                    start,
                    end,
                }, {
                    vueTag: 'template',
                    capabilities: {
                        ...capabilitiesSet.attr,
                        basic: false,
                        rename: rename,
                    },
                    doRename: keepHyphenateName,
                });
                tsCodeGen.addText(`;\n`);
            }
        }
    }
    function writeDirectives(node) {
        var _a;
        for (const prop of node.props) {
            if (prop.type === 7 /* DIRECTIVE */
                && prop.name !== 'slot'
                && prop.name !== 'model'
                && prop.name !== 'bind'
                && !prop.arg
                && ((_a = prop.exp) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */) {
                tsCodeGen.addText(`(`);
                writeCode(prop.exp.content, {
                    start: prop.exp.loc.start.offset,
                    end: prop.exp.loc.end.offset,
                }, SourceMaps.Mode.Offset, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.all,
                }, formatBrackets.round);
                tsCodeGen.addText(`);\n`);
            }
        }
    }
    function writeElReferences(node) {
        for (const prop of node.props) {
            if (prop.type === 6 /* ATTRIBUTE */
                && prop.name === 'ref'
                && prop.value) {
                tsCodeGen.addText(`// @ts-ignore\n`);
                tsCodeGen.addText(`(`);
                writeCode(prop.value.content, {
                    start: prop.value.loc.start.offset + 1,
                    end: prop.value.loc.end.offset - 1,
                }, SourceMaps.Mode.Offset, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.referencesOnly,
                });
                tsCodeGen.addText(`);\n`);
            }
        }
    }
    function writeProps(node, forDirectiveClassOrStyle) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        let startDiag;
        let endDiag;
        if (forDirectiveClassOrStyle) {
            tsCodeGen.addText(`__VLS_componentProps['${getComponentName(node.tag)}']({\n`);
        }
        else {
            startDiag = addStartWrap();
        }
        for (const prop of node.props) {
            if (prop.type === 7 /* DIRECTIVE */
                && (prop.name === 'bind' || prop.name === 'model')
                && (prop.name === 'model' || ((_a = prop.arg) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */)
                && (!prop.exp || prop.exp.type === 4 /* SIMPLE_EXPRESSION */)) {
                const propName_1 = ((_b = prop.arg) === null || _b === void 0 ? void 0 : _b.type) === 4 /* SIMPLE_EXPRESSION */ ? prop.arg.content : getModelValuePropName(node, isVue2);
                const propName_2 = shared_1.hyphenate(propName_1) === propName_1 ? shared_1.camelize(propName_1) : propName_1;
                const propValue = (_d = (_c = prop.exp) === null || _c === void 0 ? void 0 : _c.content) !== null && _d !== void 0 ? _d : 'undefined';
                const isClassOrStyleAttr = ['style', 'class'].includes(propName_2);
                const isDirective = !prop.exp || prop.exp.constType !== 3 /* CAN_STRINGIFY */;
                if ((isClassOrStyleAttr && isDirective) !== forDirectiveClassOrStyle) {
                    continue;
                }
                if (((_e = prop.arg) === null || _e === void 0 ? void 0 : _e.type) === 4 /* SIMPLE_EXPRESSION */) {
                    attrNames.add(prop.arg.content);
                }
                // camelize name
                const diagStart = tsCodeGen.getText().length;
                // `'${propName}': (${propValue})`
                if (!prop.arg) {
                    writeObjectProperty(propName_1, {
                        start: prop.loc.start.offset,
                        end: prop.loc.start.offset + 'v-model'.length,
                    }, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.attr,
                    });
                }
                else if (((_f = prop.exp) === null || _f === void 0 ? void 0 : _f.constType) === 3 /* CAN_STRINGIFY */) {
                    writeObjectProperty(propName_2, {
                        start: prop.arg.loc.start.offset,
                        end: prop.arg.loc.start.offset + propName_1.length, // patch style attr
                    }, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.attr,
                        doRename: keepHyphenateName,
                    });
                }
                else {
                    writeObjectProperty(propName_2, {
                        start: prop.arg.loc.start.offset,
                        end: prop.arg.loc.end.offset,
                    }, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.attr,
                        doRename: keepHyphenateName,
                    });
                }
                tsCodeGen.addText(`: (`);
                if (prop.exp && !(prop.exp.constType === 3 /* CAN_STRINGIFY */)) { // style='z-index: 2' will compile to {'z-index':'2'}
                    writeCode(propValue, {
                        start: prop.exp.loc.start.offset,
                        end: prop.exp.loc.end.offset,
                    }, SourceMaps.Mode.Offset, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.all,
                    }, formatBrackets.round);
                }
                else {
                    tsCodeGen.addText(propValue);
                }
                tsCodeGen.addText(`)`);
                addMapping(tsCodeGen, {
                    sourceRange: {
                        start: prop.loc.start.offset,
                        end: prop.loc.end.offset,
                    },
                    mappedRange: {
                        start: diagStart,
                        end: tsCodeGen.getText().length,
                    },
                    mode: SourceMaps.Mode.Totally,
                    data: {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.diagnosticOnly,
                    },
                });
                tsCodeGen.addText(`,\n`);
                // original name
                if (prop.arg && propName_1 !== propName_2) {
                    writeObjectProperty(propName_1, {
                        start: prop.arg.loc.start.offset,
                        end: prop.arg.loc.end.offset,
                    }, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.attr,
                        doRename: keepHyphenateName,
                    });
                    tsCodeGen.addText(`: (${propValue}),\n`);
                }
            }
            else if (prop.type === 6 /* ATTRIBUTE */) {
                if (forDirectiveClassOrStyle) {
                    continue;
                }
                const propName = shared_1.hyphenate(prop.name) === prop.name ? shared_1.camelize(prop.name) : prop.name;
                const propName2 = prop.name;
                const isClassOrStyleAttr = ['style', 'class'].includes(propName);
                attrNames.add(prop.name);
                if (isClassOrStyleAttr) {
                    tsCodeGen.addText(`// @ts-ignore\n`);
                }
                // camelize name
                const diagStart = tsCodeGen.getText().length;
                writeObjectProperty(propName, {
                    start: prop.loc.start.offset,
                    end: prop.loc.start.offset + propName2.length,
                }, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.attr,
                    doRename: keepHyphenateName,
                });
                tsCodeGen.addText(': ');
                writeAttrValue(prop.value, getComponentName(node.tag), propName);
                const diagEnd = tsCodeGen.getText().length;
                tsCodeGen.addText(',\n');
                addMapping(tsCodeGen, {
                    sourceRange: {
                        start: prop.loc.start.offset,
                        end: prop.loc.end.offset,
                    },
                    mappedRange: {
                        start: diagStart,
                        end: diagEnd,
                    },
                    mode: SourceMaps.Mode.Totally,
                    data: {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.diagnosticOnly,
                    },
                });
                // original name
                if (propName2 !== propName) {
                    writeObjectProperty(propName2, {
                        start: prop.loc.start.offset,
                        end: prop.loc.start.offset + propName2.length,
                    }, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.attr,
                        doRename: keepHyphenateName,
                    });
                    tsCodeGen.addText(': ');
                    writeAttrValue(prop.value, getComponentName(node.tag), propName);
                    tsCodeGen.addText(',\n');
                }
            }
            else if (prop.type === 7 /* DIRECTIVE */
                && prop.name === 'bind'
                && !prop.arg
                && ((_g = prop.exp) === null || _g === void 0 ? void 0 : _g.type) === 4 /* SIMPLE_EXPRESSION */) {
                if (forDirectiveClassOrStyle) {
                    continue;
                }
                tsCodeGen.addText('...(');
                writeCode(prop.exp.content, {
                    start: prop.exp.loc.start.offset,
                    end: prop.exp.loc.end.offset,
                }, SourceMaps.Mode.Offset, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.all,
                }, formatBrackets.round);
                tsCodeGen.addText('),\n');
            }
            else {
                if (forDirectiveClassOrStyle) {
                    continue;
                }
                tsCodeGen.addText("/* " + [prop.type, prop.name, (_h = prop.arg) === null || _h === void 0 ? void 0 : _h.loc.source, (_j = prop.exp) === null || _j === void 0 ? void 0 : _j.loc.source, prop.loc.source].join(", ") + " */\n");
            }
        }
        if (forDirectiveClassOrStyle) {
            tsCodeGen.addText(`});\n`);
        }
        else {
            endDiag = addEndWrap();
        }
        if (startDiag && endDiag) {
            addMapping(tsCodeGen, {
                mappedRange: {
                    start: startDiag,
                    end: endDiag,
                },
                sourceRange: {
                    start: node.loc.start.offset + node.loc.source.indexOf(node.tag),
                    end: node.loc.start.offset + node.loc.source.indexOf(node.tag) + node.tag.length,
                },
                mode: SourceMaps.Mode.Totally,
                data: {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.diagnosticOnly,
                },
            });
        }
        function writeAttrValue(attrNode, componentName, propName) {
            if (attrNode) {
                tsCodeGen.addText('"');
                let start = attrNode.loc.start.offset;
                let end = attrNode.loc.end.offset;
                if (end - start > attrNode.content.length) {
                    start++;
                    end--;
                }
                writeCode(toUnicode(attrNode.content), { start, end }, SourceMaps.Mode.Offset, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.all
                });
                tsCodeGen.addText('"');
            }
            else {
                tsCodeGen.addText(`{} as __VLS_ConstAttrType<typeof __VLS_componentProps['${componentName}'], '${propName}'>`);
            }
        }
        function addStartWrap() {
            const componentName = getComponentName(node.tag);
            { // start tag
                tsCodeGen.addText(`// @ts-ignore start tag\n__VLS_components`);
                writePropertyAccess(componentName, {
                    start: node.loc.start.offset + node.loc.source.indexOf(node.tag),
                    end: node.loc.start.offset + node.loc.source.indexOf(node.tag) + node.tag.length,
                }, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.tag,
                    beforeRename: node.tag === componentName ? undefined : unHyphenatComponentName,
                    doRename: keepHyphenateName,
                });
                tsCodeGen.addText(`;\n`);
            }
            if (!node.isSelfClosing && sourceLang === 'html') { // end tag
                tsCodeGen.addText(`// @ts-ignore end tag\n__VLS_components`);
                writePropertyAccess(componentName, {
                    start: node.loc.start.offset + node.loc.source.lastIndexOf(node.tag),
                    end: node.loc.start.offset + node.loc.source.lastIndexOf(node.tag) + node.tag.length,
                }, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.tag,
                    beforeRename: node.tag === componentName ? undefined : unHyphenatComponentName,
                    doRename: keepHyphenateName,
                });
                tsCodeGen.addText(`;\n`);
            }
            tsCodeGen.addText(`__VLS_componentProps['${getComponentName(node.tag)}'](`);
            const diagStart = tsCodeGen.getText().length;
            tsCodeGen.addText(`{\n`);
            return diagStart;
        }
        function addEndWrap() {
            tsCodeGen.addText(`}`);
            const diagEnd = tsCodeGen.getText().length;
            tsCodeGen.addText(`);\n`);
            return diagEnd;
        }
    }
    function writeClassScopeds(node) {
        for (const prop of node.props) {
            if (prop.type === 6 /* ATTRIBUTE */
                && prop.name === 'class'
                && prop.value) {
                let startOffset = prop.value.loc.start.offset + 1; // +1 is "
                let tempClassName = '';
                for (const char of (prop.value.content + ' ')) {
                    if (char.trim() !== '') {
                        tempClassName += char;
                    }
                    else {
                        addClass(tempClassName, startOffset);
                        startOffset += tempClassName.length + 1;
                        tempClassName = '';
                    }
                }
                function addClass(className, offset) {
                    tsCodeGen.addText(`// @ts-ignore\n`);
                    tsCodeGen.addText(`__VLS_styleScopedClasses`);
                    writePropertyAccess(className, {
                        start: offset,
                        end: offset + className.length,
                    }, {
                        vueTag: 'template',
                        capabilities: {
                            ...capabilitiesSet.scopedClassName,
                            displayWithLink: cssScopedClassesSet.has(className),
                        },
                    });
                    tsCodeGen.addText(`;\n`);
                }
            }
        }
    }
    function writeEvents(node) {
        var _a;
        for (const prop of node.props) {
            if (prop.type === 7 /* DIRECTIVE */
                && ((_a = prop.arg) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */
                && prop.name === 'on') {
                const var_on = `__VLS_${elementIndex++}`;
                let key_1 = prop.arg.content;
                let keyOffset = 0;
                const key_2 = shared_1.camelize('on-' + key_1);
                const key_3 = shared_1.camelize(key_1);
                tsCodeGen.addText(`let ${var_on}!: { `);
                tsCodeGen.addText(validTsVar.test(key_1) ? key_1 : `'${key_1}'`);
                tsCodeGen.addText(`: __VLS_FillingEventArg<__VLS_FirstFunction<\n`);
                if (key_1 !== key_3) {
                    tsCodeGen.addText(`__VLS_FirstFunction<\n`);
                    tsCodeGen.addText(`__VLS_EmitEvent<typeof __VLS_components['${getComponentName(node.tag)}'], '${key_1}'>,\n`);
                    tsCodeGen.addText(`__VLS_EmitEvent<typeof __VLS_components['${getComponentName(node.tag)}'], '${key_3}'>\n`);
                    tsCodeGen.addText(`>,\n`);
                }
                else {
                    tsCodeGen.addText(`__VLS_EmitEvent<typeof __VLS_components['${getComponentName(node.tag)}'], '${key_1}'>,\n`);
                }
                tsCodeGen.addText(`(typeof __VLS_componentPropsBase['${getComponentName(node.tag)}'] & __VLS_GlobalAttrs & Record<string, unknown>)[`);
                writeCodeWithQuotes(key_2, {
                    start: prop.arg.loc.start.offset,
                    end: prop.arg.loc.end.offset,
                }, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.attr,
                });
                tsCodeGen.addText(`]>>\n};\n`);
                const transformResult = CompilerDOM.transformOn(prop, node, exports.transformContext);
                for (const prop_2 of transformResult.props) {
                    const value = prop_2.value;
                    tsCodeGen.addText(`${var_on} = {\n`);
                    writeObjectProperty(key_1, {
                        start: prop.arg.loc.start.offset + keyOffset,
                        end: prop.arg.loc.end.offset,
                    }, {
                        vueTag: 'template',
                        capabilities: capabilitiesSet.attr,
                    });
                    tsCodeGen.addText(`: `);
                    appendExpressionNode(prop);
                    tsCodeGen.addText(`\n};\n`);
                    function appendExpressionNode(prop) {
                        var _a;
                        if (((_a = prop.exp) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */) {
                            if (value.type === 4 /* SIMPLE_EXPRESSION */) {
                                appendSimpleExpressionNode(value, prop.exp);
                            }
                            else if (value.type === 8 /* COMPOUND_EXPRESSION */) {
                                appendCompoundExpressionNode(value, prop.exp);
                            }
                        }
                        else {
                            tsCodeGen.addText(`undefined`);
                        }
                    }
                    function appendCompoundExpressionNode(node, exp) {
                        for (const child of node.children) {
                            if (typeof child === 'string') {
                                tsCodeGen.addText(child);
                            }
                            else if (typeof child === 'symbol') {
                                // ignore
                            }
                            else if (child.type === 4 /* SIMPLE_EXPRESSION */) {
                                appendSimpleExpressionNode(child, exp);
                            }
                        }
                    }
                    function appendSimpleExpressionNode(node, exp) {
                        if (node.content === exp.content) {
                            writeCode(node.content, {
                                start: exp.loc.start.offset,
                                end: exp.loc.end.offset,
                            }, SourceMaps.Mode.Offset, {
                                vueTag: 'template',
                                capabilities: capabilitiesSet.all,
                            }, formatBrackets.empty);
                        }
                        else {
                            tsCodeGen.addText(node.content);
                        }
                    }
                }
            }
        }
    }
    function writeSlots(node) {
        var _a, _b, _c;
        if (node.tag !== 'slot')
            return;
        const varDefaultBind = `__VLS_${elementIndex++}`;
        const varBinds = `__VLS_${elementIndex++}`;
        const varSlot = `__VLS_${elementIndex++}`;
        const slotName = getSlotName();
        const slotNameExp = getSlotNameExp();
        let hasDefaultBind = false;
        for (const prop of node.props) {
            if (prop.type === 7 /* DIRECTIVE */
                && !prop.arg
                && ((_a = prop.exp) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */) {
                hasDefaultBind = true;
                tsCodeGen.addText(`const ${varDefaultBind} = (`);
                writeCode(prop.exp.content, {
                    start: prop.exp.loc.start.offset,
                    end: prop.exp.loc.end.offset,
                }, SourceMaps.Mode.Offset, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.all,
                }, formatBrackets.round);
                tsCodeGen.addText(`);\n`);
                break;
            }
        }
        tsCodeGen.addText(`const ${varBinds} = {\n`);
        for (const prop of node.props) {
            if (prop.type === 7 /* DIRECTIVE */
                && ((_b = prop.arg) === null || _b === void 0 ? void 0 : _b.type) === 4 /* SIMPLE_EXPRESSION */
                && ((_c = prop.exp) === null || _c === void 0 ? void 0 : _c.type) === 4 /* SIMPLE_EXPRESSION */
                && prop.arg.content !== 'name') {
                writeObjectProperty(prop.arg.content, {
                    start: prop.arg.loc.start.offset,
                    end: prop.arg.loc.end.offset,
                }, {
                    vueTag: 'template',
                    doRename: keepHyphenateName,
                    capabilities: capabilitiesSet.attr,
                });
                tsCodeGen.addText(`: (`);
                writeCode(prop.exp.content, {
                    start: prop.exp.loc.start.offset,
                    end: prop.exp.loc.end.offset,
                }, SourceMaps.Mode.Offset, {
                    vueTag: 'template',
                    capabilities: capabilitiesSet.all,
                }, formatBrackets.round);
                tsCodeGen.addText(`),\n`);
            }
            else if (prop.type === 6 /* ATTRIBUTE */
                && prop.name !== 'name' // slot name
            ) {
                const propValue = prop.value !== undefined ? `"${toUnicode(prop.value.content)}"` : 'true';
                writeObjectProperty(prop.name, {
                    start: prop.loc.start.offset,
                    end: prop.loc.start.offset + prop.name.length
                }, {
                    vueTag: 'template',
                    doRename: keepHyphenateName,
                    capabilities: capabilitiesSet.attr,
                });
                tsCodeGen.addText(`: (`);
                tsCodeGen.addText(propValue);
                tsCodeGen.addText(`),\n`);
            }
        }
        tsCodeGen.addText(`};\n`);
        if (hasDefaultBind) {
            tsCodeGen.addText(`var ${varSlot}!: typeof ${varDefaultBind} & typeof ${varBinds};\n`);
        }
        else {
            tsCodeGen.addText(`var ${varSlot}!: typeof ${varBinds};\n`);
        }
        if (slotNameExp) {
            const varSlotExp = `__VLS_${elementIndex++}`;
            const varSlotExp2 = `__VLS_${elementIndex++}`;
            tsCodeGen.addText(`const ${varSlotExp} = ${slotNameExp};\n`);
            tsCodeGen.addText(`var ${varSlotExp2}!: typeof ${varSlotExp};\n`);
            slotExps.set(varSlotExp2, {
                varName: varSlot,
                loc: {
                    start: node.loc.start.offset + node.loc.source.indexOf(node.tag),
                    end: node.loc.start.offset + node.loc.source.indexOf(node.tag) + node.tag.length,
                },
            });
        }
        else {
            slots.set(slotName, {
                varName: varSlot,
                loc: {
                    start: node.loc.start.offset + node.loc.source.indexOf(node.tag),
                    end: node.loc.start.offset + node.loc.source.indexOf(node.tag) + node.tag.length,
                },
            });
        }
        function getSlotName() {
            for (const prop2 of node.props) {
                if (prop2.name === 'name' && prop2.type === 6 /* ATTRIBUTE */ && prop2.value) {
                    if (prop2.value.content) {
                        return prop2.value.content;
                    }
                }
            }
            return 'default';
        }
        function getSlotNameExp() {
            var _a, _b;
            for (const prop2 of node.props) {
                if (prop2.type === 7 /* DIRECTIVE */ && prop2.name === 'bind' && ((_a = prop2.arg) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */ && prop2.arg.content === 'name') {
                    if (((_b = prop2.exp) === null || _b === void 0 ? void 0 : _b.type) === 4 /* SIMPLE_EXPRESSION */) {
                        return prop2.exp.content;
                    }
                    else {
                        return `'default'`;
                    }
                }
            }
        }
    }
    function writeObjectProperty(mapCode, sourceRange, data) {
        if (validTsVar.test(mapCode)) {
            writeCode(mapCode, sourceRange, SourceMaps.Mode.Offset, data);
        }
        else {
            writeCodeWithQuotes(mapCode, sourceRange, data);
        }
    }
    function writePropertyAccess(mapCode, sourceRange, data) {
        if (validTsVar.test(mapCode)) {
            tsCodeGen.addText(`.`);
            if (sourceRange.end - sourceRange.start === mapCode.length) {
                return writeCode(mapCode, sourceRange, SourceMaps.Mode.Offset, data);
            }
            else {
                return writeCode(mapCode, sourceRange, SourceMaps.Mode.Expand, data);
            }
        }
        else {
            tsCodeGen.addText(`[`);
            writeCodeWithQuotes(mapCode, sourceRange, data);
            tsCodeGen.addText(`]`);
        }
    }
    function writeCodeWithQuotes(mapCode, sourceRange, data) {
        const addText = `'${mapCode}'`;
        addMapping(tsCodeGen, {
            sourceRange,
            mappedRange: {
                start: tsCodeGen.getText().length + 1,
                end: tsCodeGen.getText().length + addText.length - 1,
            },
            mode: SourceMaps.Mode.Offset,
            additional: [
                {
                    sourceRange,
                    mappedRange: {
                        start: tsCodeGen.getText().length,
                        end: tsCodeGen.getText().length + addText.length,
                    },
                    mode: SourceMaps.Mode.Totally,
                }
            ],
            data,
        });
        tsCodeGen.addText(addText);
    }
    function writeCode(mapCode, sourceRange, mode, data, formatWrapper) {
        if (formatWrapper) {
            tsFormatCodeGen.addText(formatWrapper[0]);
            const targetRange = tsFormatCodeGen.addText(mapCode);
            addMapping(tsFormatCodeGen, {
                mappedRange: targetRange,
                sourceRange,
                mode,
                data: {
                    vueTag: 'template',
                    capabilities: {
                        formatting: true,
                    },
                },
            });
            tsFormatCodeGen.addText(formatWrapper[1]);
            tsFormatCodeGen.addText(`\n;\n`);
        }
        const targetRange = tsCodeGen.addText(mapCode);
        addMapping(tsCodeGen, {
            sourceRange,
            mappedRange: targetRange,
            mode,
            data,
        });
    }
    function addMapping(gen, mapping) {
        const newMapping = { ...mapping };
        const templateStart = htmlToTemplate(mapping.sourceRange.start, mapping.sourceRange.end);
        if (templateStart === undefined)
            return; // not found
        const offset = templateStart - mapping.sourceRange.start;
        newMapping.sourceRange = {
            start: mapping.sourceRange.start + offset,
            end: mapping.sourceRange.end + offset,
        };
        if (mapping.additional) {
            newMapping.additional = [];
            for (const other of mapping.additional) {
                let otherTemplateStart = htmlToTemplate(other.sourceRange.start, other.sourceRange.end);
                if (otherTemplateStart === undefined)
                    continue;
                const otherOffset = otherTemplateStart - other.sourceRange.start;
                newMapping.additional.push({
                    ...other,
                    sourceRange: {
                        start: other.sourceRange.start + otherOffset,
                        end: other.sourceRange.end + otherOffset,
                    },
                });
            }
        }
        gen.addMapping2(newMapping);
    }
}
exports.generate = generate;
;
function toUnicode(str) {
    return str.split('').map(value => {
        var temp = value.charCodeAt(0).toString(16).padStart(4, '0');
        if (temp.length > 2) {
            return '\\u' + temp;
        }
        return value;
    }).join('');
}
function unHyphenatComponentName(newName) {
    return shared_1.camelize('-' + newName);
}
function keepHyphenateName(oldName, newName) {
    if (oldName === shared_1.hyphenate(oldName)) {
        return shared_1.hyphenate(newName);
    }
    return newName;
}
// https://github.com/vuejs/vue-next/blob/master/packages/compiler-dom/src/transforms/vModel.ts#L49-L51
// https://v3.vuejs.org/guide/forms.html#basic-usage
function getModelValuePropName(node, isVue2) {
    var _a;
    const tag = node.tag;
    const typeAttr = node.props.find(prop => prop.type === 6 /* ATTRIBUTE */ && prop.name === 'type');
    const type = (_a = typeAttr === null || typeAttr === void 0 ? void 0 : typeAttr.value) === null || _a === void 0 ? void 0 : _a.content;
    if (tag === 'input' && type === 'checkbox')
        return 'checked';
    if (tag === 'input' && type === 'radio')
        return '--radio-binding';
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isVue2)
        return 'value';
    return 'modelValue';
}
// TODO: track https://github.com/vuejs/vue-next/issues/3498
function getPatchForSlotNode(node) {
    const forDirective = node.props.find((prop) => prop.type === 7 /* DIRECTIVE */
        && prop.name === 'for');
    if (forDirective) {
        let forNode;
        CompilerCore.processFor(node, forDirective, exports.transformContext, _forNode => {
            forNode = { ..._forNode };
            return undefined;
        });
        if (forNode) {
            forNode.children = [{
                    ...node,
                    props: node.props.filter(prop => prop !== forDirective),
                }];
            return forNode;
        }
    }
}
exports.getPatchForSlotNode = getPatchForSlotNode;
//# sourceMappingURL=template.js.map