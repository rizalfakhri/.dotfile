"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSourceFile = exports.defaultLanguages = void 0;
const shared = require("@volar/shared");
const vueSfc = require("@vue/compiler-sfc");
const reactivity_1 = require("@vue/reactivity");
const vscode = require("vscode-languageserver");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const refSugarRanges_1 = require("./parsers/refSugarRanges");
const useSfcEntryForTemplateLs_1 = require("./use/useSfcEntryForTemplateLs");
const useSfcJsons_1 = require("./use/useSfcJsons");
const useSfcScript_1 = require("./use/useSfcScript");
const useSfcScriptGen_1 = require("./use/useSfcScriptGen");
const useSfcStyles_1 = require("./use/useSfcStyles");
const useSfcTemplate_1 = require("./use/useSfcTemplate");
const useSfcTemplateCompileResult_1 = require("./use/useSfcTemplateCompileResult");
const useSfcTemplateScript_1 = require("./use/useSfcTemplateScript");
const string_1 = require("./utils/string");
const untrack_1 = require("./utils/untrack");
exports.defaultLanguages = {
    template: 'html',
    script: 'js',
    style: 'css',
};
function createSourceFile(_document, context) {
    // refs
    const content = reactivity_1.ref(_document.getText());
    const version = reactivity_1.ref(_document.version);
    const document = reactivity_1.computed(() => vscode_languageserver_textdocument_1.TextDocument.create(_document.uri, _document.languageId, version.value, content.value));
    const descriptor = reactivity_1.reactive({
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
    });
    const lastUpdated = {
        template: false,
        script: false,
        scriptSetup: false,
    };
    const templateScriptData = reactivity_1.reactive({
        projectVersion: undefined,
        context: [],
        components: [],
        props: [],
        setupReturns: [],
        componentItems: [],
    });
    const vueHtmlDocument = reactivity_1.computed(() => {
        return context.htmlLs.parseHTMLDocument(document.value);
    });
    const sfcErrors = reactivity_1.ref([]);
    // use
    const sfcStyles = useSfcStyles_1.useSfcStyles(context, untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.styles));
    const sfcJsons = useSfcJsons_1.useSfcJsons(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.customBlocks), context);
    const sfcTemplate = useSfcTemplate_1.useSfcTemplate(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.template), context);
    const sfcTemplateData = reactivity_1.computed(() => {
        if (sfcTemplate.pugDocument.value) {
            const pugDoc = sfcTemplate.pugDocument.value;
            return {
                sourceLang: 'pug',
                html: pugDoc.htmlCode,
                htmlTextDocument: pugDoc.htmlTextDocument,
                htmlToTemplate: (htmlStart, htmlEnd) => {
                    const pugRange = pugDoc.sourceMap.getSourceRange2(htmlStart, htmlEnd);
                    if (pugRange) {
                        return pugRange.start;
                    }
                },
            };
        }
        if (descriptor.template && sfcTemplate.textDocument.value) {
            return {
                sourceLang: 'html',
                html: descriptor.template.content,
                htmlTextDocument: sfcTemplate.textDocument.value,
                htmlToTemplate: (htmlStart, _) => htmlStart,
            };
        }
    });
    const sfcTemplateCompileResult = useSfcTemplateCompileResult_1.useSfcTemplateCompileResult(reactivity_1.computed(() => { var _a; return (_a = sfcTemplateData.value) === null || _a === void 0 ? void 0 : _a.htmlTextDocument; }), context.isVue2Mode);
    const sfcScript = useSfcScript_1.useSfcScript(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.script), context.modules.typescript);
    const sfcScriptSetup = useSfcScript_1.useSfcScript(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.scriptSetup), context.modules.typescript);
    const sfcScriptForTemplateLs = useSfcScriptGen_1.useSfcScriptGen('template', context.modules.typescript, document, reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => sfcScript.ast.value), reactivity_1.computed(() => sfcScriptSetup.ast.value), sfcTemplateCompileResult, reactivity_1.computed(() => sfcStyles.textDocuments.value));
    const sfcScriptForScriptLs = useSfcScriptGen_1.useSfcScriptGen('script', context.modules.typescript, document, reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => sfcScript.ast.value), reactivity_1.computed(() => sfcScriptSetup.ast.value), sfcTemplateCompileResult, reactivity_1.computed(() => sfcStyles.textDocuments.value));
    const sfcEntryForTemplateLs = useSfcEntryForTemplateLs_1.useSfcEntryForTemplateLs(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => descriptor.template), reactivity_1.computed(() => !!sfcScriptForTemplateLs.textDocumentTs.value));
    const sfcTemplateScript = useSfcTemplateScript_1.useSfcTemplateScript(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.template), reactivity_1.computed(() => descriptor.styles), templateScriptData, sfcStyles.textDocuments, sfcStyles.sourceMaps, sfcTemplateData, sfcTemplateCompileResult, reactivity_1.computed(() => sfcStyles.textDocuments.value), context);
    const sfcRefSugarRanges = reactivity_1.computed(() => (sfcScriptSetup.ast.value ? {
        refs: refSugarRanges_1.parseRefSugarDeclarationRanges(context.modules.typescript, sfcScriptSetup.ast.value, ['$ref', '$computed', '$shallowRef', '$fromRefs']),
        raws: refSugarRanges_1.parseRefSugarCallRanges(context.modules.typescript, sfcScriptSetup.ast.value, ['$raw', '$fromRefs']),
    } : undefined));
    // getters
    const cssLsDocuments = reactivity_1.computed(() => [
        sfcTemplateScript.cssTextDocument.value,
        ...sfcStyles.textDocuments.value,
    ].filter(shared.notEmpty));
    const cssLsSourceMaps = reactivity_1.computed(() => [
        sfcTemplateScript.cssSourceMap.value,
        ...sfcStyles.sourceMaps.value,
    ].filter(shared.notEmpty));
    const templateLsSourceMaps = reactivity_1.computed(() => [
        sfcScriptForTemplateLs.sourceMap.value,
        sfcTemplateScript.sourceMap.value,
        sfcEntryForTemplateLs.sourceMap.value,
    ].filter(shared.notEmpty));
    const scriptLsSourceMaps = reactivity_1.computed(() => [
        sfcScriptForScriptLs.sourceMap.value,
    ].filter(shared.notEmpty));
    const templateLsDocuments = reactivity_1.computed(() => [
        sfcEntryForTemplateLs.textDocument.value,
        sfcScriptForTemplateLs.textDocument.value,
        sfcScriptForTemplateLs.textDocumentTs.value,
        sfcTemplateScript.textDocument.value,
    ].filter(shared.notEmpty));
    const scriptLsDocuments = reactivity_1.computed(() => [
        sfcScriptForScriptLs.textDocument.value,
    ].filter(shared.notEmpty));
    const tsSourceMaps = reactivity_1.computed(() => [
        sfcScriptForScriptLs.sourceMap.value,
        ...templateLsSourceMaps.value,
    ]);
    const templateLsTeleports = reactivity_1.computed(() => [
        sfcTemplateScript.teleportSourceMap.value,
        sfcScriptForTemplateLs.teleportSourceMap.value,
    ].filter(shared.notEmpty));
    update(_document);
    return {
        uri: _document.uri,
        getTemplateTagNames: untrack_1.untrack(() => { var _a; return (_a = sfcTemplateScript.templateCodeGens.value) === null || _a === void 0 ? void 0 : _a.tagNames; }),
        getTemplateAttrNames: untrack_1.untrack(() => { var _a; return (_a = sfcTemplateScript.templateCodeGens.value) === null || _a === void 0 ? void 0 : _a.attrNames; }),
        getTextDocument: untrack_1.untrack(() => document.value),
        getTemplateScriptDocument: untrack_1.untrack(() => sfcTemplateScript.textDocument.value),
        update: untrack_1.untrack(update),
        updateTemplateScript: untrack_1.untrack(updateTemplateScript),
        getScriptTsDocument: untrack_1.untrack(() => sfcScriptForScriptLs.textDocument.value),
        getScriptTsSourceMap: untrack_1.untrack(() => sfcScriptForScriptLs.sourceMap.value),
        getTsSourceMaps: untrack_1.untrack(() => tsSourceMaps.value),
        getCssSourceMaps: untrack_1.untrack(() => cssLsSourceMaps.value),
        getJsonSourceMaps: untrack_1.untrack(() => sfcJsons.sourceMaps.value),
        getHtmlSourceMaps: untrack_1.untrack(() => sfcTemplate.htmlSourceMap.value ? [sfcTemplate.htmlSourceMap.value] : []),
        getPugSourceMaps: untrack_1.untrack(() => sfcTemplate.pugSourceMap.value ? [sfcTemplate.pugSourceMap.value] : []),
        getTemplateScriptData: untrack_1.untrack(() => templateScriptData),
        getDescriptor: untrack_1.untrack(() => descriptor),
        getScriptAst: untrack_1.untrack(() => sfcScript.ast.value),
        getScriptSetupAst: untrack_1.untrack(() => sfcScriptSetup.ast.value),
        getVueHtmlDocument: untrack_1.untrack(() => vueHtmlDocument.value),
        getScriptSetupData: untrack_1.untrack(() => sfcScriptForTemplateLs.scriptSetupRanges.value),
        docLsScripts: untrack_1.untrack(() => ({
            documents: [sfcScript.textDocument.value, sfcScriptSetup.textDocument.value].filter(shared.notEmpty),
            sourceMaps: [sfcScript.sourceMap.value, sfcScriptSetup.sourceMap.value].filter(shared.notEmpty),
        })),
        getTemplateFormattingScript: untrack_1.untrack(() => ({
            document: sfcTemplateScript.textDocumentForFormatting.value,
            sourceMap: sfcTemplateScript.sourceMapForFormatting.value,
        })),
        getSfcRefSugarRanges: untrack_1.untrack(() => sfcRefSugarRanges.value),
        refs: {
            document,
            descriptor,
            lastUpdated,
            sfcErrors,
            sfcJsons,
            sfcTemplate,
            sfcTemplateData,
            sfcTemplateCompileResult,
            sfcTemplateScript,
            sfcScriptForScriptLs,
            sfcScriptForTemplateLs,
            templateScriptData,
            cssLsDocuments,
            cssLsSourceMaps,
            scriptLsDocuments,
            scriptLsSourceMaps,
            templateLsDocuments,
            templateLsSourceMaps,
            templateLsTeleports,
        },
    };
    function update(newDocument) {
        var _a, _b;
        const parsedSfc = vueSfc.parse(newDocument.getText(), { sourceMap: false, ignoreEmpty: false });
        const newDescriptor = parsedSfc.descriptor;
        const scriptLang_1 = sfcScriptForScriptLs.textDocument.value.languageId;
        const scriptText_1 = sfcScriptForScriptLs.textDocument.value.getText();
        const templateScriptVersion_1 = (_a = sfcTemplateScript.textDocument.value) === null || _a === void 0 ? void 0 : _a.version;
        updateSfcErrors();
        updateTemplate(newDescriptor);
        updateScript(newDescriptor);
        updateScriptSetup(newDescriptor);
        updateStyles(newDescriptor);
        updateCustomBlocks(newDescriptor);
        content.value = newDocument.getText();
        version.value = newDocument.version;
        sfcTemplateScript.update(); // TODO
        const scriptLang_2 = sfcScriptForScriptLs.textDocument.value.languageId;
        const scriptText_2 = sfcScriptForScriptLs.textDocument.value.getText();
        const templateScriptVersion_2 = (_b = sfcTemplateScript.textDocument.value) === null || _b === void 0 ? void 0 : _b.version;
        return {
            scriptContentUpdated: lastUpdated.script || lastUpdated.scriptSetup,
            scriptUpdated: scriptLang_1 !== scriptLang_2 || scriptText_1 !== scriptText_2,
            templateScriptUpdated: templateScriptVersion_1 !== templateScriptVersion_2,
        };
        function updateSfcErrors() {
            const errors = [];
            for (const error of parsedSfc.errors) {
                if ('code' in error && error.loc) {
                    const diag = vscode.Diagnostic.create(vscode.Range.create(error.loc.start.line - 1, error.loc.start.column - 1, error.loc.end.line - 1, error.loc.end.column - 1), error.message, vscode.DiagnosticSeverity.Error, error.code, 'vue');
                    errors.push(diag);
                }
            }
            sfcErrors.value = errors;
        }
        function updateTemplate(newDescriptor) {
            var _a, _b, _c;
            const newData = newDescriptor.template ? {
                lang: (_a = newDescriptor.template.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.template,
                content: newDescriptor.template.content,
                loc: {
                    start: newDescriptor.template.loc.start.offset,
                    end: newDescriptor.template.loc.end.offset,
                },
            } : null;
            lastUpdated.template = ((_b = descriptor.template) === null || _b === void 0 ? void 0 : _b.lang) !== (newData === null || newData === void 0 ? void 0 : newData.lang)
                || ((_c = descriptor.template) === null || _c === void 0 ? void 0 : _c.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.template && newData) {
                descriptor.template.lang = newData.lang;
                descriptor.template.content = newData.content;
                descriptor.template.loc.start = newData.loc.start;
                descriptor.template.loc.end = newData.loc.end;
            }
            else {
                descriptor.template = newData;
            }
        }
        function updateScript(newDescriptor) {
            var _a, _b, _c;
            const newData = newDescriptor.script ? {
                src: newDescriptor.script.src,
                lang: (_a = newDescriptor.script.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.script,
                content: newDescriptor.script.content,
                loc: {
                    start: newDescriptor.script.loc.start.offset,
                    end: newDescriptor.script.loc.end.offset,
                },
            } : null;
            lastUpdated.script = ((_b = descriptor.script) === null || _b === void 0 ? void 0 : _b.lang) !== (newData === null || newData === void 0 ? void 0 : newData.lang)
                || ((_c = descriptor.script) === null || _c === void 0 ? void 0 : _c.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.script && newData) {
                descriptor.script.src = newData.src;
                descriptor.script.lang = newData.lang;
                descriptor.script.content = newData.content;
                descriptor.script.loc.start = newData.loc.start;
                descriptor.script.loc.end = newData.loc.end;
            }
            else {
                descriptor.script = newData;
            }
        }
        function updateScriptSetup(newDescriptor) {
            var _a, _b, _c;
            const newData = newDescriptor.scriptSetup ? {
                lang: (_a = newDescriptor.scriptSetup.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.script,
                content: newDescriptor.scriptSetup.content,
                loc: {
                    start: newDescriptor.scriptSetup.loc.start.offset,
                    end: newDescriptor.scriptSetup.loc.end.offset,
                },
            } : null;
            lastUpdated.scriptSetup = ((_b = descriptor.scriptSetup) === null || _b === void 0 ? void 0 : _b.lang) !== (newData === null || newData === void 0 ? void 0 : newData.lang)
                || ((_c = descriptor.scriptSetup) === null || _c === void 0 ? void 0 : _c.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.scriptSetup && newData) {
                descriptor.scriptSetup.lang = newData.lang;
                descriptor.scriptSetup.content = newData.content;
                descriptor.scriptSetup.loc.start = newData.loc.start;
                descriptor.scriptSetup.loc.end = newData.loc.end;
            }
            else {
                descriptor.scriptSetup = newData;
            }
        }
        function updateStyles(newDescriptor) {
            var _a;
            for (let i = 0; i < newDescriptor.styles.length; i++) {
                const style = newDescriptor.styles[i];
                const newData = {
                    lang: (_a = style.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.style,
                    content: style.content,
                    loc: {
                        start: style.loc.start.offset,
                        end: style.loc.end.offset,
                    },
                    module: style.module === true ? '$style' : typeof style.module === 'string' ? style.module : undefined,
                    scoped: !!style.scoped,
                };
                if (descriptor.styles.length > i) {
                    descriptor.styles[i].lang = newData.lang;
                    descriptor.styles[i].content = newData.content;
                    descriptor.styles[i].loc.start = newData.loc.start;
                    descriptor.styles[i].loc.end = newData.loc.end;
                    descriptor.styles[i].module = newData.module;
                    descriptor.styles[i].scoped = newData.scoped;
                }
                else {
                    descriptor.styles.push(newData);
                }
            }
            while (descriptor.styles.length > newDescriptor.styles.length) {
                descriptor.styles.pop();
            }
        }
        function updateCustomBlocks(newDescriptor) {
            var _a;
            for (let i = 0; i < newDescriptor.customBlocks.length; i++) {
                const block = newDescriptor.customBlocks[i];
                const newData = {
                    type: block.type,
                    lang: (_a = block.lang) !== null && _a !== void 0 ? _a : '',
                    content: block.content,
                    loc: {
                        start: block.loc.start.offset,
                        end: block.loc.end.offset,
                    },
                };
                if (descriptor.customBlocks.length > i) {
                    descriptor.customBlocks[i].type = newData.type;
                    descriptor.customBlocks[i].lang = newData.lang;
                    descriptor.customBlocks[i].content = newData.content;
                    descriptor.customBlocks[i].loc.start = newData.loc.start;
                    descriptor.customBlocks[i].loc.end = newData.loc.end;
                }
                else {
                    descriptor.customBlocks.push(newData);
                }
            }
            while (descriptor.customBlocks.length > newDescriptor.customBlocks.length) {
                descriptor.customBlocks.pop();
            }
        }
    }
    function updateTemplateScript(templateTsLs) {
        var _a, _b;
        const newVersion = (_b = (_a = templateTsLs.__internal__.host).getProjectVersion) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (templateScriptData.projectVersion === newVersion) {
            return false;
        }
        templateScriptData.projectVersion = newVersion;
        const doc = sfcEntryForTemplateLs.textDocument.value;
        const docText = doc.getText();
        const context = docText.indexOf(string_1.SearchTexts.Context) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Context))) : [];
        let components = docText.indexOf(string_1.SearchTexts.Components) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Components))) : [];
        const props = docText.indexOf(string_1.SearchTexts.Props) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Props))) : [];
        const setupReturns = docText.indexOf(string_1.SearchTexts.SetupReturns) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.SetupReturns))) : [];
        components = components.filter(entry => {
            const name = entry.data.name;
            return name.indexOf('$') === -1 && !name.startsWith('_');
        });
        const contextNames = context.map(entry => entry.data.name);
        const componentNames = components.map(entry => entry.data.name);
        const propNames = props.map(entry => entry.data.name);
        const setupReturnNames = setupReturns.map(entry => entry.data.name);
        let dirty = false;
        if (!shared.eqSet(new Set(contextNames), new Set(templateScriptData.context))) {
            templateScriptData.context = contextNames;
            dirty = true;
        }
        if (!shared.eqSet(new Set(componentNames), new Set(templateScriptData.components))) {
            templateScriptData.components = componentNames;
            templateScriptData.componentItems = components;
            dirty = true;
        }
        if (!shared.eqSet(new Set(propNames), new Set(templateScriptData.props))) {
            templateScriptData.props = propNames;
            dirty = true;
        }
        if (!shared.eqSet(new Set(setupReturnNames), new Set(templateScriptData.setupReturns))) {
            templateScriptData.setupReturns = setupReturnNames;
            dirty = true;
        }
        if (dirty) {
            sfcTemplateScript.update(); // TODO
        }
        return dirty;
    }
}
exports.createSourceFile = createSourceFile;
//# sourceMappingURL=sourceFile.js.map