"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSourceFiles = void 0;
const reactivity_1 = require("@vue/reactivity");
const untrack_1 = require("./utils/untrack");
function createSourceFiles() {
    const sourceFiles = reactivity_1.shallowReactive({});
    const all = reactivity_1.computed(() => Object.values(sourceFiles));
    const uris = reactivity_1.computed(() => all.value.map(sourceFile => sourceFile.uri));
    const cssSourceMaps = reactivity_1.computed(() => {
        const map = new Map();
        for (const key in sourceFiles) {
            const sourceFile = sourceFiles[key];
            for (const sourceMap of sourceFile.refs.cssLsSourceMaps.value) {
                map.set(sourceMap.mappedDocument.uri, sourceMap);
            }
        }
        return map;
    });
    const htmlSourceMaps = reactivity_1.computed(() => {
        const map = new Map();
        for (const key in sourceFiles) {
            const sourceFile = sourceFiles[key];
            if (sourceFile.refs.sfcTemplate.htmlSourceMap.value) {
                const sourceMap = sourceFile.refs.sfcTemplate.htmlSourceMap.value;
                map.set(sourceMap.mappedDocument.uri, sourceMap);
            }
        }
        return map;
    });
    const tsRefs = {
        template: {
            documents: reactivity_1.computed(() => {
                const map = new Map();
                for (const key in sourceFiles) {
                    const sourceFile = sourceFiles[key];
                    for (const tsDoc of sourceFile.refs.templateLsDocuments.value) {
                        map.set(tsDoc.uri, tsDoc);
                    }
                }
                return map;
            }),
            teleports: reactivity_1.computed(() => {
                const map = new Map();
                for (const key in sourceFiles) {
                    const sourceFile = sourceFiles[key];
                    for (const sourceMap of sourceFile.refs.templateLsTeleports.value) {
                        map.set(sourceMap.mappedDocument.uri, sourceMap);
                    }
                }
                return map;
            }),
            sourceMaps: reactivity_1.computed(() => {
                const map = new Map();
                for (const key in sourceFiles) {
                    const sourceFile = sourceFiles[key];
                    for (const sourceMap of sourceFile.refs.templateLsSourceMaps.value) {
                        map.set(sourceMap.mappedDocument.uri, sourceMap);
                    }
                }
                return map;
            }),
            urisMapSourceFiles: reactivity_1.computed(() => {
                const map = new Map();
                for (const key in sourceFiles) {
                    const sourceFile = sourceFiles[key];
                    for (const tsDoc of sourceFile.refs.templateLsDocuments.value) {
                        map.set(tsDoc.uri, sourceFile);
                    }
                }
                return map;
            }),
        },
        script: {
            documents: reactivity_1.computed(() => {
                const map = new Map();
                for (const key in sourceFiles) {
                    const sourceFile = sourceFiles[key];
                    for (const tsDoc of sourceFile.refs.scriptLsDocuments.value) {
                        map.set(tsDoc.uri, tsDoc);
                    }
                }
                return map;
            }),
            teleports: reactivity_1.computed(() => {
                const map = new Map();
                for (const key in sourceFiles) {
                    const sourceFile = sourceFiles[key];
                    const sourceMap = sourceFile.refs.sfcScriptForScriptLs.teleportSourceMap.value;
                    map.set(sourceMap.mappedDocument.uri, sourceMap);
                }
                return map;
            }),
            sourceMaps: reactivity_1.computed(() => {
                const map = new Map();
                for (const key in sourceFiles) {
                    const sourceFile = sourceFiles[key];
                    for (const sourceMap of sourceFile.refs.scriptLsSourceMaps.value) {
                        map.set(sourceMap.mappedDocument.uri, sourceMap);
                    }
                }
                return map;
            }),
            urisMapSourceFiles: reactivity_1.computed(() => {
                const map = new Map();
                for (const key in sourceFiles) {
                    const sourceFile = sourceFiles[key];
                    for (const tsDoc of sourceFile.refs.scriptLsDocuments.value) {
                        map.set(tsDoc.uri, sourceFile);
                    }
                }
                return map;
            }),
        },
    };
    return {
        getUris: untrack_1.untrack(() => uris.value),
        getAll: untrack_1.untrack(() => all.value),
        get: untrack_1.untrack((uri) => sourceFiles[uri.toLowerCase()]),
        set: untrack_1.untrack((uri, sourceFile) => sourceFiles[uri.toLowerCase()] = sourceFile),
        delete: untrack_1.untrack((uri) => {
            if (sourceFiles[uri.toLowerCase()]) {
                delete sourceFiles[uri.toLowerCase()];
                return true;
            }
            return false;
        }),
        getTsTeleports: untrack_1.untrack((lsType) => tsRefs[lsType].teleports.value),
        getTsDocuments: untrack_1.untrack((lsType) => tsRefs[lsType].documents.value),
        getTsSourceMaps: untrack_1.untrack((lsType) => tsRefs[lsType].sourceMaps.value),
        getSourceFileByTsUri: untrack_1.untrack((lsType, uri) => tsRefs[lsType].urisMapSourceFiles.value.get(uri)),
        getCssSourceMaps: untrack_1.untrack(() => cssSourceMaps.value),
        getHtmlSourceMaps: untrack_1.untrack(() => htmlSourceMaps.value),
        toTsLocations: untrack_1.untrack(function* (uri, start, end) {
            if (end === undefined)
                end = start;
            for (const lsType of ['script', 'template']) {
                const sourceFile = sourceFiles[uri.toLowerCase()];
                if (sourceFile) {
                    for (const sourceMap of lsType === 'script' ? sourceFile.refs.scriptLsSourceMaps.value : sourceFile.refs.templateLsSourceMaps.value) {
                        for (const tsRange of sourceMap.getMappedRanges(start, end)) {
                            yield {
                                lsType,
                                type: 'embedded-ts',
                                sourceMap,
                                uri: sourceMap.mappedDocument.uri,
                                range: tsRange,
                            };
                        }
                    }
                }
                else {
                    yield {
                        lsType,
                        type: 'source-ts',
                        uri,
                        range: {
                            start,
                            end,
                        },
                    };
                }
            }
        }),
        fromTsLocation: untrack_1.untrack(function* (lsType, uri, start, end) {
            if (end === undefined)
                end = start;
            const sourceMap = tsRefs[lsType].sourceMaps.value.get(uri);
            if (sourceMap) {
                for (const vueRange of sourceMap.getSourceRanges(start, end)) {
                    yield {
                        type: 'embedded-ts',
                        sourceMap,
                        uri: sourceMap.sourceDocument.uri,
                        range: vueRange,
                    };
                }
            }
            else {
                yield {
                    type: 'source-ts',
                    uri,
                    range: {
                        start,
                        end,
                    },
                };
            }
        }),
        fromTsLocation2: untrack_1.untrack(function* (lsType, uri, start, end) {
            if (end === undefined)
                end = start;
            const sourceMap = tsRefs[lsType].sourceMaps.value.get(uri);
            if (sourceMap) {
                for (const vueRange of sourceMap.getSourceRanges2(start, end)) {
                    yield {
                        lsType,
                        type: 'embedded-ts',
                        sourceMap,
                        uri: sourceMap.sourceDocument.uri,
                        range: vueRange,
                    };
                }
            }
            else {
                yield {
                    lsType,
                    type: 'source-ts',
                    uri,
                    range: {
                        start,
                        end,
                    },
                };
            }
        }),
    };
}
exports.createSourceFiles = createSourceFiles;
//# sourceMappingURL=sourceFiles.js.map