var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/vscode-uri/lib/esm/index.js
var require_esm = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    URI: () => URI,
    Utils: () => Utils
  });
  var LIB;
  LIB = (() => {
    "use strict";
    var t = {470: (t2) => {
      function e2(t3) {
        if (typeof t3 != "string")
          throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
      }
      function r2(t3, e3) {
        for (var r3, n2 = "", o = 0, i = -1, a = 0, h = 0; h <= t3.length; ++h) {
          if (h < t3.length)
            r3 = t3.charCodeAt(h);
          else {
            if (r3 === 47)
              break;
            r3 = 47;
          }
          if (r3 === 47) {
            if (i === h - 1 || a === 1)
              ;
            else if (i !== h - 1 && a === 2) {
              if (n2.length < 2 || o !== 2 || n2.charCodeAt(n2.length - 1) !== 46 || n2.charCodeAt(n2.length - 2) !== 46) {
                if (n2.length > 2) {
                  var s = n2.lastIndexOf("/");
                  if (s !== n2.length - 1) {
                    s === -1 ? (n2 = "", o = 0) : o = (n2 = n2.slice(0, s)).length - 1 - n2.lastIndexOf("/"), i = h, a = 0;
                    continue;
                  }
                } else if (n2.length === 2 || n2.length === 1) {
                  n2 = "", o = 0, i = h, a = 0;
                  continue;
                }
              }
              e3 && (n2.length > 0 ? n2 += "/.." : n2 = "..", o = 2);
            } else
              n2.length > 0 ? n2 += "/" + t3.slice(i + 1, h) : n2 = t3.slice(i + 1, h), o = h - i - 1;
            i = h, a = 0;
          } else
            r3 === 46 && a !== -1 ? ++a : a = -1;
        }
        return n2;
      }
      var n = {resolve: function() {
        for (var t3, n2 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
          var a;
          i >= 0 ? a = arguments[i] : (t3 === void 0 && (t3 = process.cwd()), a = t3), e2(a), a.length !== 0 && (n2 = a + "/" + n2, o = a.charCodeAt(0) === 47);
        }
        return n2 = r2(n2, !o), o ? n2.length > 0 ? "/" + n2 : "/" : n2.length > 0 ? n2 : ".";
      }, normalize: function(t3) {
        if (e2(t3), t3.length === 0)
          return ".";
        var n2 = t3.charCodeAt(0) === 47, o = t3.charCodeAt(t3.length - 1) === 47;
        return (t3 = r2(t3, !n2)).length !== 0 || n2 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n2 ? "/" + t3 : t3;
      }, isAbsolute: function(t3) {
        return e2(t3), t3.length > 0 && t3.charCodeAt(0) === 47;
      }, join: function() {
        if (arguments.length === 0)
          return ".";
        for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
          var o = arguments[r3];
          e2(o), o.length > 0 && (t3 === void 0 ? t3 = o : t3 += "/" + o);
        }
        return t3 === void 0 ? "." : n.normalize(t3);
      }, relative: function(t3, r3) {
        if (e2(t3), e2(r3), t3 === r3)
          return "";
        if ((t3 = n.resolve(t3)) === (r3 = n.resolve(r3)))
          return "";
        for (var o = 1; o < t3.length && t3.charCodeAt(o) === 47; ++o)
          ;
        for (var i = t3.length, a = i - o, h = 1; h < r3.length && r3.charCodeAt(h) === 47; ++h)
          ;
        for (var s = r3.length - h, f = a < s ? a : s, u = -1, c = 0; c <= f; ++c) {
          if (c === f) {
            if (s > f) {
              if (r3.charCodeAt(h + c) === 47)
                return r3.slice(h + c + 1);
              if (c === 0)
                return r3.slice(h + c);
            } else
              a > f && (t3.charCodeAt(o + c) === 47 ? u = c : c === 0 && (u = 0));
            break;
          }
          var l = t3.charCodeAt(o + c);
          if (l !== r3.charCodeAt(h + c))
            break;
          l === 47 && (u = c);
        }
        var p = "";
        for (c = o + u + 1; c <= i; ++c)
          c !== i && t3.charCodeAt(c) !== 47 || (p.length === 0 ? p += ".." : p += "/..");
        return p.length > 0 ? p + r3.slice(h + u) : (h += u, r3.charCodeAt(h) === 47 && ++h, r3.slice(h));
      }, _makeLong: function(t3) {
        return t3;
      }, dirname: function(t3) {
        if (e2(t3), t3.length === 0)
          return ".";
        for (var r3 = t3.charCodeAt(0), n2 = r3 === 47, o = -1, i = true, a = t3.length - 1; a >= 1; --a)
          if ((r3 = t3.charCodeAt(a)) === 47) {
            if (!i) {
              o = a;
              break;
            }
          } else
            i = false;
        return o === -1 ? n2 ? "/" : "." : n2 && o === 1 ? "//" : t3.slice(0, o);
      }, basename: function(t3, r3) {
        if (r3 !== void 0 && typeof r3 != "string")
          throw new TypeError('"ext" argument must be a string');
        e2(t3);
        var n2, o = 0, i = -1, a = true;
        if (r3 !== void 0 && r3.length > 0 && r3.length <= t3.length) {
          if (r3.length === t3.length && r3 === t3)
            return "";
          var h = r3.length - 1, s = -1;
          for (n2 = t3.length - 1; n2 >= 0; --n2) {
            var f = t3.charCodeAt(n2);
            if (f === 47) {
              if (!a) {
                o = n2 + 1;
                break;
              }
            } else
              s === -1 && (a = false, s = n2 + 1), h >= 0 && (f === r3.charCodeAt(h) ? --h == -1 && (i = n2) : (h = -1, i = s));
          }
          return o === i ? i = s : i === -1 && (i = t3.length), t3.slice(o, i);
        }
        for (n2 = t3.length - 1; n2 >= 0; --n2)
          if (t3.charCodeAt(n2) === 47) {
            if (!a) {
              o = n2 + 1;
              break;
            }
          } else
            i === -1 && (a = false, i = n2 + 1);
        return i === -1 ? "" : t3.slice(o, i);
      }, extname: function(t3) {
        e2(t3);
        for (var r3 = -1, n2 = 0, o = -1, i = true, a = 0, h = t3.length - 1; h >= 0; --h) {
          var s = t3.charCodeAt(h);
          if (s !== 47)
            o === -1 && (i = false, o = h + 1), s === 46 ? r3 === -1 ? r3 = h : a !== 1 && (a = 1) : r3 !== -1 && (a = -1);
          else if (!i) {
            n2 = h + 1;
            break;
          }
        }
        return r3 === -1 || o === -1 || a === 0 || a === 1 && r3 === o - 1 && r3 === n2 + 1 ? "" : t3.slice(r3, o);
      }, format: function(t3) {
        if (t3 === null || typeof t3 != "object")
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
        return function(t4, e3) {
          var r3 = e3.dir || e3.root, n2 = e3.base || (e3.name || "") + (e3.ext || "");
          return r3 ? r3 === e3.root ? r3 + n2 : r3 + "/" + n2 : n2;
        }(0, t3);
      }, parse: function(t3) {
        e2(t3);
        var r3 = {root: "", dir: "", base: "", ext: "", name: ""};
        if (t3.length === 0)
          return r3;
        var n2, o = t3.charCodeAt(0), i = o === 47;
        i ? (r3.root = "/", n2 = 1) : n2 = 0;
        for (var a = -1, h = 0, s = -1, f = true, u = t3.length - 1, c = 0; u >= n2; --u)
          if ((o = t3.charCodeAt(u)) !== 47)
            s === -1 && (f = false, s = u + 1), o === 46 ? a === -1 ? a = u : c !== 1 && (c = 1) : a !== -1 && (c = -1);
          else if (!f) {
            h = u + 1;
            break;
          }
        return a === -1 || s === -1 || c === 0 || c === 1 && a === s - 1 && a === h + 1 ? s !== -1 && (r3.base = r3.name = h === 0 && i ? t3.slice(1, s) : t3.slice(h, s)) : (h === 0 && i ? (r3.name = t3.slice(1, a), r3.base = t3.slice(1, s)) : (r3.name = t3.slice(h, a), r3.base = t3.slice(h, s)), r3.ext = t3.slice(a, s)), h > 0 ? r3.dir = t3.slice(0, h - 1) : i && (r3.dir = "/"), r3;
      }, sep: "/", delimiter: ":", win32: null, posix: null};
      n.posix = n, t2.exports = n;
    }, 447: (t2, e2, r2) => {
      var n;
      if (r2.r(e2), r2.d(e2, {URI: () => g, Utils: () => O}), typeof process == "object")
        n = process.platform === "win32";
      else if (typeof navigator == "object") {
        var o = navigator.userAgent;
        n = o.indexOf("Windows") >= 0;
      }
      var i, a, h = (i = function(t3, e3) {
        return (i = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(t4, e4) {
          t4.__proto__ = e4;
        } || function(t4, e4) {
          for (var r3 in e4)
            Object.prototype.hasOwnProperty.call(e4, r3) && (t4[r3] = e4[r3]);
        })(t3, e3);
      }, function(t3, e3) {
        function r3() {
          this.constructor = t3;
        }
        i(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (r3.prototype = e3.prototype, new r3());
      }), s = /^\w[\w\d+.-]*$/, f = /^\//, u = /^\/\//, c = "", l = "/", p = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, g = function() {
        function t3(t4, e3, r3, n2, o2, i2) {
          i2 === void 0 && (i2 = false), typeof t4 == "object" ? (this.scheme = t4.scheme || c, this.authority = t4.authority || c, this.path = t4.path || c, this.query = t4.query || c, this.fragment = t4.fragment || c) : (this.scheme = function(t5, e4) {
            return t5 || e4 ? t5 : "file";
          }(t4, i2), this.authority = e3 || c, this.path = function(t5, e4) {
            switch (t5) {
              case "https":
              case "http":
              case "file":
                e4 ? e4[0] !== l && (e4 = l + e4) : e4 = l;
            }
            return e4;
          }(this.scheme, r3 || c), this.query = n2 || c, this.fragment = o2 || c, function(t5, e4) {
            if (!t5.scheme && e4)
              throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "' + t5.authority + '", path: "' + t5.path + '", query: "' + t5.query + '", fragment: "' + t5.fragment + '"}');
            if (t5.scheme && !s.test(t5.scheme))
              throw new Error("[UriError]: Scheme contains illegal characters.");
            if (t5.path) {
              if (t5.authority) {
                if (!f.test(t5.path))
                  throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
              } else if (u.test(t5.path))
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
          }(this, i2));
        }
        return t3.isUri = function(e3) {
          return e3 instanceof t3 || !!e3 && typeof e3.authority == "string" && typeof e3.fragment == "string" && typeof e3.path == "string" && typeof e3.query == "string" && typeof e3.scheme == "string" && typeof e3.fsPath == "function" && typeof e3.with == "function" && typeof e3.toString == "function";
        }, Object.defineProperty(t3.prototype, "fsPath", {get: function() {
          return C(this, false);
        }, enumerable: false, configurable: true}), t3.prototype.with = function(t4) {
          if (!t4)
            return this;
          var e3 = t4.scheme, r3 = t4.authority, n2 = t4.path, o2 = t4.query, i2 = t4.fragment;
          return e3 === void 0 ? e3 = this.scheme : e3 === null && (e3 = c), r3 === void 0 ? r3 = this.authority : r3 === null && (r3 = c), n2 === void 0 ? n2 = this.path : n2 === null && (n2 = c), o2 === void 0 ? o2 = this.query : o2 === null && (o2 = c), i2 === void 0 ? i2 = this.fragment : i2 === null && (i2 = c), e3 === this.scheme && r3 === this.authority && n2 === this.path && o2 === this.query && i2 === this.fragment ? this : new v(e3, r3, n2, o2, i2);
        }, t3.parse = function(t4, e3) {
          e3 === void 0 && (e3 = false);
          var r3 = p.exec(t4);
          return r3 ? new v(r3[2] || c, x(r3[4] || c), x(r3[5] || c), x(r3[7] || c), x(r3[9] || c), e3) : new v(c, c, c, c, c);
        }, t3.file = function(t4) {
          var e3 = c;
          if (n && (t4 = t4.replace(/\\/g, l)), t4[0] === l && t4[1] === l) {
            var r3 = t4.indexOf(l, 2);
            r3 === -1 ? (e3 = t4.substring(2), t4 = l) : (e3 = t4.substring(2, r3), t4 = t4.substring(r3) || l);
          }
          return new v("file", e3, t4, c, c);
        }, t3.from = function(t4) {
          return new v(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);
        }, t3.prototype.toString = function(t4) {
          return t4 === void 0 && (t4 = false), A(this, t4);
        }, t3.prototype.toJSON = function() {
          return this;
        }, t3.revive = function(e3) {
          if (e3) {
            if (e3 instanceof t3)
              return e3;
            var r3 = new v(e3);
            return r3._formatted = e3.external, r3._fsPath = e3._sep === d ? e3.fsPath : null, r3;
          }
          return e3;
        }, t3;
      }(), d = n ? 1 : void 0, v = function(t3) {
        function e3() {
          var e4 = t3 !== null && t3.apply(this, arguments) || this;
          return e4._formatted = null, e4._fsPath = null, e4;
        }
        return h(e3, t3), Object.defineProperty(e3.prototype, "fsPath", {get: function() {
          return this._fsPath || (this._fsPath = C(this, false)), this._fsPath;
        }, enumerable: false, configurable: true}), e3.prototype.toString = function(t4) {
          return t4 === void 0 && (t4 = false), t4 ? A(this, true) : (this._formatted || (this._formatted = A(this, false)), this._formatted);
        }, e3.prototype.toJSON = function() {
          var t4 = {$mid: 1};
          return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = d), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
        }, e3;
      }(g), m = ((a = {})[58] = "%3A", a[47] = "%2F", a[63] = "%3F", a[35] = "%23", a[91] = "%5B", a[93] = "%5D", a[64] = "%40", a[33] = "%21", a[36] = "%24", a[38] = "%26", a[39] = "%27", a[40] = "%28", a[41] = "%29", a[42] = "%2A", a[43] = "%2B", a[44] = "%2C", a[59] = "%3B", a[61] = "%3D", a[32] = "%20", a);
      function y(t3, e3) {
        for (var r3 = void 0, n2 = -1, o2 = 0; o2 < t3.length; o2++) {
          var i2 = t3.charCodeAt(o2);
          if (i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 >= 48 && i2 <= 57 || i2 === 45 || i2 === 46 || i2 === 95 || i2 === 126 || e3 && i2 === 47)
            n2 !== -1 && (r3 += encodeURIComponent(t3.substring(n2, o2)), n2 = -1), r3 !== void 0 && (r3 += t3.charAt(o2));
          else {
            r3 === void 0 && (r3 = t3.substr(0, o2));
            var a2 = m[i2];
            a2 !== void 0 ? (n2 !== -1 && (r3 += encodeURIComponent(t3.substring(n2, o2)), n2 = -1), r3 += a2) : n2 === -1 && (n2 = o2);
          }
        }
        return n2 !== -1 && (r3 += encodeURIComponent(t3.substring(n2))), r3 !== void 0 ? r3 : t3;
      }
      function b(t3) {
        for (var e3 = void 0, r3 = 0; r3 < t3.length; r3++) {
          var n2 = t3.charCodeAt(r3);
          n2 === 35 || n2 === 63 ? (e3 === void 0 && (e3 = t3.substr(0, r3)), e3 += m[n2]) : e3 !== void 0 && (e3 += t3[r3]);
        }
        return e3 !== void 0 ? e3 : t3;
      }
      function C(t3, e3) {
        var r3;
        return r3 = t3.authority && t3.path.length > 1 && t3.scheme === "file" ? "//" + t3.authority + t3.path : t3.path.charCodeAt(0) === 47 && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && t3.path.charCodeAt(2) === 58 ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n && (r3 = r3.replace(/\//g, "\\")), r3;
      }
      function A(t3, e3) {
        var r3 = e3 ? b : y, n2 = "", o2 = t3.scheme, i2 = t3.authority, a2 = t3.path, h2 = t3.query, s2 = t3.fragment;
        if (o2 && (n2 += o2, n2 += ":"), (i2 || o2 === "file") && (n2 += l, n2 += l), i2) {
          var f2 = i2.indexOf("@");
          if (f2 !== -1) {
            var u2 = i2.substr(0, f2);
            i2 = i2.substr(f2 + 1), (f2 = u2.indexOf(":")) === -1 ? n2 += r3(u2, false) : (n2 += r3(u2.substr(0, f2), false), n2 += ":", n2 += r3(u2.substr(f2 + 1), false)), n2 += "@";
          }
          (f2 = (i2 = i2.toLowerCase()).indexOf(":")) === -1 ? n2 += r3(i2, false) : (n2 += r3(i2.substr(0, f2), false), n2 += i2.substr(f2));
        }
        if (a2) {
          if (a2.length >= 3 && a2.charCodeAt(0) === 47 && a2.charCodeAt(2) === 58)
            (c2 = a2.charCodeAt(1)) >= 65 && c2 <= 90 && (a2 = "/" + String.fromCharCode(c2 + 32) + ":" + a2.substr(3));
          else if (a2.length >= 2 && a2.charCodeAt(1) === 58) {
            var c2;
            (c2 = a2.charCodeAt(0)) >= 65 && c2 <= 90 && (a2 = String.fromCharCode(c2 + 32) + ":" + a2.substr(2));
          }
          n2 += r3(a2, true);
        }
        return h2 && (n2 += "?", n2 += r3(h2, false)), s2 && (n2 += "#", n2 += e3 ? s2 : y(s2, false)), n2;
      }
      function w(t3) {
        try {
          return decodeURIComponent(t3);
        } catch (e3) {
          return t3.length > 3 ? t3.substr(0, 3) + w(t3.substr(3)) : t3;
        }
      }
      var _ = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
      function x(t3) {
        return t3.match(_) ? t3.replace(_, function(t4) {
          return w(t4);
        }) : t3;
      }
      var O, P = r2(470), j = function() {
        for (var t3 = 0, e3 = 0, r3 = arguments.length; e3 < r3; e3++)
          t3 += arguments[e3].length;
        var n2 = Array(t3), o2 = 0;
        for (e3 = 0; e3 < r3; e3++)
          for (var i2 = arguments[e3], a2 = 0, h2 = i2.length; a2 < h2; a2++, o2++)
            n2[o2] = i2[a2];
        return n2;
      }, U = P.posix || P;
      !function(t3) {
        t3.joinPath = function(t4) {
          for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
            e3[r3 - 1] = arguments[r3];
          return t4.with({path: U.join.apply(U, j([t4.path], e3))});
        }, t3.resolvePath = function(t4) {
          for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
            e3[r3 - 1] = arguments[r3];
          var n2 = t4.path || "/";
          return t4.with({path: U.resolve.apply(U, j([n2], e3))});
        }, t3.dirname = function(t4) {
          var e3 = U.dirname(t4.path);
          return e3.length === 1 && e3.charCodeAt(0) === 46 ? t4 : t4.with({path: e3});
        }, t3.basename = function(t4) {
          return U.basename(t4.path);
        }, t3.extname = function(t4) {
          return U.extname(t4.path);
        };
      }(O || (O = {}));
    }}, e = {};
    function r(n) {
      if (e[n])
        return e[n].exports;
      var o = e[n] = {exports: {}};
      return t[n](o, o.exports, r), o.exports;
    }
    return r.d = (t2, e2) => {
      for (var n in e2)
        r.o(e2, n) && !r.o(t2, n) && Object.defineProperty(t2, n, {enumerable: true, get: e2[n]});
    }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(t2, "__esModule", {value: true});
    }, r(447);
  })();
  var {URI, Utils} = LIB;
});

// node_modules/upath/build/code/upath.js
var require_upath = __commonJS((exports2) => {
  var VERSION = "2.0.1";
  var extraFn;
  var extraFunctions;
  var isFunction2;
  var isString;
  var isValidExt;
  var name;
  var path4;
  var propName;
  var propValue;
  var toUnix;
  var upath;
  var slice = [].slice;
  var indexOf = [].indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  };
  var hasProp = {}.hasOwnProperty;
  path4 = require("path");
  isFunction2 = function(val) {
    return typeof val === "function";
  };
  isString = function(val) {
    return typeof val === "string" || !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object String]";
  };
  upath = exports2;
  upath.VERSION = typeof VERSION !== "undefined" && VERSION !== null ? VERSION : "NO-VERSION";
  toUnix = function(p) {
    p = p.replace(/\\/g, "/");
    p = p.replace(/(?<!^)\/+/g, "/");
    return p;
  };
  for (propName in path4) {
    propValue = path4[propName];
    if (isFunction2(propValue)) {
      upath[propName] = function(propName2) {
        return function() {
          var args, result;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          args = args.map(function(p) {
            if (isString(p)) {
              return toUnix(p);
            } else {
              return p;
            }
          });
          result = path4[propName2].apply(path4, args);
          if (isString(result)) {
            return toUnix(result);
          } else {
            return result;
          }
        };
      }(propName);
    } else {
      upath[propName] = propValue;
    }
  }
  upath.sep = "/";
  extraFunctions = {
    toUnix,
    normalizeSafe: function(p) {
      var result;
      p = toUnix(p);
      result = upath.normalize(p);
      if (p.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
        result = "./" + result;
      } else if (p.startsWith("//") && !result.startsWith("//")) {
        if (p.startsWith("//./")) {
          result = "//." + result;
        } else {
          result = "/" + result;
        }
      }
      return result;
    },
    normalizeTrim: function(p) {
      p = upath.normalizeSafe(p);
      if (p.endsWith("/")) {
        return p.slice(0, +(p.length - 2) + 1 || 9e9);
      } else {
        return p;
      }
    },
    joinSafe: function() {
      var p, p0, result;
      p = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      result = upath.join.apply(null, p);
      if (p.length > 0) {
        p0 = toUnix(p[0]);
        if (p0.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
          result = "./" + result;
        } else if (p0.startsWith("//") && !result.startsWith("//")) {
          if (p0.startsWith("//./")) {
            result = "//." + result;
          } else {
            result = "/" + result;
          }
        }
      }
      return result;
    },
    addExt: function(file, ext) {
      if (!ext) {
        return file;
      } else {
        if (ext[0] !== ".") {
          ext = "." + ext;
        }
        return file + (file.endsWith(ext) ? "" : ext);
      }
    },
    trimExt: function(filename, ignoreExts, maxSize) {
      var oldExt;
      if (maxSize == null) {
        maxSize = 7;
      }
      oldExt = upath.extname(filename);
      if (isValidExt(oldExt, ignoreExts, maxSize)) {
        return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9e9);
      } else {
        return filename;
      }
    },
    removeExt: function(filename, ext) {
      if (!ext) {
        return filename;
      } else {
        ext = ext[0] === "." ? ext : "." + ext;
        if (upath.extname(filename) === ext) {
          return upath.trimExt(filename, [], ext.length);
        } else {
          return filename;
        }
      }
    },
    changeExt: function(filename, ext, ignoreExts, maxSize) {
      if (maxSize == null) {
        maxSize = 7;
      }
      return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? "" : ext[0] === "." ? ext : "." + ext);
    },
    defaultExt: function(filename, ext, ignoreExts, maxSize) {
      var oldExt;
      if (maxSize == null) {
        maxSize = 7;
      }
      oldExt = upath.extname(filename);
      if (isValidExt(oldExt, ignoreExts, maxSize)) {
        return filename;
      } else {
        return upath.addExt(filename, ext);
      }
    }
  };
  isValidExt = function(ext, ignoreExts, maxSize) {
    if (ignoreExts == null) {
      ignoreExts = [];
    }
    return ext && ext.length <= maxSize && indexOf.call(ignoreExts.map(function(e) {
      return (e && e[0] !== "." ? "." : "") + e;
    }), ext) < 0;
  };
  for (name in extraFunctions) {
    if (!hasProp.call(extraFunctions, name))
      continue;
    extraFn = extraFunctions[name];
    if (upath[name] !== void 0) {
      throw new Error("path." + name + " already exists.");
    } else {
      upath[name] = extraFn;
    }
  }
});

// node_modules/@volar/shared/out/path.js
var require_path = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.normalizeFileName = exports2.fsPathToUri = exports2.uriToFsPath = void 0;
  var vscode_uri_1 = require_esm();
  var upath = require_upath();
  function uriToFsPath(uri) {
    return upath.toUnix(vscode_uri_1.URI.parse(uri).fsPath);
  }
  exports2.uriToFsPath = uriToFsPath;
  function fsPathToUri(fsPath) {
    return vscode_uri_1.URI.file(fsPath).toString();
  }
  exports2.fsPathToUri = fsPathToUri;
  function normalizeFileName(fileName) {
    return uriToFsPath(fsPathToUri(fileName));
  }
  exports2.normalizeFileName = normalizeFileName;
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var _ral;
  function RAL() {
    if (_ral === void 0) {
      throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
  }
  (function(RAL2) {
    function install(ral) {
      if (ral === void 0) {
        throw new Error(`No runtime abstraction layer provided`);
      }
      _ral = ral;
    }
    RAL2.install = install;
  })(RAL || (RAL = {}));
  exports2.default = RAL;
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Disposable = void 0;
  var Disposable3;
  (function(Disposable4) {
    function create(func) {
      return {
        dispose: func
      };
    }
    Disposable4.create = create;
  })(Disposable3 = exports2.Disposable || (exports2.Disposable = {}));
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.AbstractMessageBuffer = void 0;
  var CR = 13;
  var LF = 10;
  var CRLF = "\r\n";
  var AbstractMessageBuffer = class {
    constructor(encoding = "utf-8") {
      this._encoding = encoding;
      this._chunks = [];
      this._totalLength = 0;
    }
    get encoding() {
      return this._encoding;
    }
    append(chunk) {
      const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
      this._chunks.push(toAppend);
      this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
      if (this._chunks.length === 0) {
        return void 0;
      }
      let state = 0;
      let chunkIndex = 0;
      let offset = 0;
      let chunkBytesRead = 0;
      row:
        while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column:
            while (offset < chunk.length) {
              const value = chunk[offset];
              switch (value) {
                case CR:
                  switch (state) {
                    case 0:
                      state = 1;
                      break;
                    case 2:
                      state = 3;
                      break;
                    default:
                      state = 0;
                  }
                  break;
                case LF:
                  switch (state) {
                    case 1:
                      state = 2;
                      break;
                    case 3:
                      state = 4;
                      offset++;
                      break row;
                    default:
                      state = 0;
                  }
                  break;
                default:
                  state = 0;
              }
              offset++;
            }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
      if (state !== 4) {
        return void 0;
      }
      const buffer = this._read(chunkBytesRead + offset);
      const result = new Map();
      const headers = this.toString(buffer, "ascii").split(CRLF);
      if (headers.length < 2) {
        return result;
      }
      for (let i = 0; i < headers.length - 2; i++) {
        const header = headers[i];
        const index = header.indexOf(":");
        if (index === -1) {
          throw new Error("Message header must separate key and value using :");
        }
        const key = header.substr(0, index);
        const value = header.substr(index + 1).trim();
        result.set(key, value);
      }
      return result;
    }
    tryReadBody(length) {
      if (this._totalLength < length) {
        return void 0;
      }
      return this._read(length);
    }
    get numberOfBytes() {
      return this._totalLength;
    }
    _read(byteCount) {
      if (byteCount === 0) {
        return this.emptyBuffer();
      }
      if (byteCount > this._totalLength) {
        throw new Error(`Cannot read so many bytes!`);
      }
      if (this._chunks[0].byteLength === byteCount) {
        const chunk = this._chunks[0];
        this._chunks.shift();
        this._totalLength -= byteCount;
        return this.asNative(chunk);
      }
      if (this._chunks[0].byteLength > byteCount) {
        const chunk = this._chunks[0];
        const result2 = this.asNative(chunk, byteCount);
        this._chunks[0] = chunk.slice(byteCount);
        this._totalLength -= byteCount;
        return result2;
      }
      const result = this.allocNative(byteCount);
      let resultOffset = 0;
      let chunkIndex = 0;
      while (byteCount > 0) {
        const chunk = this._chunks[chunkIndex];
        if (chunk.byteLength > byteCount) {
          const chunkPart = chunk.slice(0, byteCount);
          result.set(chunkPart, resultOffset);
          resultOffset += byteCount;
          this._chunks[chunkIndex] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          byteCount -= byteCount;
        } else {
          result.set(chunk, resultOffset);
          resultOffset += chunk.byteLength;
          this._chunks.shift();
          this._totalLength -= chunk.byteLength;
          byteCount -= chunk.byteLength;
        }
      }
      return result;
    }
  };
  exports2.AbstractMessageBuffer = AbstractMessageBuffer;
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var ral_1 = require_ral();
  var util_1 = require("util");
  var disposable_1 = require_disposable();
  var messageBuffer_1 = require_messageBuffer();
  var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = "utf-8") {
      super(encoding);
    }
    emptyBuffer() {
      return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
      return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
      if (value instanceof Buffer) {
        return value.toString(encoding);
      } else {
        return new util_1.TextDecoder(encoding).decode(value);
      }
    }
    asNative(buffer, length) {
      if (length === void 0) {
        return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
      } else {
        return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
      }
    }
    allocNative(length) {
      return Buffer.allocUnsafe(length);
    }
  };
  MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
  var ReadableStreamWrapper = class {
    constructor(stream) {
      this.stream = stream;
    }
    onClose(listener) {
      this.stream.on("close", listener);
      return disposable_1.Disposable.create(() => this.stream.off("close", listener));
    }
    onError(listener) {
      this.stream.on("error", listener);
      return disposable_1.Disposable.create(() => this.stream.off("error", listener));
    }
    onEnd(listener) {
      this.stream.on("end", listener);
      return disposable_1.Disposable.create(() => this.stream.off("end", listener));
    }
    onData(listener) {
      this.stream.on("data", listener);
      return disposable_1.Disposable.create(() => this.stream.off("data", listener));
    }
  };
  var WritableStreamWrapper = class {
    constructor(stream) {
      this.stream = stream;
    }
    onClose(listener) {
      this.stream.on("close", listener);
      return disposable_1.Disposable.create(() => this.stream.off("close", listener));
    }
    onError(listener) {
      this.stream.on("error", listener);
      return disposable_1.Disposable.create(() => this.stream.off("error", listener));
    }
    onEnd(listener) {
      this.stream.on("end", listener);
      return disposable_1.Disposable.create(() => this.stream.off("end", listener));
    }
    write(data, encoding) {
      return new Promise((resolve, reject) => {
        const callback = (error) => {
          if (error === void 0 || error === null) {
            resolve();
          } else {
            reject(error);
          }
        };
        if (typeof data === "string") {
          this.stream.write(data, encoding, callback);
        } else {
          this.stream.write(data, callback);
        }
      });
    }
    end() {
      this.stream.end();
    }
  };
  var _ril = Object.freeze({
    messageBuffer: Object.freeze({
      create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
      encoder: Object.freeze({
        name: "application/json",
        encode: (msg, options) => {
          try {
            return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
          } catch (err) {
            return Promise.reject(err);
          }
        }
      }),
      decoder: Object.freeze({
        name: "application/json",
        decode: (buffer, options) => {
          try {
            if (buffer instanceof Buffer) {
              return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
            } else {
              return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
            }
          } catch (err) {
            return Promise.reject(err);
          }
        }
      })
    }),
    stream: Object.freeze({
      asReadableStream: (stream) => new ReadableStreamWrapper(stream),
      asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console,
    timer: Object.freeze({
      setTimeout(callback, ms, ...args) {
        const handle = setTimeout(callback, ms, ...args);
        return {dispose: () => clearTimeout(handle)};
      },
      setImmediate(callback, ...args) {
        const handle = setImmediate(callback, ...args);
        return {dispose: () => clearImmediate(handle)};
      },
      setInterval(callback, ms, ...args) {
        const handle = setInterval(callback, ms, ...args);
        return {dispose: () => clearInterval(handle)};
      }
    })
  });
  function RIL() {
    return _ril;
  }
  (function(RIL2) {
    function install() {
      ral_1.default.install(_ril);
    }
    RIL2.install = install;
  })(RIL || (RIL = {}));
  exports2.default = RIL;
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
  function boolean(value) {
    return value === true || value === false;
  }
  exports2.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports2.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports2.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports2.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports2.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports2.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string(elem));
  }
  exports2.stringArray = stringArray;
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isResponseMessage = exports2.isNotificationMessage = exports2.isRequestMessage = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
  var is = require_is();
  var ErrorCodes;
  (function(ErrorCodes2) {
    ErrorCodes2.ParseError = -32700;
    ErrorCodes2.InvalidRequest = -32600;
    ErrorCodes2.MethodNotFound = -32601;
    ErrorCodes2.InvalidParams = -32602;
    ErrorCodes2.InternalError = -32603;
    ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
    ErrorCodes2.serverErrorStart = ErrorCodes2.jsonrpcReservedErrorRangeStart;
    ErrorCodes2.MessageWriteError = -32099;
    ErrorCodes2.MessageReadError = -32098;
    ErrorCodes2.ServerNotInitialized = -32002;
    ErrorCodes2.UnknownErrorCode = -32001;
    ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
    ErrorCodes2.serverErrorEnd = ErrorCodes2.jsonrpcReservedErrorRangeEnd;
  })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
  var ResponseError = class extends Error {
    constructor(code, message, data) {
      super(message);
      this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
      this.data = data;
      Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
      const result = {
        code: this.code,
        message: this.message
      };
      if (this.data !== void 0) {
        result.data = this.data;
      }
      return result;
    }
  };
  exports2.ResponseError = ResponseError;
  var ParameterStructures = class {
    constructor(kind) {
      this.kind = kind;
    }
    static is(value) {
      return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
      return this.kind;
    }
  };
  exports2.ParameterStructures = ParameterStructures;
  ParameterStructures.auto = new ParameterStructures("auto");
  ParameterStructures.byPosition = new ParameterStructures("byPosition");
  ParameterStructures.byName = new ParameterStructures("byName");
  var AbstractMessageSignature = class {
    constructor(method, numberOfParams) {
      this.method = method;
      this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
      return ParameterStructures.auto;
    }
  };
  exports2.AbstractMessageSignature = AbstractMessageSignature;
  var RequestType0 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.RequestType0 = RequestType0;
  var RequestType2 = class extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  };
  exports2.RequestType = RequestType2;
  var RequestType1 = class extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  };
  exports2.RequestType1 = RequestType1;
  var RequestType22 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.RequestType2 = RequestType22;
  var RequestType3 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.RequestType3 = RequestType3;
  var RequestType4 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.RequestType4 = RequestType4;
  var RequestType5 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.RequestType5 = RequestType5;
  var RequestType6 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.RequestType6 = RequestType6;
  var RequestType7 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.RequestType7 = RequestType7;
  var RequestType8 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.RequestType8 = RequestType8;
  var RequestType9 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.RequestType9 = RequestType9;
  var NotificationType2 = class extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  };
  exports2.NotificationType = NotificationType2;
  var NotificationType02 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.NotificationType0 = NotificationType02;
  var NotificationType1 = class extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  };
  exports2.NotificationType1 = NotificationType1;
  var NotificationType22 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.NotificationType2 = NotificationType22;
  var NotificationType3 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.NotificationType3 = NotificationType3;
  var NotificationType4 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.NotificationType4 = NotificationType4;
  var NotificationType5 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.NotificationType5 = NotificationType5;
  var NotificationType6 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.NotificationType6 = NotificationType6;
  var NotificationType7 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.NotificationType7 = NotificationType7;
  var NotificationType8 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.NotificationType8 = NotificationType8;
  var NotificationType9 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.NotificationType9 = NotificationType9;
  function isRequestMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
  }
  exports2.isRequestMessage = isRequestMessage;
  function isNotificationMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
  }
  exports2.isNotificationMessage = isNotificationMessage;
  function isResponseMessage(message) {
    const candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
  }
  exports2.isResponseMessage = isResponseMessage;
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS((exports2) => {
  "use strict";
  var _a2;
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
  var Touch;
  (function(Touch2) {
    Touch2.None = 0;
    Touch2.First = 1;
    Touch2.AsOld = Touch2.First;
    Touch2.Last = 2;
    Touch2.AsNew = Touch2.Last;
  })(Touch = exports2.Touch || (exports2.Touch = {}));
  var LinkedMap = class {
    constructor() {
      this[_a2] = "LinkedMap";
      this._map = new Map();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state = 0;
    }
    clear() {
      this._map.clear();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      var _b;
      return (_b = this._head) === null || _b === void 0 ? void 0 : _b.value;
    }
    get last() {
      var _b;
      return (_b = this._tail) === null || _b === void 0 ? void 0 : _b.value;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key, touch = Touch.None) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      if (touch !== Touch.None) {
        this.touch(item, touch);
      }
      return item.value;
    }
    set(key, value, touch = Touch.None) {
      let item = this._map.get(key);
      if (item) {
        item.value = value;
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
      } else {
        item = {key, value, next: void 0, previous: void 0};
        switch (touch) {
          case Touch.None:
            this.addItemLast(item);
            break;
          case Touch.First:
            this.addItemFirst(item);
            break;
          case Touch.Last:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
      return this;
    }
    delete(key) {
      return !!this.remove(key);
    }
    remove(key) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    shift() {
      if (!this._head && !this._tail) {
        return void 0;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      const state = this._state;
      let current = this._head;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        if (this._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        current = current.next;
      }
    }
    keys() {
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]: () => {
          return iterator;
        },
        next: () => {
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = {value: current.key, done: false};
            current = current.next;
            return result;
          } else {
            return {value: void 0, done: true};
          }
        }
      };
      return iterator;
    }
    values() {
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]: () => {
          return iterator;
        },
        next: () => {
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = {value: current.value, done: false};
            current = current.next;
            return result;
          } else {
            return {value: void 0, done: true};
          }
        }
      };
      return iterator;
    }
    entries() {
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]: () => {
          return iterator;
        },
        next: () => {
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = {value: [current.key, current.value], done: false};
            current = current.next;
            return result;
          } else {
            return {value: void 0, done: true};
          }
        }
      };
      return iterator;
    }
    [(_a2 = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._head;
      let currentSize = this.size;
      while (current && currentSize > newSize) {
        this._map.delete(current.key);
        current = current.next;
        currentSize--;
      }
      this._head = current;
      this._size = currentSize;
      if (current) {
        current.previous = void 0;
      }
      this._state++;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
      this._state++;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
      this._state++;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = void 0;
        this._tail = void 0;
      } else if (item === this._head) {
        if (!item.next) {
          throw new Error("Invalid list");
        }
        item.next.previous = void 0;
        this._head = item.next;
      } else if (item === this._tail) {
        if (!item.previous) {
          throw new Error("Invalid list");
        }
        item.previous.next = void 0;
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous = item.previous;
        if (!next || !previous) {
          throw new Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = void 0;
      this._state++;
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== Touch.First && touch !== Touch.Last) {
        return;
      }
      if (touch === Touch.First) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._tail) {
          previous.next = void 0;
          this._tail = previous;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.previous = void 0;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
        this._state++;
      } else if (touch === Touch.Last) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._head) {
          next.previous = void 0;
          this._head = next;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
        this._state++;
      }
    }
    toJSON() {
      const data = [];
      this.forEach((value, key) => {
        data.push([key, value]);
      });
      return data;
    }
    fromJSON(data) {
      this.clear();
      for (const [key, value] of data) {
        this.set(key, value);
      }
    }
  };
  exports2.LinkedMap = LinkedMap;
  var LRUCache = class extends LinkedMap {
    constructor(limit, ratio = 1) {
      super();
      this._limit = limit;
      this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(limit) {
      this._limit = limit;
      this.checkTrim();
    }
    get ratio() {
      return this._ratio;
    }
    set ratio(ratio) {
      this._ratio = Math.min(Math.max(0, ratio), 1);
      this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
      return super.get(key, touch);
    }
    peek(key) {
      return super.get(key, Touch.None);
    }
    set(key, value) {
      super.set(key, value, Touch.Last);
      this.checkTrim();
      return this;
    }
    checkTrim() {
      if (this.size > this._limit) {
        this.trimOld(Math.round(this._limit * this._ratio));
      }
    }
  };
  exports2.LRUCache = LRUCache;
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Emitter = exports2.Event = void 0;
  var ral_1 = require_ral();
  var Event;
  (function(Event2) {
    const _disposable = {dispose() {
    }};
    Event2.None = function() {
      return _disposable;
    };
  })(Event = exports2.Event || (exports2.Event = {}));
  var CallbackList = class {
    add(callback, context = null, bucket) {
      if (!this._callbacks) {
        this._callbacks = [];
        this._contexts = [];
      }
      this._callbacks.push(callback);
      this._contexts.push(context);
      if (Array.isArray(bucket)) {
        bucket.push({dispose: () => this.remove(callback, context)});
      }
    }
    remove(callback, context = null) {
      if (!this._callbacks) {
        return;
      }
      let foundCallbackWithDifferentContext = false;
      for (let i = 0, len = this._callbacks.length; i < len; i++) {
        if (this._callbacks[i] === callback) {
          if (this._contexts[i] === context) {
            this._callbacks.splice(i, 1);
            this._contexts.splice(i, 1);
            return;
          } else {
            foundCallbackWithDifferentContext = true;
          }
        }
      }
      if (foundCallbackWithDifferentContext) {
        throw new Error("When adding a listener with a context, you should remove it with the same context");
      }
    }
    invoke(...args) {
      if (!this._callbacks) {
        return [];
      }
      const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
      for (let i = 0, len = callbacks.length; i < len; i++) {
        try {
          ret.push(callbacks[i].apply(contexts[i], args));
        } catch (e) {
          ral_1.default().console.error(e);
        }
      }
      return ret;
    }
    isEmpty() {
      return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
      this._callbacks = void 0;
      this._contexts = void 0;
    }
  };
  var Emitter = class {
    constructor(_options) {
      this._options = _options;
    }
    get event() {
      if (!this._event) {
        this._event = (listener, thisArgs, disposables) => {
          if (!this._callbacks) {
            this._callbacks = new CallbackList();
          }
          if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
            this._options.onFirstListenerAdd(this);
          }
          this._callbacks.add(listener, thisArgs);
          const result = {
            dispose: () => {
              if (!this._callbacks) {
                return;
              }
              this._callbacks.remove(listener, thisArgs);
              result.dispose = Emitter._noop;
              if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                this._options.onLastListenerRemove(this);
              }
            }
          };
          if (Array.isArray(disposables)) {
            disposables.push(result);
          }
          return result;
        };
      }
      return this._event;
    }
    fire(event) {
      if (this._callbacks) {
        this._callbacks.invoke.call(this._callbacks, event);
      }
    }
    dispose() {
      if (this._callbacks) {
        this._callbacks.dispose();
        this._callbacks = void 0;
      }
    }
  };
  exports2.Emitter = Emitter;
  Emitter._noop = function() {
  };
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
  var ral_1 = require_ral();
  var Is = require_is();
  var events_1 = require_events();
  var CancellationToken;
  (function(CancellationToken2) {
    CancellationToken2.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: events_1.Event.None
    });
    CancellationToken2.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: events_1.Event.None
    });
    function is(value) {
      const candidate = value;
      return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
    }
    CancellationToken2.is = is;
  })(CancellationToken = exports2.CancellationToken || (exports2.CancellationToken = {}));
  var shortcutEvent = Object.freeze(function(callback, context) {
    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
    return {dispose() {
      handle.dispose();
    }};
  });
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new events_1.Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = void 0;
      }
    }
  };
  var CancellationTokenSource = class {
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken.Cancelled;
      } else {
        this._token.cancel();
      }
    }
    dispose() {
      if (!this._token) {
        this._token = CancellationToken.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };
  exports2.CancellationTokenSource = CancellationTokenSource;
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
  var ral_1 = require_ral();
  var Is = require_is();
  var events_1 = require_events();
  var MessageReader;
  (function(MessageReader2) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader2.is = is;
  })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
  var AbstractMessageReader = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
      this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error) {
      this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    get onPartialMessage() {
      return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
      this.partialMessageEmitter.fire(info);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageReader = AbstractMessageReader;
  var ResolvedMessageReaderOptions;
  (function(ResolvedMessageReaderOptions2) {
    function fromOptions(options) {
      var _a2;
      let charset;
      let result;
      let contentDecoder;
      const contentDecoders = new Map();
      let contentTypeDecoder;
      const contentTypeDecoders = new Map();
      if (options === void 0 || typeof options === "string") {
        charset = options !== null && options !== void 0 ? options : "utf-8";
      } else {
        charset = (_a2 = options.charset) !== null && _a2 !== void 0 ? _a2 : "utf-8";
        if (options.contentDecoder !== void 0) {
          contentDecoder = options.contentDecoder;
          contentDecoders.set(contentDecoder.name, contentDecoder);
        }
        if (options.contentDecoders !== void 0) {
          for (const decoder of options.contentDecoders) {
            contentDecoders.set(decoder.name, decoder);
          }
        }
        if (options.contentTypeDecoder !== void 0) {
          contentTypeDecoder = options.contentTypeDecoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        if (options.contentTypeDecoders !== void 0) {
          for (const decoder of options.contentTypeDecoders) {
            contentTypeDecoders.set(decoder.name, decoder);
          }
        }
      }
      if (contentTypeDecoder === void 0) {
        contentTypeDecoder = ral_1.default().applicationJson.decoder;
        contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
      }
      return {charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders};
    }
    ResolvedMessageReaderOptions2.fromOptions = fromOptions;
  })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
  var ReadableStreamMessageReader = class extends AbstractMessageReader {
    constructor(readable, options) {
      super();
      this.readable = readable;
      this.options = ResolvedMessageReaderOptions.fromOptions(options);
      this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
      this._partialMessageTimeout = 1e4;
      this.nextMessageLength = -1;
      this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
      this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
      return this._partialMessageTimeout;
    }
    listen(callback) {
      this.nextMessageLength = -1;
      this.messageToken = 0;
      this.partialMessageTimer = void 0;
      this.callback = callback;
      const result = this.readable.onData((data) => {
        this.onData(data);
      });
      this.readable.onError((error) => this.fireError(error));
      this.readable.onClose(() => this.fireClose());
      return result;
    }
    onData(data) {
      this.buffer.append(data);
      while (true) {
        if (this.nextMessageLength === -1) {
          const headers = this.buffer.tryReadHeaders();
          if (!headers) {
            return;
          }
          const contentLength = headers.get("Content-Length");
          if (!contentLength) {
            throw new Error("Header must provide a Content-Length property.");
          }
          const length = parseInt(contentLength);
          if (isNaN(length)) {
            throw new Error("Content-Length value must be a number.");
          }
          this.nextMessageLength = length;
        }
        const body = this.buffer.tryReadBody(this.nextMessageLength);
        if (body === void 0) {
          this.setPartialMessageTimer();
          return;
        }
        this.clearPartialMessageTimer();
        this.nextMessageLength = -1;
        let p;
        if (this.options.contentDecoder !== void 0) {
          p = this.options.contentDecoder.decode(body);
        } else {
          p = Promise.resolve(body);
        }
        p.then((value) => {
          this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
            this.callback(msg);
          }, (error) => {
            this.fireError(error);
          });
        }, (error) => {
          this.fireError(error);
        });
      }
    }
    clearPartialMessageTimer() {
      if (this.partialMessageTimer) {
        this.partialMessageTimer.dispose();
        this.partialMessageTimer = void 0;
      }
    }
    setPartialMessageTimer() {
      this.clearPartialMessageTimer();
      if (this._partialMessageTimeout <= 0) {
        return;
      }
      this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
        this.partialMessageTimer = void 0;
        if (token === this.messageToken) {
          this.firePartialMessage({messageToken: token, waitingTime: timeout});
          this.setPartialMessageTimer();
        }
      }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
  };
  exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Semaphore = void 0;
  var ral_1 = require_ral();
  var Semaphore = class {
    constructor(capacity = 1) {
      if (capacity <= 0) {
        throw new Error("Capacity must be greater than 0");
      }
      this._capacity = capacity;
      this._active = 0;
      this._waiting = [];
    }
    lock(thunk) {
      return new Promise((resolve, reject) => {
        this._waiting.push({thunk, resolve, reject});
        this.runNext();
      });
    }
    get active() {
      return this._active;
    }
    runNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      ral_1.default().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      const next = this._waiting.shift();
      this._active++;
      if (this._active > this._capacity) {
        throw new Error(`To many thunks active`);
      }
      try {
        const result = next.thunk();
        if (result instanceof Promise) {
          result.then((value) => {
            this._active--;
            next.resolve(value);
            this.runNext();
          }, (err) => {
            this._active--;
            next.reject(err);
            this.runNext();
          });
        } else {
          this._active--;
          next.resolve(result);
          this.runNext();
        }
      } catch (err) {
        this._active--;
        next.reject(err);
        this.runNext();
      }
    }
  };
  exports2.Semaphore = Semaphore;
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
  var ral_1 = require_ral();
  var Is = require_is();
  var semaphore_1 = require_semaphore();
  var events_1 = require_events();
  var ContentLength = "Content-Length: ";
  var CRLF = "\r\n";
  var MessageWriter;
  (function(MessageWriter2) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter2.is = is;
  })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
  var AbstractMessageWriter = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error, message, count) {
      this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageWriter = AbstractMessageWriter;
  var ResolvedMessageWriterOptions;
  (function(ResolvedMessageWriterOptions2) {
    function fromOptions(options) {
      var _a2, _b;
      if (options === void 0 || typeof options === "string") {
        return {charset: options !== null && options !== void 0 ? options : "utf-8", contentTypeEncoder: ral_1.default().applicationJson.encoder};
      } else {
        return {charset: (_a2 = options.charset) !== null && _a2 !== void 0 ? _a2 : "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder};
      }
    }
    ResolvedMessageWriterOptions2.fromOptions = fromOptions;
  })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
  var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
    constructor(writable, options) {
      super();
      this.writable = writable;
      this.options = ResolvedMessageWriterOptions.fromOptions(options);
      this.errorCount = 0;
      this.writeSemaphore = new semaphore_1.Semaphore(1);
      this.writable.onError((error) => this.fireError(error));
      this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
      return this.writeSemaphore.lock(async () => {
        const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
          if (this.options.contentEncoder !== void 0) {
            return this.options.contentEncoder.encode(buffer);
          } else {
            return buffer;
          }
        });
        return payload.then((buffer) => {
          const headers = [];
          headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
          headers.push(CRLF);
          return this.doWrite(msg, headers, buffer);
        }, (error) => {
          this.fireError(error);
          throw error;
        });
      });
    }
    async doWrite(msg, headers, data) {
      try {
        await this.writable.write(headers.join(""), "ascii");
        return this.writable.write(data);
      } catch (error) {
        this.handleError(error, msg);
        return Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
    end() {
      this.writable.end();
    }
  };
  exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.NullLogger = exports2.ProgressType = void 0;
  var ral_1 = require_ral();
  var Is = require_is();
  var messages_1 = require_messages();
  var linkedMap_1 = require_linkedMap();
  var events_1 = require_events();
  var cancellation_1 = require_cancellation();
  var CancelNotification;
  (function(CancelNotification2) {
    CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
  })(CancelNotification || (CancelNotification = {}));
  var ProgressNotification;
  (function(ProgressNotification2) {
    ProgressNotification2.type = new messages_1.NotificationType("$/progress");
  })(ProgressNotification || (ProgressNotification = {}));
  var ProgressType = class {
    constructor() {
    }
  };
  exports2.ProgressType = ProgressType;
  var StarRequestHandler;
  (function(StarRequestHandler2) {
    function is(value) {
      return Is.func(value);
    }
    StarRequestHandler2.is = is;
  })(StarRequestHandler || (StarRequestHandler = {}));
  exports2.NullLogger = Object.freeze({
    error: () => {
    },
    warn: () => {
    },
    info: () => {
    },
    log: () => {
    }
  });
  var Trace;
  (function(Trace2) {
    Trace2[Trace2["Off"] = 0] = "Off";
    Trace2[Trace2["Messages"] = 1] = "Messages";
    Trace2[Trace2["Verbose"] = 2] = "Verbose";
  })(Trace = exports2.Trace || (exports2.Trace = {}));
  (function(Trace2) {
    function fromString(value) {
      if (!Is.string(value)) {
        return Trace2.Off;
      }
      value = value.toLowerCase();
      switch (value) {
        case "off":
          return Trace2.Off;
        case "messages":
          return Trace2.Messages;
        case "verbose":
          return Trace2.Verbose;
        default:
          return Trace2.Off;
      }
    }
    Trace2.fromString = fromString;
    function toString(value) {
      switch (value) {
        case Trace2.Off:
          return "off";
        case Trace2.Messages:
          return "messages";
        case Trace2.Verbose:
          return "verbose";
        default:
          return "off";
      }
    }
    Trace2.toString = toString;
  })(Trace = exports2.Trace || (exports2.Trace = {}));
  var TraceFormat;
  (function(TraceFormat2) {
    TraceFormat2["Text"] = "text";
    TraceFormat2["JSON"] = "json";
  })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
  (function(TraceFormat2) {
    function fromString(value) {
      if (!Is.string(value)) {
        return TraceFormat2.Text;
      }
      value = value.toLowerCase();
      if (value === "json") {
        return TraceFormat2.JSON;
      } else {
        return TraceFormat2.Text;
      }
    }
    TraceFormat2.fromString = fromString;
  })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
  var SetTraceNotification;
  (function(SetTraceNotification2) {
    SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
  })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
  var LogTraceNotification;
  (function(LogTraceNotification2) {
    LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
  })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
  var ConnectionErrors;
  (function(ConnectionErrors2) {
    ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
    ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
    ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
  })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
  var ConnectionError = class extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
      Object.setPrototypeOf(this, ConnectionError.prototype);
    }
  };
  exports2.ConnectionError = ConnectionError;
  var ConnectionStrategy;
  (function(ConnectionStrategy2) {
    function is(value) {
      const candidate = value;
      return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy2.is = is;
  })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
  var CancellationReceiverStrategy;
  (function(CancellationReceiverStrategy2) {
    CancellationReceiverStrategy2.Message = Object.freeze({
      createCancellationTokenSource(_) {
        return new cancellation_1.CancellationTokenSource();
      }
    });
    function is(value) {
      const candidate = value;
      return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy2.is = is;
  })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
  var CancellationSenderStrategy;
  (function(CancellationSenderStrategy2) {
    CancellationSenderStrategy2.Message = Object.freeze({
      sendCancellation(conn, id) {
        return conn.sendNotification(CancelNotification.type, {id});
      },
      cleanup(_) {
      }
    });
    function is(value) {
      const candidate = value;
      return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy2.is = is;
  })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
  var CancellationStrategy;
  (function(CancellationStrategy2) {
    CancellationStrategy2.Message = Object.freeze({
      receiver: CancellationReceiverStrategy.Message,
      sender: CancellationSenderStrategy.Message
    });
    function is(value) {
      const candidate = value;
      return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy2.is = is;
  })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
  var ConnectionOptions;
  (function(ConnectionOptions2) {
    function is(value) {
      const candidate = value;
      return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions2.is = is;
  })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2[ConnectionState2["New"] = 1] = "New";
    ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
    ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
    ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
  })(ConnectionState || (ConnectionState = {}));
  function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = "2.0";
    let starRequestHandler = void 0;
    const requestHandlers = Object.create(null);
    let starNotificationHandler = void 0;
    const notificationHandlers = Object.create(null);
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let knownCanceledRequests = new Set();
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
      if (id === null) {
        throw new Error(`Can't send requests with id null since the response can't be correlated.`);
      }
      return "req-" + id.toString();
    }
    function createResponseQueueKey(id) {
      if (id === null) {
        return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
      } else {
        return "res-" + id.toString();
      }
    }
    function createNotificationQueueKey() {
      return "not-" + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
      if (messages_1.isRequestMessage(message)) {
        queue.set(createRequestQueueKey(message.id), message);
      } else if (messages_1.isResponseMessage(message)) {
        queue.set(createResponseQueueKey(message.id), message);
      } else {
        queue.set(createNotificationQueueKey(), message);
      }
    }
    function cancelUndispatched(_message) {
      return void 0;
    }
    function isListening() {
      return state === ConnectionState.Listening;
    }
    function isClosed() {
      return state === ConnectionState.Closed;
    }
    function isDisposed() {
      return state === ConnectionState.Disposed;
    }
    function closeHandler() {
      if (state === ConnectionState.New || state === ConnectionState.Listening) {
        state = ConnectionState.Closed;
        closeEmitter.fire(void 0);
      }
    }
    function readErrorHandler(error) {
      errorEmitter.fire([error, void 0, void 0]);
    }
    function writeErrorHandler(data) {
      errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
      if (timer || messageQueue.size === 0) {
        return;
      }
      timer = ral_1.default().timer.setImmediate(() => {
        timer = void 0;
        processMessageQueue();
      });
    }
    function processMessageQueue() {
      if (messageQueue.size === 0) {
        return;
      }
      const message = messageQueue.shift();
      try {
        if (messages_1.isRequestMessage(message)) {
          handleRequest(message);
        } else if (messages_1.isNotificationMessage(message)) {
          handleNotification(message);
        } else if (messages_1.isResponseMessage(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      } finally {
        triggerMessageQueue();
      }
    }
    const callback = (message) => {
      try {
        if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          const key = createRequestQueueKey(cancelId);
          const toCancel = messageQueue.get(key);
          if (messages_1.isRequestMessage(toCancel)) {
            const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
            const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
            if (response && (response.error !== void 0 || response.result !== void 0)) {
              messageQueue.delete(key);
              response.id = toCancel.id;
              traceSendingResponse(response, message.method, Date.now());
              messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
              return;
            }
          }
          const tokenKey = String(cancelId);
          const cancellationToken = requestTokens[tokenKey];
          if (cancellationToken !== void 0) {
            cancellationToken.cancel();
            traceReceivedNotification(message);
            return;
          } else {
            knownCanceledRequests.add(cancelId);
          }
        }
        addMessageToQueue(messageQueue, message);
      } finally {
        triggerMessageQueue();
      }
    };
    function handleRequest(requestMessage) {
      if (isDisposed()) {
        return;
      }
      function reply(resultOrError, method, startTime2) {
        const message = {
          jsonrpc: version,
          id: requestMessage.id
        };
        if (resultOrError instanceof messages_1.ResponseError) {
          message.error = resultOrError.toJson();
        } else {
          message.result = resultOrError === void 0 ? null : resultOrError;
        }
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
      }
      function replyError(error, method, startTime2) {
        const message = {
          jsonrpc: version,
          id: requestMessage.id,
          error: error.toJson()
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
      }
      function replySuccess(result, method, startTime2) {
        if (result === void 0) {
          result = null;
        }
        const message = {
          jsonrpc: version,
          id: requestMessage.id,
          result
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
      }
      traceReceivedRequest(requestMessage);
      const element = requestHandlers[requestMessage.method];
      let type;
      let requestHandler;
      if (element) {
        type = element.type;
        requestHandler = element.handler;
      }
      const startTime = Date.now();
      if (requestHandler || starRequestHandler) {
        const tokenKey = String(requestMessage.id);
        const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
        if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
          cancellationSource.cancel();
        }
        requestTokens[tokenKey] = cancellationSource;
        try {
          let handlerResult;
          if (requestHandler) {
            if (requestMessage.params === void 0) {
              if (type !== void 0 && type.numberOfParams !== 0) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(cancellationSource.token);
            } else if (Array.isArray(requestMessage.params)) {
              if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
            } else {
              if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
            }
          } else if (starRequestHandler) {
            handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
          }
          const promise = handlerResult;
          if (!handlerResult) {
            delete requestTokens[tokenKey];
            replySuccess(handlerResult, requestMessage.method, startTime);
          } else if (promise.then) {
            promise.then((resultOrError) => {
              delete requestTokens[tokenKey];
              reply(resultOrError, requestMessage.method, startTime);
            }, (error) => {
              delete requestTokens[tokenKey];
              if (error instanceof messages_1.ResponseError) {
                replyError(error, requestMessage.method, startTime);
              } else if (error && Is.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            });
          } else {
            delete requestTokens[tokenKey];
            reply(handlerResult, requestMessage.method, startTime);
          }
        } catch (error) {
          delete requestTokens[tokenKey];
          if (error instanceof messages_1.ResponseError) {
            reply(error, requestMessage.method, startTime);
          } else if (error && Is.string(error.message)) {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
          }
        }
      } else {
        replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
      }
    }
    function handleResponse(responseMessage) {
      if (isDisposed()) {
        return;
      }
      if (responseMessage.id === null) {
        if (responseMessage.error) {
          logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
        } else {
          logger.error(`Received response message without id. No further error information provided.`);
        }
      } else {
        const key = String(responseMessage.id);
        const responsePromise = responsePromises[key];
        traceReceivedResponse(responseMessage, responsePromise);
        if (responsePromise) {
          delete responsePromises[key];
          try {
            if (responseMessage.error) {
              const error = responseMessage.error;
              responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
            } else if (responseMessage.result !== void 0) {
              responsePromise.resolve(responseMessage.result);
            } else {
              throw new Error("Should never happen.");
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
            }
          }
        }
      }
    }
    function handleNotification(message) {
      if (isDisposed()) {
        return;
      }
      let type = void 0;
      let notificationHandler;
      if (message.method === CancelNotification.type.method) {
        const cancelId = message.params.id;
        knownCanceledRequests.delete(cancelId);
        traceReceivedNotification(message);
        return;
      } else {
        const element = notificationHandlers[message.method];
        if (element) {
          notificationHandler = element.handler;
          type = element.type;
        }
      }
      if (notificationHandler || starNotificationHandler) {
        try {
          traceReceivedNotification(message);
          if (notificationHandler) {
            if (message.params === void 0) {
              if (type !== void 0) {
                if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                  logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                }
              }
              notificationHandler();
            } else if (Array.isArray(message.params)) {
              if (type !== void 0) {
                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                  logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                }
                if (type.numberOfParams !== message.params.length) {
                  logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} arguments`);
                }
              }
              notificationHandler(...message.params);
            } else {
              if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
              }
              notificationHandler(message.params);
            }
          } else if (starNotificationHandler) {
            starNotificationHandler(message.method, message.params);
          }
        } catch (error) {
          if (error.message) {
            logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
          } else {
            logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
          }
        }
      } else {
        unhandledNotificationEmitter.fire(message);
      }
    }
    function handleInvalidMessage(message) {
      if (!message) {
        logger.error("Received empty message.");
        return;
      }
      logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
      const responseMessage = message;
      if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
        const key = String(responseMessage.id);
        const responseHandler = responsePromises[key];
        if (responseHandler) {
          responseHandler.reject(new Error("The received response has neither a result nor an error property."));
        }
      }
    }
    function traceSendingRequest(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("send-request", message);
      }
    }
    function traceSendingNotification(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Sending notification '${message.method}'.`, data);
      } else {
        logLSPMessage("send-notification", message);
      }
    }
    function traceSendingResponse(message, method, startTime) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
      } else {
        logLSPMessage("send-response", message);
      }
    }
    function traceReceivedRequest(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("receive-request", message);
      }
    }
    function traceReceivedNotification(message) {
      if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Received notification '${message.method}'.`, data);
      } else {
        logLSPMessage("receive-notification", message);
      }
    }
    function traceReceivedResponse(message, responsePromise) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        if (responsePromise) {
          const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
          tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
        } else {
          tracer.log(`Received response ${message.id} without active response promise.`, data);
        }
      } else {
        logLSPMessage("receive-response", message);
      }
    }
    function logLSPMessage(type, message) {
      if (!tracer || trace === Trace.Off) {
        return;
      }
      const lspMessage = {
        isLSPMessage: true,
        type,
        message,
        timestamp: Date.now()
      };
      tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
      if (isClosed()) {
        throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
      }
      if (isDisposed()) {
        throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
      }
    }
    function throwIfListening() {
      if (isListening()) {
        throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
      }
    }
    function throwIfNotListening() {
      if (!isListening()) {
        throw new Error("Call listen() first.");
      }
    }
    function undefinedToNull(param) {
      if (param === void 0) {
        return null;
      } else {
        return param;
      }
    }
    function nullToUndefined(param) {
      if (param === null) {
        return void 0;
      } else {
        return param;
      }
    }
    function isNamedParam(param) {
      return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
    }
    function computeSingleParam(parameterStructures, param) {
      switch (parameterStructures) {
        case messages_1.ParameterStructures.auto:
          if (isNamedParam(param)) {
            return nullToUndefined(param);
          } else {
            return [undefinedToNull(param)];
          }
        case messages_1.ParameterStructures.byName:
          if (!isNamedParam(param)) {
            throw new Error(`Received parameters by name but param is not an object literal.`);
          }
          return nullToUndefined(param);
        case messages_1.ParameterStructures.byPosition:
          return [undefinedToNull(param)];
        default:
          throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
      }
    }
    function computeMessageParams(type, params) {
      let result;
      const numberOfParams = type.numberOfParams;
      switch (numberOfParams) {
        case 0:
          result = void 0;
          break;
        case 1:
          result = computeSingleParam(type.parameterStructures, params[0]);
          break;
        default:
          result = [];
          for (let i = 0; i < params.length && i < numberOfParams; i++) {
            result.push(undefinedToNull(params[i]));
          }
          if (params.length < numberOfParams) {
            for (let i = params.length; i < numberOfParams; i++) {
              result.push(null);
            }
          }
          break;
      }
      return result;
    }
    const connection = {
      sendNotification: (type, ...args) => {
        throwIfClosedOrDisposed();
        let method;
        let messageParams;
        if (Is.string(type)) {
          method = type;
          const first = args[0];
          let paramStart = 0;
          let parameterStructures = messages_1.ParameterStructures.auto;
          if (messages_1.ParameterStructures.is(first)) {
            paramStart = 1;
            parameterStructures = first;
          }
          let paramEnd = args.length;
          const numberOfParams = paramEnd - paramStart;
          switch (numberOfParams) {
            case 0:
              messageParams = void 0;
              break;
            case 1:
              messageParams = computeSingleParam(parameterStructures, args[paramStart]);
              break;
            default:
              if (parameterStructures === messages_1.ParameterStructures.byName) {
                throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
              }
              messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
              break;
          }
        } else {
          const params = args;
          method = type.method;
          messageParams = computeMessageParams(type, params);
        }
        const notificationMessage = {
          jsonrpc: version,
          method,
          params: messageParams
        };
        traceSendingNotification(notificationMessage);
        return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
      },
      onNotification: (type, handler) => {
        throwIfClosedOrDisposed();
        let method;
        if (Is.func(type)) {
          starNotificationHandler = type;
        } else if (handler) {
          if (Is.string(type)) {
            method = type;
            notificationHandlers[type] = {type: void 0, handler};
          } else {
            method = type.method;
            notificationHandlers[type.method] = {type, handler};
          }
        }
        return {
          dispose: () => {
            if (method !== void 0) {
              delete notificationHandlers[method];
            } else {
              starNotificationHandler = void 0;
            }
          }
        };
      },
      onProgress: (_type, token, handler) => {
        if (progressHandlers.has(token)) {
          throw new Error(`Progress handler for token ${token} already registered`);
        }
        progressHandlers.set(token, handler);
        return {
          dispose: () => {
            progressHandlers.delete(token);
          }
        };
      },
      sendProgress: (_type, token, value) => {
        return connection.sendNotification(ProgressNotification.type, {token, value});
      },
      onUnhandledProgress: unhandledProgressEmitter.event,
      sendRequest: (type, ...args) => {
        throwIfClosedOrDisposed();
        throwIfNotListening();
        let method;
        let messageParams;
        let token = void 0;
        if (Is.string(type)) {
          method = type;
          const first = args[0];
          const last = args[args.length - 1];
          let paramStart = 0;
          let parameterStructures = messages_1.ParameterStructures.auto;
          if (messages_1.ParameterStructures.is(first)) {
            paramStart = 1;
            parameterStructures = first;
          }
          let paramEnd = args.length;
          if (cancellation_1.CancellationToken.is(last)) {
            paramEnd = paramEnd - 1;
            token = last;
          }
          const numberOfParams = paramEnd - paramStart;
          switch (numberOfParams) {
            case 0:
              messageParams = void 0;
              break;
            case 1:
              messageParams = computeSingleParam(parameterStructures, args[paramStart]);
              break;
            default:
              if (parameterStructures === messages_1.ParameterStructures.byName) {
                throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
              }
              messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
              break;
          }
        } else {
          const params = args;
          method = type.method;
          messageParams = computeMessageParams(type, params);
          const numberOfParams = type.numberOfParams;
          token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
        }
        const id = sequenceNumber++;
        let disposable;
        if (token) {
          disposable = token.onCancellationRequested(() => {
            const p = cancellationStrategy.sender.sendCancellation(connection, id);
            if (p === void 0) {
              logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
              return Promise.resolve();
            } else {
              return p.catch(() => {
                logger.log(`Sending cancellation messages for id ${id} failed`);
              });
            }
          });
        }
        const result = new Promise((resolve, reject) => {
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          const resolveWithCleanup = (r) => {
            resolve(r);
            cancellationStrategy.sender.cleanup(id);
            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
          };
          const rejectWithCleanup = (r) => {
            reject(r);
            cancellationStrategy.sender.cleanup(id);
            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
          };
          let responsePromise = {method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup};
          traceSendingRequest(requestMessage);
          try {
            messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
          } catch (e) {
            responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
            responsePromise = null;
          }
          if (responsePromise) {
            responsePromises[String(id)] = responsePromise;
          }
        });
        return result;
      },
      onRequest: (type, handler) => {
        throwIfClosedOrDisposed();
        let method = null;
        if (StarRequestHandler.is(type)) {
          method = void 0;
          starRequestHandler = type;
        } else if (Is.string(type)) {
          method = null;
          if (handler !== void 0) {
            method = type;
            requestHandlers[type] = {handler, type: void 0};
          }
        } else {
          if (handler !== void 0) {
            method = type.method;
            requestHandlers[type.method] = {type, handler};
          }
        }
        return {
          dispose: () => {
            if (method === null) {
              return;
            }
            if (method !== void 0) {
              delete requestHandlers[method];
            } else {
              starRequestHandler = void 0;
            }
          }
        };
      },
      trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
        let _sendNotification = false;
        let _traceFormat = TraceFormat.Text;
        if (sendNotificationOrTraceOptions !== void 0) {
          if (Is.boolean(sendNotificationOrTraceOptions)) {
            _sendNotification = sendNotificationOrTraceOptions;
          } else {
            _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
            _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
          }
        }
        trace = _value;
        traceFormat = _traceFormat;
        if (trace === Trace.Off) {
          tracer = void 0;
        } else {
          tracer = _tracer;
        }
        if (_sendNotification && !isClosed() && !isDisposed()) {
          connection.sendNotification(SetTraceNotification.type, {value: Trace.toString(_value)}).catch(() => {
            logger.error(`Sending trace notification failed`);
          });
        }
      },
      onError: errorEmitter.event,
      onClose: closeEmitter.event,
      onUnhandledNotification: unhandledNotificationEmitter.event,
      onDispose: disposeEmitter.event,
      end: () => {
        messageWriter.end();
      },
      dispose: () => {
        if (isDisposed()) {
          return;
        }
        state = ConnectionState.Disposed;
        disposeEmitter.fire(void 0);
        const error = new Error("Connection got disposed.");
        Object.keys(responsePromises).forEach((key) => {
          responsePromises[key].reject(error);
        });
        responsePromises = Object.create(null);
        requestTokens = Object.create(null);
        knownCanceledRequests = new Set();
        messageQueue = new linkedMap_1.LinkedMap();
        if (Is.func(messageWriter.dispose)) {
          messageWriter.dispose();
        }
        if (Is.func(messageReader.dispose)) {
          messageReader.dispose();
        }
      },
      listen: () => {
        throwIfClosedOrDisposed();
        throwIfListening();
        state = ConnectionState.Listening;
        messageReader.listen(callback);
      },
      inspect: () => {
        ral_1.default().console.log("inspect");
      }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      tracer.log(params.message, trace === Trace.Verbose ? params.verbose : void 0);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
      const handler = progressHandlers.get(params.token);
      if (handler) {
        handler(params.value);
      } else {
        unhandledProgressEmitter.fire(params);
      }
    });
    return connection;
  }
  exports2.createMessageConnection = createMessageConnection;
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.ProgressType = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.RAL = void 0;
  exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = void 0;
  var messages_1 = require_messages();
  Object.defineProperty(exports2, "RequestType", {enumerable: true, get: function() {
    return messages_1.RequestType;
  }});
  Object.defineProperty(exports2, "RequestType0", {enumerable: true, get: function() {
    return messages_1.RequestType0;
  }});
  Object.defineProperty(exports2, "RequestType1", {enumerable: true, get: function() {
    return messages_1.RequestType1;
  }});
  Object.defineProperty(exports2, "RequestType2", {enumerable: true, get: function() {
    return messages_1.RequestType2;
  }});
  Object.defineProperty(exports2, "RequestType3", {enumerable: true, get: function() {
    return messages_1.RequestType3;
  }});
  Object.defineProperty(exports2, "RequestType4", {enumerable: true, get: function() {
    return messages_1.RequestType4;
  }});
  Object.defineProperty(exports2, "RequestType5", {enumerable: true, get: function() {
    return messages_1.RequestType5;
  }});
  Object.defineProperty(exports2, "RequestType6", {enumerable: true, get: function() {
    return messages_1.RequestType6;
  }});
  Object.defineProperty(exports2, "RequestType7", {enumerable: true, get: function() {
    return messages_1.RequestType7;
  }});
  Object.defineProperty(exports2, "RequestType8", {enumerable: true, get: function() {
    return messages_1.RequestType8;
  }});
  Object.defineProperty(exports2, "RequestType9", {enumerable: true, get: function() {
    return messages_1.RequestType9;
  }});
  Object.defineProperty(exports2, "ResponseError", {enumerable: true, get: function() {
    return messages_1.ResponseError;
  }});
  Object.defineProperty(exports2, "ErrorCodes", {enumerable: true, get: function() {
    return messages_1.ErrorCodes;
  }});
  Object.defineProperty(exports2, "NotificationType", {enumerable: true, get: function() {
    return messages_1.NotificationType;
  }});
  Object.defineProperty(exports2, "NotificationType0", {enumerable: true, get: function() {
    return messages_1.NotificationType0;
  }});
  Object.defineProperty(exports2, "NotificationType1", {enumerable: true, get: function() {
    return messages_1.NotificationType1;
  }});
  Object.defineProperty(exports2, "NotificationType2", {enumerable: true, get: function() {
    return messages_1.NotificationType2;
  }});
  Object.defineProperty(exports2, "NotificationType3", {enumerable: true, get: function() {
    return messages_1.NotificationType3;
  }});
  Object.defineProperty(exports2, "NotificationType4", {enumerable: true, get: function() {
    return messages_1.NotificationType4;
  }});
  Object.defineProperty(exports2, "NotificationType5", {enumerable: true, get: function() {
    return messages_1.NotificationType5;
  }});
  Object.defineProperty(exports2, "NotificationType6", {enumerable: true, get: function() {
    return messages_1.NotificationType6;
  }});
  Object.defineProperty(exports2, "NotificationType7", {enumerable: true, get: function() {
    return messages_1.NotificationType7;
  }});
  Object.defineProperty(exports2, "NotificationType8", {enumerable: true, get: function() {
    return messages_1.NotificationType8;
  }});
  Object.defineProperty(exports2, "NotificationType9", {enumerable: true, get: function() {
    return messages_1.NotificationType9;
  }});
  Object.defineProperty(exports2, "ParameterStructures", {enumerable: true, get: function() {
    return messages_1.ParameterStructures;
  }});
  var linkedMap_1 = require_linkedMap();
  Object.defineProperty(exports2, "LinkedMap", {enumerable: true, get: function() {
    return linkedMap_1.LinkedMap;
  }});
  Object.defineProperty(exports2, "LRUCache", {enumerable: true, get: function() {
    return linkedMap_1.LRUCache;
  }});
  Object.defineProperty(exports2, "Touch", {enumerable: true, get: function() {
    return linkedMap_1.Touch;
  }});
  var disposable_1 = require_disposable();
  Object.defineProperty(exports2, "Disposable", {enumerable: true, get: function() {
    return disposable_1.Disposable;
  }});
  var events_1 = require_events();
  Object.defineProperty(exports2, "Event", {enumerable: true, get: function() {
    return events_1.Event;
  }});
  Object.defineProperty(exports2, "Emitter", {enumerable: true, get: function() {
    return events_1.Emitter;
  }});
  var cancellation_1 = require_cancellation();
  Object.defineProperty(exports2, "CancellationTokenSource", {enumerable: true, get: function() {
    return cancellation_1.CancellationTokenSource;
  }});
  Object.defineProperty(exports2, "CancellationToken", {enumerable: true, get: function() {
    return cancellation_1.CancellationToken;
  }});
  var messageReader_1 = require_messageReader();
  Object.defineProperty(exports2, "MessageReader", {enumerable: true, get: function() {
    return messageReader_1.MessageReader;
  }});
  Object.defineProperty(exports2, "AbstractMessageReader", {enumerable: true, get: function() {
    return messageReader_1.AbstractMessageReader;
  }});
  Object.defineProperty(exports2, "ReadableStreamMessageReader", {enumerable: true, get: function() {
    return messageReader_1.ReadableStreamMessageReader;
  }});
  var messageWriter_1 = require_messageWriter();
  Object.defineProperty(exports2, "MessageWriter", {enumerable: true, get: function() {
    return messageWriter_1.MessageWriter;
  }});
  Object.defineProperty(exports2, "AbstractMessageWriter", {enumerable: true, get: function() {
    return messageWriter_1.AbstractMessageWriter;
  }});
  Object.defineProperty(exports2, "WriteableStreamMessageWriter", {enumerable: true, get: function() {
    return messageWriter_1.WriteableStreamMessageWriter;
  }});
  var connection_1 = require_connection();
  Object.defineProperty(exports2, "ConnectionStrategy", {enumerable: true, get: function() {
    return connection_1.ConnectionStrategy;
  }});
  Object.defineProperty(exports2, "ConnectionOptions", {enumerable: true, get: function() {
    return connection_1.ConnectionOptions;
  }});
  Object.defineProperty(exports2, "NullLogger", {enumerable: true, get: function() {
    return connection_1.NullLogger;
  }});
  Object.defineProperty(exports2, "createMessageConnection", {enumerable: true, get: function() {
    return connection_1.createMessageConnection;
  }});
  Object.defineProperty(exports2, "ProgressType", {enumerable: true, get: function() {
    return connection_1.ProgressType;
  }});
  Object.defineProperty(exports2, "Trace", {enumerable: true, get: function() {
    return connection_1.Trace;
  }});
  Object.defineProperty(exports2, "TraceFormat", {enumerable: true, get: function() {
    return connection_1.TraceFormat;
  }});
  Object.defineProperty(exports2, "SetTraceNotification", {enumerable: true, get: function() {
    return connection_1.SetTraceNotification;
  }});
  Object.defineProperty(exports2, "LogTraceNotification", {enumerable: true, get: function() {
    return connection_1.LogTraceNotification;
  }});
  Object.defineProperty(exports2, "ConnectionErrors", {enumerable: true, get: function() {
    return connection_1.ConnectionErrors;
  }});
  Object.defineProperty(exports2, "ConnectionError", {enumerable: true, get: function() {
    return connection_1.ConnectionError;
  }});
  Object.defineProperty(exports2, "CancellationReceiverStrategy", {enumerable: true, get: function() {
    return connection_1.CancellationReceiverStrategy;
  }});
  Object.defineProperty(exports2, "CancellationSenderStrategy", {enumerable: true, get: function() {
    return connection_1.CancellationSenderStrategy;
  }});
  Object.defineProperty(exports2, "CancellationStrategy", {enumerable: true, get: function() {
    return connection_1.CancellationStrategy;
  }});
  var ral_1 = require_ral();
  exports2.RAL = ral_1.default;
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
  var ril_1 = require_ril();
  ril_1.default.install();
  var api_1 = require_api();
  var path4 = require("path");
  var os = require("os");
  var crypto_1 = require("crypto");
  var net_1 = require("net");
  __exportStar2(require_api(), exports2);
  var IPCMessageReader = class extends api_1.AbstractMessageReader {
    constructor(process2) {
      super();
      this.process = process2;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose());
    }
    listen(callback) {
      this.process.on("message", callback);
      return api_1.Disposable.create(() => this.process.off("message", callback));
    }
  };
  exports2.IPCMessageReader = IPCMessageReader;
  var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
    constructor(process2) {
      super();
      this.process = process2;
      this.errorCount = 0;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose);
    }
    write(msg) {
      try {
        if (typeof this.process.send === "function") {
          this.process.send(msg, void 0, void 0, (error) => {
            if (error) {
              this.errorCount++;
              this.handleError(error, msg);
            } else {
              this.errorCount = 0;
            }
          });
        }
        return Promise.resolve();
      } catch (error) {
        this.handleError(error, msg);
        return Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
  };
  exports2.IPCMessageWriter = IPCMessageWriter;
  var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = "utf-8") {
      super(ril_1.default().stream.asReadableStream(socket), encoding);
    }
  };
  exports2.SocketMessageReader = SocketMessageReader;
  var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
      super(ril_1.default().stream.asWritableStream(socket), options);
      this.socket = socket;
    }
    dispose() {
      super.dispose();
      this.socket.destroy();
    }
  };
  exports2.SocketMessageWriter = SocketMessageWriter;
  var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
      super(ril_1.default().stream.asReadableStream(readble), encoding);
    }
  };
  exports2.StreamMessageReader = StreamMessageReader;
  var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
      super(ril_1.default().stream.asWritableStream(writable), options);
    }
  };
  exports2.StreamMessageWriter = StreamMessageWriter;
  var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
  var safeIpcPathLengths = new Map([
    ["linux", 107],
    ["darwin", 103]
  ]);
  function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString("hex");
    if (process.platform === "win32") {
      return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
      result = path4.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    } else {
      result = path4.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== void 0 && result.length >= limit) {
      ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
  }
  exports2.generateRandomPipeName = generateRandomPipeName;
  function createClientPipeTransport(pipeName, encoding = "utf-8") {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      let server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new SocketMessageReader(socket, encoding),
          new SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(pipeName, () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientPipeTransport = createClientPipeTransport;
  function createServerPipeTransport(pipeName, encoding = "utf-8") {
    const socket = net_1.createConnection(pipeName);
    return [
      new SocketMessageReader(socket, encoding),
      new SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerPipeTransport = createServerPipeTransport;
  function createClientSocketTransport(port, encoding = "utf-8") {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      const server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new SocketMessageReader(socket, encoding),
          new SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(port, "127.0.0.1", () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientSocketTransport = createClientSocketTransport;
  function createServerSocketTransport(port, encoding = "utf-8") {
    const socket = net_1.createConnection(port, "127.0.0.1");
    return [
      new SocketMessageReader(socket, encoding),
      new SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerSocketTransport = createServerSocketTransport;
  function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== void 0 && candidate.addListener !== void 0;
  }
  function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== void 0 && candidate.addListener !== void 0;
  }
  function createMessageConnection(input, output, logger, options) {
    if (!logger) {
      logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
      options = {connectionStrategy: options};
    }
    return api_1.createMessageConnection(reader, writer, logger, options);
  }
  exports2.createMessageConnection = createMessageConnection;
});

// node_modules/@volar/shared/out/requests.js
var require_requests = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DetectDocumentNameCasesRequest = exports2.WriteVirtualFilesNotification = exports2.VerifyAllScriptsNotification = exports2.GetRefCompleteEditsRequest = exports2.GetTagCloseEditsRequest = exports2.D3Request = exports2.PingRequest = exports2.GetEditorSelectionRequest = exports2.GetDocumentPrintWidthRequest = exports2.GetDocumentNameCasesRequest = exports2.ShowReferencesNotification = exports2.GetDocumentVersionRequest = exports2.GetDocumentContentRequest = void 0;
  var rpc = require_main();
  var GetDocumentContentRequest;
  (function(GetDocumentContentRequest2) {
    GetDocumentContentRequest2.type = new rpc.RequestType("vscode/content");
  })(GetDocumentContentRequest = exports2.GetDocumentContentRequest || (exports2.GetDocumentContentRequest = {}));
  var GetDocumentVersionRequest2;
  (function(GetDocumentVersionRequest3) {
    GetDocumentVersionRequest3.type = new rpc.RequestType("vue/docUpdated");
  })(GetDocumentVersionRequest2 = exports2.GetDocumentVersionRequest || (exports2.GetDocumentVersionRequest = {}));
  var ShowReferencesNotification2;
  (function(ShowReferencesNotification3) {
    ShowReferencesNotification3.type = new rpc.NotificationType("vue.findReferences");
  })(ShowReferencesNotification2 = exports2.ShowReferencesNotification || (exports2.ShowReferencesNotification = {}));
  var GetDocumentNameCasesRequest;
  (function(GetDocumentNameCasesRequest2) {
    GetDocumentNameCasesRequest2.type = new rpc.RequestType("volar/getAttrNameCaseClient");
  })(GetDocumentNameCasesRequest = exports2.GetDocumentNameCasesRequest || (exports2.GetDocumentNameCasesRequest = {}));
  var GetDocumentPrintWidthRequest2;
  (function(GetDocumentPrintWidthRequest3) {
    GetDocumentPrintWidthRequest3.type = new rpc.RequestType("vue/getDocumentWordWrapColumn");
  })(GetDocumentPrintWidthRequest2 = exports2.GetDocumentPrintWidthRequest || (exports2.GetDocumentPrintWidthRequest = {}));
  var GetEditorSelectionRequest;
  (function(GetEditorSelectionRequest2) {
    GetEditorSelectionRequest2.type = new rpc.RequestType0("vue/activeSelection");
  })(GetEditorSelectionRequest = exports2.GetEditorSelectionRequest || (exports2.GetEditorSelectionRequest = {}));
  var PingRequest;
  (function(PingRequest2) {
    PingRequest2.type = new rpc.RequestType0("volar/ping");
  })(PingRequest = exports2.PingRequest || (exports2.PingRequest = {}));
  var D3Request;
  (function(D3Request2) {
    D3Request2.type = new rpc.RequestType("volar/d3");
  })(D3Request = exports2.D3Request || (exports2.D3Request = {}));
  var GetTagCloseEditsRequest2;
  (function(GetTagCloseEditsRequest3) {
    GetTagCloseEditsRequest3.type = new rpc.RequestType("html/tag");
  })(GetTagCloseEditsRequest2 = exports2.GetTagCloseEditsRequest || (exports2.GetTagCloseEditsRequest = {}));
  var GetRefCompleteEditsRequest2;
  (function(GetRefCompleteEditsRequest3) {
    GetRefCompleteEditsRequest3.type = new rpc.RequestType("volar/ref");
  })(GetRefCompleteEditsRequest2 = exports2.GetRefCompleteEditsRequest || (exports2.GetRefCompleteEditsRequest = {}));
  var VerifyAllScriptsNotification2;
  (function(VerifyAllScriptsNotification3) {
    VerifyAllScriptsNotification3.type = new rpc.NotificationType0("volar.action.verifyAllScripts");
  })(VerifyAllScriptsNotification2 = exports2.VerifyAllScriptsNotification || (exports2.VerifyAllScriptsNotification = {}));
  var WriteVirtualFilesNotification;
  (function(WriteVirtualFilesNotification2) {
    WriteVirtualFilesNotification2.type = new rpc.NotificationType("volar.action.writeVirtualFiles");
  })(WriteVirtualFilesNotification = exports2.WriteVirtualFilesNotification || (exports2.WriteVirtualFilesNotification = {}));
  var DetectDocumentNameCasesRequest;
  (function(DetectDocumentNameCasesRequest2) {
    DetectDocumentNameCasesRequest2.type = new rpc.RequestType("volar/getTagNameCaseServer");
  })(DetectDocumentNameCasesRequest = exports2.DetectDocumentNameCasesRequest || (exports2.DetectDocumentNameCasesRequest = {}));
});

// node_modules/@volar/shared/out/types.js
var require_types = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
});

// node_modules/@volar/shared/out/uriMap.js
var require_uriMap = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.FsPathSet = exports2.FsPathMap = exports2.UriSet = exports2.UriMap = void 0;
  var UriMap = class extends Map {
    delete(uri) {
      return super.delete(uri.toLowerCase());
    }
    get(uri) {
      return super.get(uri.toLowerCase());
    }
    has(uri) {
      return super.has(uri.toLowerCase());
    }
    set(uri, item) {
      return super.set(uri.toLowerCase(), item);
    }
  };
  exports2.UriMap = UriMap;
  var UriSet = class extends Set {
    delete(uri) {
      return super.delete(uri.toLowerCase());
    }
    has(uri) {
      return super.has(uri.toLowerCase());
    }
    add(uri) {
      return super.add(uri.toLowerCase());
    }
  };
  exports2.UriSet = UriSet;
  var FsPathMap = class extends UriMap {
  };
  exports2.FsPathMap = FsPathMap;
  var FsPathSet = class extends UriSet {
  };
  exports2.FsPathSet = FsPathSet;
});

// node_modules/@volar/shared/out/ts.js
var require_ts = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createParsedCommandLine = exports2.getTypeScriptVersion = exports2.loadTypescriptLocalized = exports2.loadTypescript = exports2.getVscodeTypescriptLocalizedPath = exports2.getVscodeTypescriptPath = exports2.findTypescriptLocalizedPathInLib = exports2.findTypescriptModulePathInLib = exports2.getWorkspaceTypescriptLocalizedPath = exports2.getWorkspaceTypescriptPath = exports2.createTsLanguageService = void 0;
  var fs4 = require("fs");
  var path4 = require_upath();
  var path_1 = require_path();
  function createTsLanguageService(ts, ShPlugin, _host) {
    var _a2, _b;
    const importSuggestionsCache = (_b = (_a2 = ts.Completions) === null || _a2 === void 0 ? void 0 : _a2.createImportSuggestionsForFileCache) === null || _b === void 0 ? void 0 : _b.call(_a2);
    const host = {
      ..._host,
      getImportSuggestionsCache: () => importSuggestionsCache
    };
    const shPlugin = ShPlugin({typescript: ts});
    let languageService = ts.createLanguageService(host);
    languageService = shPlugin.decorate(languageService);
    return languageService;
  }
  exports2.createTsLanguageService = createTsLanguageService;
  function getWorkspaceTypescriptPath2(tsdk, workspaceFolderFsPaths) {
    if (path4.isAbsolute(tsdk)) {
      const tsPath = findTypescriptModulePathInLib(tsdk);
      if (tsPath) {
        return tsPath;
      }
    } else {
      for (const folder of workspaceFolderFsPaths) {
        const tsPath = findTypescriptModulePathInLib(path4.join(folder, tsdk));
        if (tsPath) {
          return tsPath;
        }
      }
    }
  }
  exports2.getWorkspaceTypescriptPath = getWorkspaceTypescriptPath2;
  function getWorkspaceTypescriptLocalizedPath(tsdk, lang, workspaceFolderFsPaths) {
    if (path4.isAbsolute(tsdk)) {
      const tsPath = findTypescriptLocalizedPathInLib(tsdk, lang);
      if (tsPath) {
        return tsPath;
      }
    } else {
      for (const folder of workspaceFolderFsPaths) {
        const tsPath = findTypescriptLocalizedPathInLib(path4.join(folder, tsdk), lang);
        if (tsPath) {
          return tsPath;
        }
      }
    }
  }
  exports2.getWorkspaceTypescriptLocalizedPath = getWorkspaceTypescriptLocalizedPath;
  function findTypescriptModulePathInLib(lib) {
    const tsserverlibrary = path4.join(lib, "tsserverlibrary.js");
    const typescript = path4.join(lib, "typescript.js");
    const tsserver = path4.join(lib, "tsserver.js");
    if (fs4.existsSync(tsserverlibrary)) {
      return tsserverlibrary;
    }
    if (fs4.existsSync(typescript)) {
      return typescript;
    }
    if (fs4.existsSync(tsserver)) {
      return tsserver;
    }
  }
  exports2.findTypescriptModulePathInLib = findTypescriptModulePathInLib;
  function findTypescriptLocalizedPathInLib(lib, lang) {
    const localized = path4.join(lib, lang, "diagnosticMessages.generated.json");
    if (fs4.existsSync(localized)) {
      return localized;
    }
  }
  exports2.findTypescriptLocalizedPathInLib = findTypescriptLocalizedPathInLib;
  function getVscodeTypescriptPath(appRoot) {
    return path4.join(appRoot, "extensions", "node_modules", "typescript", "lib", "typescript.js");
  }
  exports2.getVscodeTypescriptPath = getVscodeTypescriptPath;
  function getVscodeTypescriptLocalizedPath(appRoot, lang) {
    const tsPath = path4.join(appRoot, "extensions", "node_modules", "typescript", "lib", lang, "diagnosticMessages.generated.json");
    if (fs4.existsSync(tsPath)) {
      return tsPath;
    }
  }
  exports2.getVscodeTypescriptLocalizedPath = getVscodeTypescriptLocalizedPath;
  function loadTypescript(tsPath) {
    return require(path4.toUnix(tsPath));
  }
  exports2.loadTypescript = loadTypescript;
  function loadTypescriptLocalized(tsPath) {
    if (fs4.existsSync(tsPath)) {
      return require(path4.toUnix(tsPath));
    }
  }
  exports2.loadTypescriptLocalized = loadTypescriptLocalized;
  function getTypeScriptVersion(serverPath) {
    if (!fs4.existsSync(serverPath)) {
      return void 0;
    }
    const p = serverPath.split(path4.sep);
    if (p.length <= 2) {
      return void 0;
    }
    const p2 = p.slice(0, -2);
    const modulePath = p2.join(path4.sep);
    let fileName = path4.join(modulePath, "package.json");
    if (!fs4.existsSync(fileName)) {
      if (path4.basename(modulePath) === "built") {
        fileName = path4.join(modulePath, "..", "package.json");
      }
    }
    if (!fs4.existsSync(fileName)) {
      return void 0;
    }
    const contents = fs4.readFileSync(fileName).toString();
    let desc = null;
    try {
      desc = JSON.parse(contents);
    } catch (err) {
      return void 0;
    }
    if (!desc || !desc.version) {
      return void 0;
    }
    return desc.version;
  }
  exports2.getTypeScriptVersion = getTypeScriptVersion;
  function createParsedCommandLine(ts, parseConfigHost, tsConfig) {
    const realTsConfig = ts.sys.realpath(tsConfig);
    const config = ts.readJsonConfigFile(realTsConfig, ts.sys.readFile);
    const content = ts.parseJsonSourceFileConfigFileContent(config, parseConfigHost, path4.dirname(realTsConfig), {}, path4.basename(realTsConfig));
    content.options.outDir = void 0;
    content.fileNames = content.fileNames.map(path_1.normalizeFileName);
    return content;
  }
  exports2.createParsedCommandLine = createParsedCommandLine;
});

// node_modules/@volar/shared/out/http.js
var require_http = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getAvaliablePort = exports2.isAvailablePort = void 0;
  var http = require("http");
  function isAvailablePort(port) {
    return new Promise((resolve) => {
      const server = http.createServer().listen(port, () => {
        server.close();
        resolve(true);
      }).on("error", () => {
        resolve(false);
      });
    });
  }
  exports2.isAvailablePort = isAvailablePort;
  async function getAvaliablePort(port) {
    if (!await isAvailablePort(port)) {
      port++;
    }
    return port;
  }
  exports2.getAvaliablePort = getAvaliablePort;
});

// node_modules/@volar/shared/out/index.js
var require_out = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.eqSet = exports2.getWordRange = exports2.isInsideRange = exports2.notEmpty = exports2.getValidScriptSyntax = exports2.languageIdToSyntax = exports2.syntaxToLanguageId = exports2.sleep = void 0;
  __exportStar2(require_path(), exports2);
  __exportStar2(require_requests(), exports2);
  __exportStar2(require_types(), exports2);
  __exportStar2(require_uriMap(), exports2);
  __exportStar2(require_ts(), exports2);
  __exportStar2(require_http(), exports2);
  var util_1 = require("util");
  var validScriptSyntaxs = new Set(["js", "jsx", "ts", "tsx"]);
  exports2.sleep = util_1.promisify(setTimeout);
  function syntaxToLanguageId(syntax) {
    switch (syntax) {
      case "js":
        return "javascript";
      case "ts":
        return "typescript";
      case "jsx":
        return "javascriptreact";
      case "tsx":
        return "typescriptreact";
      case "pug":
        return "jade";
    }
    return syntax;
  }
  exports2.syntaxToLanguageId = syntaxToLanguageId;
  function languageIdToSyntax(languageId) {
    switch (languageId) {
      case "javascript":
        return "js";
      case "typescript":
        return "ts";
      case "javascriptreact":
        return "jsx";
      case "typescriptreact":
        return "tsx";
      case "jade":
        return "pug";
    }
    return languageId;
  }
  exports2.languageIdToSyntax = languageIdToSyntax;
  function getValidScriptSyntax(syntax) {
    if (validScriptSyntaxs.has(syntax)) {
      return syntax;
    }
    return "js";
  }
  exports2.getValidScriptSyntax = getValidScriptSyntax;
  function notEmpty2(value) {
    return value !== null && value !== void 0;
  }
  exports2.notEmpty = notEmpty2;
  function isInsideRange(parent, child) {
    if (child.start.line < parent.start.line)
      return false;
    if (child.end.line > parent.end.line)
      return false;
    if (child.start.line === parent.start.line && child.start.character < parent.start.character)
      return false;
    if (child.end.line === parent.end.line && child.end.character > parent.end.character)
      return false;
    return true;
  }
  exports2.isInsideRange = isInsideRange;
  function getWordRange(wordPattern, position, document2) {
    const lineStart = {
      line: position.line,
      character: 0
    };
    const lineEnd = {
      line: position.line + 1,
      character: 0
    };
    const offset = document2.offsetAt(position);
    const lineStartOffset = document2.offsetAt(lineStart);
    const lineText = document2.getText({start: lineStart, end: lineEnd});
    for (const match of lineText.matchAll(wordPattern)) {
      if (match.index === void 0)
        continue;
      const matchStart = match.index + lineStartOffset;
      const matchEnd = matchStart + match[0].length;
      if (offset >= matchStart && offset <= matchEnd) {
        return {
          start: document2.positionAt(matchStart),
          end: document2.positionAt(matchEnd)
        };
      }
    }
    return void 0;
  }
  exports2.getWordRange = getWordRange;
  function eqSet(as, bs) {
    if (as.size !== bs.size)
      return false;
    for (const a of as)
      if (!bs.has(a))
        return false;
    return true;
  }
  exports2.eqSet = eqSet;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var _ral;
  function RAL() {
    if (_ral === void 0) {
      throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
  }
  (function(RAL2) {
    function install(ral) {
      if (ral === void 0) {
        throw new Error(`No runtime abstraction layer provided`);
      }
      _ral = ral;
    }
    RAL2.install = install;
  })(RAL || (RAL = {}));
  exports2.default = RAL;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Disposable = void 0;
  var Disposable3;
  (function(Disposable4) {
    function create(func) {
      return {
        dispose: func
      };
    }
    Disposable4.create = create;
  })(Disposable3 = exports2.Disposable || (exports2.Disposable = {}));
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.AbstractMessageBuffer = void 0;
  var CR = 13;
  var LF = 10;
  var CRLF = "\r\n";
  var AbstractMessageBuffer = class {
    constructor(encoding = "utf-8") {
      this._encoding = encoding;
      this._chunks = [];
      this._totalLength = 0;
    }
    get encoding() {
      return this._encoding;
    }
    append(chunk) {
      const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
      this._chunks.push(toAppend);
      this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
      if (this._chunks.length === 0) {
        return void 0;
      }
      let state = 0;
      let chunkIndex = 0;
      let offset = 0;
      let chunkBytesRead = 0;
      row:
        while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column:
            while (offset < chunk.length) {
              const value = chunk[offset];
              switch (value) {
                case CR:
                  switch (state) {
                    case 0:
                      state = 1;
                      break;
                    case 2:
                      state = 3;
                      break;
                    default:
                      state = 0;
                  }
                  break;
                case LF:
                  switch (state) {
                    case 1:
                      state = 2;
                      break;
                    case 3:
                      state = 4;
                      offset++;
                      break row;
                    default:
                      state = 0;
                  }
                  break;
                default:
                  state = 0;
              }
              offset++;
            }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
      if (state !== 4) {
        return void 0;
      }
      const buffer = this._read(chunkBytesRead + offset);
      const result = new Map();
      const headers = this.toString(buffer, "ascii").split(CRLF);
      if (headers.length < 2) {
        return result;
      }
      for (let i = 0; i < headers.length - 2; i++) {
        const header = headers[i];
        const index = header.indexOf(":");
        if (index === -1) {
          throw new Error("Message header must separate key and value using :");
        }
        const key = header.substr(0, index);
        const value = header.substr(index + 1).trim();
        result.set(key, value);
      }
      return result;
    }
    tryReadBody(length) {
      if (this._totalLength < length) {
        return void 0;
      }
      return this._read(length);
    }
    get numberOfBytes() {
      return this._totalLength;
    }
    _read(byteCount) {
      if (byteCount === 0) {
        return this.emptyBuffer();
      }
      if (byteCount > this._totalLength) {
        throw new Error(`Cannot read so many bytes!`);
      }
      if (this._chunks[0].byteLength === byteCount) {
        const chunk = this._chunks[0];
        this._chunks.shift();
        this._totalLength -= byteCount;
        return this.asNative(chunk);
      }
      if (this._chunks[0].byteLength > byteCount) {
        const chunk = this._chunks[0];
        const result2 = this.asNative(chunk, byteCount);
        this._chunks[0] = chunk.slice(byteCount);
        this._totalLength -= byteCount;
        return result2;
      }
      const result = this.allocNative(byteCount);
      let resultOffset = 0;
      let chunkIndex = 0;
      while (byteCount > 0) {
        const chunk = this._chunks[chunkIndex];
        if (chunk.byteLength > byteCount) {
          const chunkPart = chunk.slice(0, byteCount);
          result.set(chunkPart, resultOffset);
          resultOffset += byteCount;
          this._chunks[chunkIndex] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          byteCount -= byteCount;
        } else {
          result.set(chunk, resultOffset);
          resultOffset += chunk.byteLength;
          this._chunks.shift();
          this._totalLength -= chunk.byteLength;
          byteCount -= chunk.byteLength;
        }
      }
      return result;
    }
  };
  exports2.AbstractMessageBuffer = AbstractMessageBuffer;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var ral_1 = require_ral2();
  var util_1 = require("util");
  var disposable_1 = require_disposable2();
  var messageBuffer_1 = require_messageBuffer2();
  var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = "utf-8") {
      super(encoding);
    }
    emptyBuffer() {
      return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
      return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
      if (value instanceof Buffer) {
        return value.toString(encoding);
      } else {
        return new util_1.TextDecoder(encoding).decode(value);
      }
    }
    asNative(buffer, length) {
      if (length === void 0) {
        return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
      } else {
        return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
      }
    }
    allocNative(length) {
      return Buffer.allocUnsafe(length);
    }
  };
  MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
  var ReadableStreamWrapper = class {
    constructor(stream) {
      this.stream = stream;
    }
    onClose(listener) {
      this.stream.on("close", listener);
      return disposable_1.Disposable.create(() => this.stream.off("close", listener));
    }
    onError(listener) {
      this.stream.on("error", listener);
      return disposable_1.Disposable.create(() => this.stream.off("error", listener));
    }
    onEnd(listener) {
      this.stream.on("end", listener);
      return disposable_1.Disposable.create(() => this.stream.off("end", listener));
    }
    onData(listener) {
      this.stream.on("data", listener);
      return disposable_1.Disposable.create(() => this.stream.off("data", listener));
    }
  };
  var WritableStreamWrapper = class {
    constructor(stream) {
      this.stream = stream;
    }
    onClose(listener) {
      this.stream.on("close", listener);
      return disposable_1.Disposable.create(() => this.stream.off("close", listener));
    }
    onError(listener) {
      this.stream.on("error", listener);
      return disposable_1.Disposable.create(() => this.stream.off("error", listener));
    }
    onEnd(listener) {
      this.stream.on("end", listener);
      return disposable_1.Disposable.create(() => this.stream.off("end", listener));
    }
    write(data, encoding) {
      return new Promise((resolve, reject) => {
        const callback = (error) => {
          if (error === void 0 || error === null) {
            resolve();
          } else {
            reject(error);
          }
        };
        if (typeof data === "string") {
          this.stream.write(data, encoding, callback);
        } else {
          this.stream.write(data, callback);
        }
      });
    }
    end() {
      this.stream.end();
    }
  };
  var _ril = Object.freeze({
    messageBuffer: Object.freeze({
      create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
      encoder: Object.freeze({
        name: "application/json",
        encode: (msg, options) => {
          try {
            return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
          } catch (err) {
            return Promise.reject(err);
          }
        }
      }),
      decoder: Object.freeze({
        name: "application/json",
        decode: (buffer, options) => {
          try {
            if (buffer instanceof Buffer) {
              return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
            } else {
              return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
            }
          } catch (err) {
            return Promise.reject(err);
          }
        }
      })
    }),
    stream: Object.freeze({
      asReadableStream: (stream) => new ReadableStreamWrapper(stream),
      asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console,
    timer: Object.freeze({
      setTimeout(callback, ms, ...args) {
        const handle = setTimeout(callback, ms, ...args);
        return {dispose: () => clearTimeout(handle)};
      },
      setImmediate(callback, ...args) {
        const handle = setImmediate(callback, ...args);
        return {dispose: () => clearImmediate(handle)};
      },
      setInterval(callback, ms, ...args) {
        const handle = setInterval(callback, ms, ...args);
        return {dispose: () => clearInterval(handle)};
      }
    })
  });
  function RIL() {
    return _ril;
  }
  (function(RIL2) {
    function install() {
      ral_1.default.install(_ril);
    }
    RIL2.install = install;
  })(RIL || (RIL = {}));
  exports2.default = RIL;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
  function boolean(value) {
    return value === true || value === false;
  }
  exports2.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports2.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports2.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports2.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports2.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports2.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string(elem));
  }
  exports2.stringArray = stringArray;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isResponseMessage = exports2.isNotificationMessage = exports2.isRequestMessage = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
  var is = require_is2();
  var ErrorCodes;
  (function(ErrorCodes2) {
    ErrorCodes2.ParseError = -32700;
    ErrorCodes2.InvalidRequest = -32600;
    ErrorCodes2.MethodNotFound = -32601;
    ErrorCodes2.InvalidParams = -32602;
    ErrorCodes2.InternalError = -32603;
    ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
    ErrorCodes2.serverErrorStart = ErrorCodes2.jsonrpcReservedErrorRangeStart;
    ErrorCodes2.MessageWriteError = -32099;
    ErrorCodes2.MessageReadError = -32098;
    ErrorCodes2.ServerNotInitialized = -32002;
    ErrorCodes2.UnknownErrorCode = -32001;
    ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
    ErrorCodes2.serverErrorEnd = ErrorCodes2.jsonrpcReservedErrorRangeEnd;
  })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
  var ResponseError = class extends Error {
    constructor(code, message, data) {
      super(message);
      this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
      this.data = data;
      Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
      const result = {
        code: this.code,
        message: this.message
      };
      if (this.data !== void 0) {
        result.data = this.data;
      }
      return result;
    }
  };
  exports2.ResponseError = ResponseError;
  var ParameterStructures = class {
    constructor(kind) {
      this.kind = kind;
    }
    static is(value) {
      return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
      return this.kind;
    }
  };
  exports2.ParameterStructures = ParameterStructures;
  ParameterStructures.auto = new ParameterStructures("auto");
  ParameterStructures.byPosition = new ParameterStructures("byPosition");
  ParameterStructures.byName = new ParameterStructures("byName");
  var AbstractMessageSignature = class {
    constructor(method, numberOfParams) {
      this.method = method;
      this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
      return ParameterStructures.auto;
    }
  };
  exports2.AbstractMessageSignature = AbstractMessageSignature;
  var RequestType0 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.RequestType0 = RequestType0;
  var RequestType2 = class extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  };
  exports2.RequestType = RequestType2;
  var RequestType1 = class extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  };
  exports2.RequestType1 = RequestType1;
  var RequestType22 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.RequestType2 = RequestType22;
  var RequestType3 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.RequestType3 = RequestType3;
  var RequestType4 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.RequestType4 = RequestType4;
  var RequestType5 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.RequestType5 = RequestType5;
  var RequestType6 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.RequestType6 = RequestType6;
  var RequestType7 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.RequestType7 = RequestType7;
  var RequestType8 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.RequestType8 = RequestType8;
  var RequestType9 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.RequestType9 = RequestType9;
  var NotificationType2 = class extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  };
  exports2.NotificationType = NotificationType2;
  var NotificationType02 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.NotificationType0 = NotificationType02;
  var NotificationType1 = class extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  };
  exports2.NotificationType1 = NotificationType1;
  var NotificationType22 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.NotificationType2 = NotificationType22;
  var NotificationType3 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.NotificationType3 = NotificationType3;
  var NotificationType4 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.NotificationType4 = NotificationType4;
  var NotificationType5 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.NotificationType5 = NotificationType5;
  var NotificationType6 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.NotificationType6 = NotificationType6;
  var NotificationType7 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.NotificationType7 = NotificationType7;
  var NotificationType8 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.NotificationType8 = NotificationType8;
  var NotificationType9 = class extends AbstractMessageSignature {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.NotificationType9 = NotificationType9;
  function isRequestMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
  }
  exports2.isRequestMessage = isRequestMessage;
  function isNotificationMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
  }
  exports2.isNotificationMessage = isNotificationMessage;
  function isResponseMessage(message) {
    const candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
  }
  exports2.isResponseMessage = isResponseMessage;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap2 = __commonJS((exports2) => {
  "use strict";
  var _a2;
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
  var Touch;
  (function(Touch2) {
    Touch2.None = 0;
    Touch2.First = 1;
    Touch2.AsOld = Touch2.First;
    Touch2.Last = 2;
    Touch2.AsNew = Touch2.Last;
  })(Touch = exports2.Touch || (exports2.Touch = {}));
  var LinkedMap = class {
    constructor() {
      this[_a2] = "LinkedMap";
      this._map = new Map();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state = 0;
    }
    clear() {
      this._map.clear();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      var _b;
      return (_b = this._head) === null || _b === void 0 ? void 0 : _b.value;
    }
    get last() {
      var _b;
      return (_b = this._tail) === null || _b === void 0 ? void 0 : _b.value;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key, touch = Touch.None) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      if (touch !== Touch.None) {
        this.touch(item, touch);
      }
      return item.value;
    }
    set(key, value, touch = Touch.None) {
      let item = this._map.get(key);
      if (item) {
        item.value = value;
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
      } else {
        item = {key, value, next: void 0, previous: void 0};
        switch (touch) {
          case Touch.None:
            this.addItemLast(item);
            break;
          case Touch.First:
            this.addItemFirst(item);
            break;
          case Touch.Last:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
      return this;
    }
    delete(key) {
      return !!this.remove(key);
    }
    remove(key) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    shift() {
      if (!this._head && !this._tail) {
        return void 0;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      const state = this._state;
      let current = this._head;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        if (this._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        current = current.next;
      }
    }
    keys() {
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]: () => {
          return iterator;
        },
        next: () => {
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = {value: current.key, done: false};
            current = current.next;
            return result;
          } else {
            return {value: void 0, done: true};
          }
        }
      };
      return iterator;
    }
    values() {
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]: () => {
          return iterator;
        },
        next: () => {
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = {value: current.value, done: false};
            current = current.next;
            return result;
          } else {
            return {value: void 0, done: true};
          }
        }
      };
      return iterator;
    }
    entries() {
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]: () => {
          return iterator;
        },
        next: () => {
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = {value: [current.key, current.value], done: false};
            current = current.next;
            return result;
          } else {
            return {value: void 0, done: true};
          }
        }
      };
      return iterator;
    }
    [(_a2 = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._head;
      let currentSize = this.size;
      while (current && currentSize > newSize) {
        this._map.delete(current.key);
        current = current.next;
        currentSize--;
      }
      this._head = current;
      this._size = currentSize;
      if (current) {
        current.previous = void 0;
      }
      this._state++;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
      this._state++;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
      this._state++;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = void 0;
        this._tail = void 0;
      } else if (item === this._head) {
        if (!item.next) {
          throw new Error("Invalid list");
        }
        item.next.previous = void 0;
        this._head = item.next;
      } else if (item === this._tail) {
        if (!item.previous) {
          throw new Error("Invalid list");
        }
        item.previous.next = void 0;
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous = item.previous;
        if (!next || !previous) {
          throw new Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = void 0;
      this._state++;
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== Touch.First && touch !== Touch.Last) {
        return;
      }
      if (touch === Touch.First) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._tail) {
          previous.next = void 0;
          this._tail = previous;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.previous = void 0;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
        this._state++;
      } else if (touch === Touch.Last) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._head) {
          next.previous = void 0;
          this._head = next;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
        this._state++;
      }
    }
    toJSON() {
      const data = [];
      this.forEach((value, key) => {
        data.push([key, value]);
      });
      return data;
    }
    fromJSON(data) {
      this.clear();
      for (const [key, value] of data) {
        this.set(key, value);
      }
    }
  };
  exports2.LinkedMap = LinkedMap;
  var LRUCache = class extends LinkedMap {
    constructor(limit, ratio = 1) {
      super();
      this._limit = limit;
      this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(limit) {
      this._limit = limit;
      this.checkTrim();
    }
    get ratio() {
      return this._ratio;
    }
    set ratio(ratio) {
      this._ratio = Math.min(Math.max(0, ratio), 1);
      this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
      return super.get(key, touch);
    }
    peek(key) {
      return super.get(key, Touch.None);
    }
    set(key, value) {
      super.set(key, value, Touch.Last);
      this.checkTrim();
      return this;
    }
    checkTrim() {
      if (this.size > this._limit) {
        this.trimOld(Math.round(this._limit * this._ratio));
      }
    }
  };
  exports2.LRUCache = LRUCache;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Emitter = exports2.Event = void 0;
  var ral_1 = require_ral2();
  var Event;
  (function(Event2) {
    const _disposable = {dispose() {
    }};
    Event2.None = function() {
      return _disposable;
    };
  })(Event = exports2.Event || (exports2.Event = {}));
  var CallbackList = class {
    add(callback, context = null, bucket) {
      if (!this._callbacks) {
        this._callbacks = [];
        this._contexts = [];
      }
      this._callbacks.push(callback);
      this._contexts.push(context);
      if (Array.isArray(bucket)) {
        bucket.push({dispose: () => this.remove(callback, context)});
      }
    }
    remove(callback, context = null) {
      if (!this._callbacks) {
        return;
      }
      let foundCallbackWithDifferentContext = false;
      for (let i = 0, len = this._callbacks.length; i < len; i++) {
        if (this._callbacks[i] === callback) {
          if (this._contexts[i] === context) {
            this._callbacks.splice(i, 1);
            this._contexts.splice(i, 1);
            return;
          } else {
            foundCallbackWithDifferentContext = true;
          }
        }
      }
      if (foundCallbackWithDifferentContext) {
        throw new Error("When adding a listener with a context, you should remove it with the same context");
      }
    }
    invoke(...args) {
      if (!this._callbacks) {
        return [];
      }
      const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
      for (let i = 0, len = callbacks.length; i < len; i++) {
        try {
          ret.push(callbacks[i].apply(contexts[i], args));
        } catch (e) {
          ral_1.default().console.error(e);
        }
      }
      return ret;
    }
    isEmpty() {
      return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
      this._callbacks = void 0;
      this._contexts = void 0;
    }
  };
  var Emitter = class {
    constructor(_options) {
      this._options = _options;
    }
    get event() {
      if (!this._event) {
        this._event = (listener, thisArgs, disposables) => {
          if (!this._callbacks) {
            this._callbacks = new CallbackList();
          }
          if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
            this._options.onFirstListenerAdd(this);
          }
          this._callbacks.add(listener, thisArgs);
          const result = {
            dispose: () => {
              if (!this._callbacks) {
                return;
              }
              this._callbacks.remove(listener, thisArgs);
              result.dispose = Emitter._noop;
              if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                this._options.onLastListenerRemove(this);
              }
            }
          };
          if (Array.isArray(disposables)) {
            disposables.push(result);
          }
          return result;
        };
      }
      return this._event;
    }
    fire(event) {
      if (this._callbacks) {
        this._callbacks.invoke.call(this._callbacks, event);
      }
    }
    dispose() {
      if (this._callbacks) {
        this._callbacks.dispose();
        this._callbacks = void 0;
      }
    }
  };
  exports2.Emitter = Emitter;
  Emitter._noop = function() {
  };
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
  var ral_1 = require_ral2();
  var Is = require_is2();
  var events_1 = require_events2();
  var CancellationToken;
  (function(CancellationToken2) {
    CancellationToken2.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: events_1.Event.None
    });
    CancellationToken2.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: events_1.Event.None
    });
    function is(value) {
      const candidate = value;
      return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
    }
    CancellationToken2.is = is;
  })(CancellationToken = exports2.CancellationToken || (exports2.CancellationToken = {}));
  var shortcutEvent = Object.freeze(function(callback, context) {
    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
    return {dispose() {
      handle.dispose();
    }};
  });
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new events_1.Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = void 0;
      }
    }
  };
  var CancellationTokenSource = class {
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken.Cancelled;
      } else {
        this._token.cancel();
      }
    }
    dispose() {
      if (!this._token) {
        this._token = CancellationToken.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };
  exports2.CancellationTokenSource = CancellationTokenSource;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
  var ral_1 = require_ral2();
  var Is = require_is2();
  var events_1 = require_events2();
  var MessageReader;
  (function(MessageReader2) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader2.is = is;
  })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
  var AbstractMessageReader = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
      this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error) {
      this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    get onPartialMessage() {
      return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
      this.partialMessageEmitter.fire(info);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageReader = AbstractMessageReader;
  var ResolvedMessageReaderOptions;
  (function(ResolvedMessageReaderOptions2) {
    function fromOptions(options) {
      var _a2;
      let charset;
      let result;
      let contentDecoder;
      const contentDecoders = new Map();
      let contentTypeDecoder;
      const contentTypeDecoders = new Map();
      if (options === void 0 || typeof options === "string") {
        charset = options !== null && options !== void 0 ? options : "utf-8";
      } else {
        charset = (_a2 = options.charset) !== null && _a2 !== void 0 ? _a2 : "utf-8";
        if (options.contentDecoder !== void 0) {
          contentDecoder = options.contentDecoder;
          contentDecoders.set(contentDecoder.name, contentDecoder);
        }
        if (options.contentDecoders !== void 0) {
          for (const decoder of options.contentDecoders) {
            contentDecoders.set(decoder.name, decoder);
          }
        }
        if (options.contentTypeDecoder !== void 0) {
          contentTypeDecoder = options.contentTypeDecoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        if (options.contentTypeDecoders !== void 0) {
          for (const decoder of options.contentTypeDecoders) {
            contentTypeDecoders.set(decoder.name, decoder);
          }
        }
      }
      if (contentTypeDecoder === void 0) {
        contentTypeDecoder = ral_1.default().applicationJson.decoder;
        contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
      }
      return {charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders};
    }
    ResolvedMessageReaderOptions2.fromOptions = fromOptions;
  })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
  var ReadableStreamMessageReader = class extends AbstractMessageReader {
    constructor(readable, options) {
      super();
      this.readable = readable;
      this.options = ResolvedMessageReaderOptions.fromOptions(options);
      this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
      this._partialMessageTimeout = 1e4;
      this.nextMessageLength = -1;
      this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
      this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
      return this._partialMessageTimeout;
    }
    listen(callback) {
      this.nextMessageLength = -1;
      this.messageToken = 0;
      this.partialMessageTimer = void 0;
      this.callback = callback;
      const result = this.readable.onData((data) => {
        this.onData(data);
      });
      this.readable.onError((error) => this.fireError(error));
      this.readable.onClose(() => this.fireClose());
      return result;
    }
    onData(data) {
      this.buffer.append(data);
      while (true) {
        if (this.nextMessageLength === -1) {
          const headers = this.buffer.tryReadHeaders();
          if (!headers) {
            return;
          }
          const contentLength = headers.get("Content-Length");
          if (!contentLength) {
            throw new Error("Header must provide a Content-Length property.");
          }
          const length = parseInt(contentLength);
          if (isNaN(length)) {
            throw new Error("Content-Length value must be a number.");
          }
          this.nextMessageLength = length;
        }
        const body = this.buffer.tryReadBody(this.nextMessageLength);
        if (body === void 0) {
          this.setPartialMessageTimer();
          return;
        }
        this.clearPartialMessageTimer();
        this.nextMessageLength = -1;
        let p;
        if (this.options.contentDecoder !== void 0) {
          p = this.options.contentDecoder.decode(body);
        } else {
          p = Promise.resolve(body);
        }
        p.then((value) => {
          this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
            this.callback(msg);
          }, (error) => {
            this.fireError(error);
          });
        }, (error) => {
          this.fireError(error);
        });
      }
    }
    clearPartialMessageTimer() {
      if (this.partialMessageTimer) {
        this.partialMessageTimer.dispose();
        this.partialMessageTimer = void 0;
      }
    }
    setPartialMessageTimer() {
      this.clearPartialMessageTimer();
      if (this._partialMessageTimeout <= 0) {
        return;
      }
      this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
        this.partialMessageTimer = void 0;
        if (token === this.messageToken) {
          this.firePartialMessage({messageToken: token, waitingTime: timeout});
          this.setPartialMessageTimer();
        }
      }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
  };
  exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Semaphore = void 0;
  var ral_1 = require_ral2();
  var Semaphore = class {
    constructor(capacity = 1) {
      if (capacity <= 0) {
        throw new Error("Capacity must be greater than 0");
      }
      this._capacity = capacity;
      this._active = 0;
      this._waiting = [];
    }
    lock(thunk) {
      return new Promise((resolve, reject) => {
        this._waiting.push({thunk, resolve, reject});
        this.runNext();
      });
    }
    get active() {
      return this._active;
    }
    runNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      ral_1.default().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      const next = this._waiting.shift();
      this._active++;
      if (this._active > this._capacity) {
        throw new Error(`To many thunks active`);
      }
      try {
        const result = next.thunk();
        if (result instanceof Promise) {
          result.then((value) => {
            this._active--;
            next.resolve(value);
            this.runNext();
          }, (err) => {
            this._active--;
            next.reject(err);
            this.runNext();
          });
        } else {
          this._active--;
          next.resolve(result);
          this.runNext();
        }
      } catch (err) {
        this._active--;
        next.reject(err);
        this.runNext();
      }
    }
  };
  exports2.Semaphore = Semaphore;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
  var ral_1 = require_ral2();
  var Is = require_is2();
  var semaphore_1 = require_semaphore2();
  var events_1 = require_events2();
  var ContentLength = "Content-Length: ";
  var CRLF = "\r\n";
  var MessageWriter;
  (function(MessageWriter2) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter2.is = is;
  })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
  var AbstractMessageWriter = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error, message, count) {
      this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageWriter = AbstractMessageWriter;
  var ResolvedMessageWriterOptions;
  (function(ResolvedMessageWriterOptions2) {
    function fromOptions(options) {
      var _a2, _b;
      if (options === void 0 || typeof options === "string") {
        return {charset: options !== null && options !== void 0 ? options : "utf-8", contentTypeEncoder: ral_1.default().applicationJson.encoder};
      } else {
        return {charset: (_a2 = options.charset) !== null && _a2 !== void 0 ? _a2 : "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder};
      }
    }
    ResolvedMessageWriterOptions2.fromOptions = fromOptions;
  })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
  var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
    constructor(writable, options) {
      super();
      this.writable = writable;
      this.options = ResolvedMessageWriterOptions.fromOptions(options);
      this.errorCount = 0;
      this.writeSemaphore = new semaphore_1.Semaphore(1);
      this.writable.onError((error) => this.fireError(error));
      this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
      return this.writeSemaphore.lock(async () => {
        const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
          if (this.options.contentEncoder !== void 0) {
            return this.options.contentEncoder.encode(buffer);
          } else {
            return buffer;
          }
        });
        return payload.then((buffer) => {
          const headers = [];
          headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
          headers.push(CRLF);
          return this.doWrite(msg, headers, buffer);
        }, (error) => {
          this.fireError(error);
          throw error;
        });
      });
    }
    async doWrite(msg, headers, data) {
      try {
        await this.writable.write(headers.join(""), "ascii");
        return this.writable.write(data);
      } catch (error) {
        this.handleError(error, msg);
        return Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
    end() {
      this.writable.end();
    }
  };
  exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.NullLogger = exports2.ProgressType = void 0;
  var ral_1 = require_ral2();
  var Is = require_is2();
  var messages_1 = require_messages2();
  var linkedMap_1 = require_linkedMap2();
  var events_1 = require_events2();
  var cancellation_1 = require_cancellation2();
  var CancelNotification;
  (function(CancelNotification2) {
    CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
  })(CancelNotification || (CancelNotification = {}));
  var ProgressNotification;
  (function(ProgressNotification2) {
    ProgressNotification2.type = new messages_1.NotificationType("$/progress");
  })(ProgressNotification || (ProgressNotification = {}));
  var ProgressType = class {
    constructor() {
    }
  };
  exports2.ProgressType = ProgressType;
  var StarRequestHandler;
  (function(StarRequestHandler2) {
    function is(value) {
      return Is.func(value);
    }
    StarRequestHandler2.is = is;
  })(StarRequestHandler || (StarRequestHandler = {}));
  exports2.NullLogger = Object.freeze({
    error: () => {
    },
    warn: () => {
    },
    info: () => {
    },
    log: () => {
    }
  });
  var Trace;
  (function(Trace2) {
    Trace2[Trace2["Off"] = 0] = "Off";
    Trace2[Trace2["Messages"] = 1] = "Messages";
    Trace2[Trace2["Verbose"] = 2] = "Verbose";
  })(Trace = exports2.Trace || (exports2.Trace = {}));
  (function(Trace2) {
    function fromString(value) {
      if (!Is.string(value)) {
        return Trace2.Off;
      }
      value = value.toLowerCase();
      switch (value) {
        case "off":
          return Trace2.Off;
        case "messages":
          return Trace2.Messages;
        case "verbose":
          return Trace2.Verbose;
        default:
          return Trace2.Off;
      }
    }
    Trace2.fromString = fromString;
    function toString(value) {
      switch (value) {
        case Trace2.Off:
          return "off";
        case Trace2.Messages:
          return "messages";
        case Trace2.Verbose:
          return "verbose";
        default:
          return "off";
      }
    }
    Trace2.toString = toString;
  })(Trace = exports2.Trace || (exports2.Trace = {}));
  var TraceFormat;
  (function(TraceFormat2) {
    TraceFormat2["Text"] = "text";
    TraceFormat2["JSON"] = "json";
  })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
  (function(TraceFormat2) {
    function fromString(value) {
      if (!Is.string(value)) {
        return TraceFormat2.Text;
      }
      value = value.toLowerCase();
      if (value === "json") {
        return TraceFormat2.JSON;
      } else {
        return TraceFormat2.Text;
      }
    }
    TraceFormat2.fromString = fromString;
  })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
  var SetTraceNotification;
  (function(SetTraceNotification2) {
    SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
  })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
  var LogTraceNotification;
  (function(LogTraceNotification2) {
    LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
  })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
  var ConnectionErrors;
  (function(ConnectionErrors2) {
    ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
    ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
    ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
  })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
  var ConnectionError = class extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
      Object.setPrototypeOf(this, ConnectionError.prototype);
    }
  };
  exports2.ConnectionError = ConnectionError;
  var ConnectionStrategy;
  (function(ConnectionStrategy2) {
    function is(value) {
      const candidate = value;
      return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy2.is = is;
  })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
  var CancellationReceiverStrategy;
  (function(CancellationReceiverStrategy2) {
    CancellationReceiverStrategy2.Message = Object.freeze({
      createCancellationTokenSource(_) {
        return new cancellation_1.CancellationTokenSource();
      }
    });
    function is(value) {
      const candidate = value;
      return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy2.is = is;
  })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
  var CancellationSenderStrategy;
  (function(CancellationSenderStrategy2) {
    CancellationSenderStrategy2.Message = Object.freeze({
      sendCancellation(conn, id) {
        return conn.sendNotification(CancelNotification.type, {id});
      },
      cleanup(_) {
      }
    });
    function is(value) {
      const candidate = value;
      return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy2.is = is;
  })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
  var CancellationStrategy;
  (function(CancellationStrategy2) {
    CancellationStrategy2.Message = Object.freeze({
      receiver: CancellationReceiverStrategy.Message,
      sender: CancellationSenderStrategy.Message
    });
    function is(value) {
      const candidate = value;
      return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy2.is = is;
  })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
  var ConnectionOptions;
  (function(ConnectionOptions2) {
    function is(value) {
      const candidate = value;
      return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions2.is = is;
  })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2[ConnectionState2["New"] = 1] = "New";
    ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
    ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
    ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
  })(ConnectionState || (ConnectionState = {}));
  function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = "2.0";
    let starRequestHandler = void 0;
    const requestHandlers = Object.create(null);
    let starNotificationHandler = void 0;
    const notificationHandlers = Object.create(null);
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let knownCanceledRequests = new Set();
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
      if (id === null) {
        throw new Error(`Can't send requests with id null since the response can't be correlated.`);
      }
      return "req-" + id.toString();
    }
    function createResponseQueueKey(id) {
      if (id === null) {
        return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
      } else {
        return "res-" + id.toString();
      }
    }
    function createNotificationQueueKey() {
      return "not-" + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
      if (messages_1.isRequestMessage(message)) {
        queue.set(createRequestQueueKey(message.id), message);
      } else if (messages_1.isResponseMessage(message)) {
        queue.set(createResponseQueueKey(message.id), message);
      } else {
        queue.set(createNotificationQueueKey(), message);
      }
    }
    function cancelUndispatched(_message) {
      return void 0;
    }
    function isListening() {
      return state === ConnectionState.Listening;
    }
    function isClosed() {
      return state === ConnectionState.Closed;
    }
    function isDisposed() {
      return state === ConnectionState.Disposed;
    }
    function closeHandler() {
      if (state === ConnectionState.New || state === ConnectionState.Listening) {
        state = ConnectionState.Closed;
        closeEmitter.fire(void 0);
      }
    }
    function readErrorHandler(error) {
      errorEmitter.fire([error, void 0, void 0]);
    }
    function writeErrorHandler(data) {
      errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
      if (timer || messageQueue.size === 0) {
        return;
      }
      timer = ral_1.default().timer.setImmediate(() => {
        timer = void 0;
        processMessageQueue();
      });
    }
    function processMessageQueue() {
      if (messageQueue.size === 0) {
        return;
      }
      const message = messageQueue.shift();
      try {
        if (messages_1.isRequestMessage(message)) {
          handleRequest(message);
        } else if (messages_1.isNotificationMessage(message)) {
          handleNotification(message);
        } else if (messages_1.isResponseMessage(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      } finally {
        triggerMessageQueue();
      }
    }
    const callback = (message) => {
      try {
        if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          const key = createRequestQueueKey(cancelId);
          const toCancel = messageQueue.get(key);
          if (messages_1.isRequestMessage(toCancel)) {
            const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
            const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
            if (response && (response.error !== void 0 || response.result !== void 0)) {
              messageQueue.delete(key);
              response.id = toCancel.id;
              traceSendingResponse(response, message.method, Date.now());
              messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
              return;
            }
          }
          const tokenKey = String(cancelId);
          const cancellationToken = requestTokens[tokenKey];
          if (cancellationToken !== void 0) {
            cancellationToken.cancel();
            traceReceivedNotification(message);
            return;
          } else {
            knownCanceledRequests.add(cancelId);
          }
        }
        addMessageToQueue(messageQueue, message);
      } finally {
        triggerMessageQueue();
      }
    };
    function handleRequest(requestMessage) {
      if (isDisposed()) {
        return;
      }
      function reply(resultOrError, method, startTime2) {
        const message = {
          jsonrpc: version,
          id: requestMessage.id
        };
        if (resultOrError instanceof messages_1.ResponseError) {
          message.error = resultOrError.toJson();
        } else {
          message.result = resultOrError === void 0 ? null : resultOrError;
        }
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
      }
      function replyError(error, method, startTime2) {
        const message = {
          jsonrpc: version,
          id: requestMessage.id,
          error: error.toJson()
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
      }
      function replySuccess(result, method, startTime2) {
        if (result === void 0) {
          result = null;
        }
        const message = {
          jsonrpc: version,
          id: requestMessage.id,
          result
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
      }
      traceReceivedRequest(requestMessage);
      const element = requestHandlers[requestMessage.method];
      let type;
      let requestHandler;
      if (element) {
        type = element.type;
        requestHandler = element.handler;
      }
      const startTime = Date.now();
      if (requestHandler || starRequestHandler) {
        const tokenKey = String(requestMessage.id);
        const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
        if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
          cancellationSource.cancel();
        }
        requestTokens[tokenKey] = cancellationSource;
        try {
          let handlerResult;
          if (requestHandler) {
            if (requestMessage.params === void 0) {
              if (type !== void 0 && type.numberOfParams !== 0) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(cancellationSource.token);
            } else if (Array.isArray(requestMessage.params)) {
              if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
            } else {
              if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
            }
          } else if (starRequestHandler) {
            handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
          }
          const promise = handlerResult;
          if (!handlerResult) {
            delete requestTokens[tokenKey];
            replySuccess(handlerResult, requestMessage.method, startTime);
          } else if (promise.then) {
            promise.then((resultOrError) => {
              delete requestTokens[tokenKey];
              reply(resultOrError, requestMessage.method, startTime);
            }, (error) => {
              delete requestTokens[tokenKey];
              if (error instanceof messages_1.ResponseError) {
                replyError(error, requestMessage.method, startTime);
              } else if (error && Is.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            });
          } else {
            delete requestTokens[tokenKey];
            reply(handlerResult, requestMessage.method, startTime);
          }
        } catch (error) {
          delete requestTokens[tokenKey];
          if (error instanceof messages_1.ResponseError) {
            reply(error, requestMessage.method, startTime);
          } else if (error && Is.string(error.message)) {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
          }
        }
      } else {
        replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
      }
    }
    function handleResponse(responseMessage) {
      if (isDisposed()) {
        return;
      }
      if (responseMessage.id === null) {
        if (responseMessage.error) {
          logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
        } else {
          logger.error(`Received response message without id. No further error information provided.`);
        }
      } else {
        const key = String(responseMessage.id);
        const responsePromise = responsePromises[key];
        traceReceivedResponse(responseMessage, responsePromise);
        if (responsePromise) {
          delete responsePromises[key];
          try {
            if (responseMessage.error) {
              const error = responseMessage.error;
              responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
            } else if (responseMessage.result !== void 0) {
              responsePromise.resolve(responseMessage.result);
            } else {
              throw new Error("Should never happen.");
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
            }
          }
        }
      }
    }
    function handleNotification(message) {
      if (isDisposed()) {
        return;
      }
      let type = void 0;
      let notificationHandler;
      if (message.method === CancelNotification.type.method) {
        const cancelId = message.params.id;
        knownCanceledRequests.delete(cancelId);
        traceReceivedNotification(message);
        return;
      } else {
        const element = notificationHandlers[message.method];
        if (element) {
          notificationHandler = element.handler;
          type = element.type;
        }
      }
      if (notificationHandler || starNotificationHandler) {
        try {
          traceReceivedNotification(message);
          if (notificationHandler) {
            if (message.params === void 0) {
              if (type !== void 0) {
                if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                  logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                }
              }
              notificationHandler();
            } else if (Array.isArray(message.params)) {
              if (type !== void 0) {
                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                  logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                }
                if (type.numberOfParams !== message.params.length) {
                  logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} arguments`);
                }
              }
              notificationHandler(...message.params);
            } else {
              if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
              }
              notificationHandler(message.params);
            }
          } else if (starNotificationHandler) {
            starNotificationHandler(message.method, message.params);
          }
        } catch (error) {
          if (error.message) {
            logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
          } else {
            logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
          }
        }
      } else {
        unhandledNotificationEmitter.fire(message);
      }
    }
    function handleInvalidMessage(message) {
      if (!message) {
        logger.error("Received empty message.");
        return;
      }
      logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
      const responseMessage = message;
      if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
        const key = String(responseMessage.id);
        const responseHandler = responsePromises[key];
        if (responseHandler) {
          responseHandler.reject(new Error("The received response has neither a result nor an error property."));
        }
      }
    }
    function traceSendingRequest(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("send-request", message);
      }
    }
    function traceSendingNotification(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Sending notification '${message.method}'.`, data);
      } else {
        logLSPMessage("send-notification", message);
      }
    }
    function traceSendingResponse(message, method, startTime) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
      } else {
        logLSPMessage("send-response", message);
      }
    }
    function traceReceivedRequest(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("receive-request", message);
      }
    }
    function traceReceivedNotification(message) {
      if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Received notification '${message.method}'.`, data);
      } else {
        logLSPMessage("receive-notification", message);
      }
    }
    function traceReceivedResponse(message, responsePromise) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        if (responsePromise) {
          const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
          tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
        } else {
          tracer.log(`Received response ${message.id} without active response promise.`, data);
        }
      } else {
        logLSPMessage("receive-response", message);
      }
    }
    function logLSPMessage(type, message) {
      if (!tracer || trace === Trace.Off) {
        return;
      }
      const lspMessage = {
        isLSPMessage: true,
        type,
        message,
        timestamp: Date.now()
      };
      tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
      if (isClosed()) {
        throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
      }
      if (isDisposed()) {
        throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
      }
    }
    function throwIfListening() {
      if (isListening()) {
        throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
      }
    }
    function throwIfNotListening() {
      if (!isListening()) {
        throw new Error("Call listen() first.");
      }
    }
    function undefinedToNull(param) {
      if (param === void 0) {
        return null;
      } else {
        return param;
      }
    }
    function nullToUndefined(param) {
      if (param === null) {
        return void 0;
      } else {
        return param;
      }
    }
    function isNamedParam(param) {
      return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
    }
    function computeSingleParam(parameterStructures, param) {
      switch (parameterStructures) {
        case messages_1.ParameterStructures.auto:
          if (isNamedParam(param)) {
            return nullToUndefined(param);
          } else {
            return [undefinedToNull(param)];
          }
        case messages_1.ParameterStructures.byName:
          if (!isNamedParam(param)) {
            throw new Error(`Received parameters by name but param is not an object literal.`);
          }
          return nullToUndefined(param);
        case messages_1.ParameterStructures.byPosition:
          return [undefinedToNull(param)];
        default:
          throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
      }
    }
    function computeMessageParams(type, params) {
      let result;
      const numberOfParams = type.numberOfParams;
      switch (numberOfParams) {
        case 0:
          result = void 0;
          break;
        case 1:
          result = computeSingleParam(type.parameterStructures, params[0]);
          break;
        default:
          result = [];
          for (let i = 0; i < params.length && i < numberOfParams; i++) {
            result.push(undefinedToNull(params[i]));
          }
          if (params.length < numberOfParams) {
            for (let i = params.length; i < numberOfParams; i++) {
              result.push(null);
            }
          }
          break;
      }
      return result;
    }
    const connection = {
      sendNotification: (type, ...args) => {
        throwIfClosedOrDisposed();
        let method;
        let messageParams;
        if (Is.string(type)) {
          method = type;
          const first = args[0];
          let paramStart = 0;
          let parameterStructures = messages_1.ParameterStructures.auto;
          if (messages_1.ParameterStructures.is(first)) {
            paramStart = 1;
            parameterStructures = first;
          }
          let paramEnd = args.length;
          const numberOfParams = paramEnd - paramStart;
          switch (numberOfParams) {
            case 0:
              messageParams = void 0;
              break;
            case 1:
              messageParams = computeSingleParam(parameterStructures, args[paramStart]);
              break;
            default:
              if (parameterStructures === messages_1.ParameterStructures.byName) {
                throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
              }
              messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
              break;
          }
        } else {
          const params = args;
          method = type.method;
          messageParams = computeMessageParams(type, params);
        }
        const notificationMessage = {
          jsonrpc: version,
          method,
          params: messageParams
        };
        traceSendingNotification(notificationMessage);
        return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
      },
      onNotification: (type, handler) => {
        throwIfClosedOrDisposed();
        let method;
        if (Is.func(type)) {
          starNotificationHandler = type;
        } else if (handler) {
          if (Is.string(type)) {
            method = type;
            notificationHandlers[type] = {type: void 0, handler};
          } else {
            method = type.method;
            notificationHandlers[type.method] = {type, handler};
          }
        }
        return {
          dispose: () => {
            if (method !== void 0) {
              delete notificationHandlers[method];
            } else {
              starNotificationHandler = void 0;
            }
          }
        };
      },
      onProgress: (_type, token, handler) => {
        if (progressHandlers.has(token)) {
          throw new Error(`Progress handler for token ${token} already registered`);
        }
        progressHandlers.set(token, handler);
        return {
          dispose: () => {
            progressHandlers.delete(token);
          }
        };
      },
      sendProgress: (_type, token, value) => {
        return connection.sendNotification(ProgressNotification.type, {token, value});
      },
      onUnhandledProgress: unhandledProgressEmitter.event,
      sendRequest: (type, ...args) => {
        throwIfClosedOrDisposed();
        throwIfNotListening();
        let method;
        let messageParams;
        let token = void 0;
        if (Is.string(type)) {
          method = type;
          const first = args[0];
          const last = args[args.length - 1];
          let paramStart = 0;
          let parameterStructures = messages_1.ParameterStructures.auto;
          if (messages_1.ParameterStructures.is(first)) {
            paramStart = 1;
            parameterStructures = first;
          }
          let paramEnd = args.length;
          if (cancellation_1.CancellationToken.is(last)) {
            paramEnd = paramEnd - 1;
            token = last;
          }
          const numberOfParams = paramEnd - paramStart;
          switch (numberOfParams) {
            case 0:
              messageParams = void 0;
              break;
            case 1:
              messageParams = computeSingleParam(parameterStructures, args[paramStart]);
              break;
            default:
              if (parameterStructures === messages_1.ParameterStructures.byName) {
                throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
              }
              messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
              break;
          }
        } else {
          const params = args;
          method = type.method;
          messageParams = computeMessageParams(type, params);
          const numberOfParams = type.numberOfParams;
          token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
        }
        const id = sequenceNumber++;
        let disposable;
        if (token) {
          disposable = token.onCancellationRequested(() => {
            const p = cancellationStrategy.sender.sendCancellation(connection, id);
            if (p === void 0) {
              logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
              return Promise.resolve();
            } else {
              return p.catch(() => {
                logger.log(`Sending cancellation messages for id ${id} failed`);
              });
            }
          });
        }
        const result = new Promise((resolve, reject) => {
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          const resolveWithCleanup = (r) => {
            resolve(r);
            cancellationStrategy.sender.cleanup(id);
            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
          };
          const rejectWithCleanup = (r) => {
            reject(r);
            cancellationStrategy.sender.cleanup(id);
            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
          };
          let responsePromise = {method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup};
          traceSendingRequest(requestMessage);
          try {
            messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
          } catch (e) {
            responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
            responsePromise = null;
          }
          if (responsePromise) {
            responsePromises[String(id)] = responsePromise;
          }
        });
        return result;
      },
      onRequest: (type, handler) => {
        throwIfClosedOrDisposed();
        let method = null;
        if (StarRequestHandler.is(type)) {
          method = void 0;
          starRequestHandler = type;
        } else if (Is.string(type)) {
          method = null;
          if (handler !== void 0) {
            method = type;
            requestHandlers[type] = {handler, type: void 0};
          }
        } else {
          if (handler !== void 0) {
            method = type.method;
            requestHandlers[type.method] = {type, handler};
          }
        }
        return {
          dispose: () => {
            if (method === null) {
              return;
            }
            if (method !== void 0) {
              delete requestHandlers[method];
            } else {
              starRequestHandler = void 0;
            }
          }
        };
      },
      trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
        let _sendNotification = false;
        let _traceFormat = TraceFormat.Text;
        if (sendNotificationOrTraceOptions !== void 0) {
          if (Is.boolean(sendNotificationOrTraceOptions)) {
            _sendNotification = sendNotificationOrTraceOptions;
          } else {
            _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
            _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
          }
        }
        trace = _value;
        traceFormat = _traceFormat;
        if (trace === Trace.Off) {
          tracer = void 0;
        } else {
          tracer = _tracer;
        }
        if (_sendNotification && !isClosed() && !isDisposed()) {
          connection.sendNotification(SetTraceNotification.type, {value: Trace.toString(_value)}).catch(() => {
            logger.error(`Sending trace notification failed`);
          });
        }
      },
      onError: errorEmitter.event,
      onClose: closeEmitter.event,
      onUnhandledNotification: unhandledNotificationEmitter.event,
      onDispose: disposeEmitter.event,
      end: () => {
        messageWriter.end();
      },
      dispose: () => {
        if (isDisposed()) {
          return;
        }
        state = ConnectionState.Disposed;
        disposeEmitter.fire(void 0);
        const error = new Error("Connection got disposed.");
        Object.keys(responsePromises).forEach((key) => {
          responsePromises[key].reject(error);
        });
        responsePromises = Object.create(null);
        requestTokens = Object.create(null);
        knownCanceledRequests = new Set();
        messageQueue = new linkedMap_1.LinkedMap();
        if (Is.func(messageWriter.dispose)) {
          messageWriter.dispose();
        }
        if (Is.func(messageReader.dispose)) {
          messageReader.dispose();
        }
      },
      listen: () => {
        throwIfClosedOrDisposed();
        throwIfListening();
        state = ConnectionState.Listening;
        messageReader.listen(callback);
      },
      inspect: () => {
        ral_1.default().console.log("inspect");
      }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      tracer.log(params.message, trace === Trace.Verbose ? params.verbose : void 0);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
      const handler = progressHandlers.get(params.token);
      if (handler) {
        handler(params.value);
      } else {
        unhandledProgressEmitter.fire(params);
      }
    });
    return connection;
  }
  exports2.createMessageConnection = createMessageConnection;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.ProgressType = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.RAL = void 0;
  exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = void 0;
  var messages_1 = require_messages2();
  Object.defineProperty(exports2, "RequestType", {enumerable: true, get: function() {
    return messages_1.RequestType;
  }});
  Object.defineProperty(exports2, "RequestType0", {enumerable: true, get: function() {
    return messages_1.RequestType0;
  }});
  Object.defineProperty(exports2, "RequestType1", {enumerable: true, get: function() {
    return messages_1.RequestType1;
  }});
  Object.defineProperty(exports2, "RequestType2", {enumerable: true, get: function() {
    return messages_1.RequestType2;
  }});
  Object.defineProperty(exports2, "RequestType3", {enumerable: true, get: function() {
    return messages_1.RequestType3;
  }});
  Object.defineProperty(exports2, "RequestType4", {enumerable: true, get: function() {
    return messages_1.RequestType4;
  }});
  Object.defineProperty(exports2, "RequestType5", {enumerable: true, get: function() {
    return messages_1.RequestType5;
  }});
  Object.defineProperty(exports2, "RequestType6", {enumerable: true, get: function() {
    return messages_1.RequestType6;
  }});
  Object.defineProperty(exports2, "RequestType7", {enumerable: true, get: function() {
    return messages_1.RequestType7;
  }});
  Object.defineProperty(exports2, "RequestType8", {enumerable: true, get: function() {
    return messages_1.RequestType8;
  }});
  Object.defineProperty(exports2, "RequestType9", {enumerable: true, get: function() {
    return messages_1.RequestType9;
  }});
  Object.defineProperty(exports2, "ResponseError", {enumerable: true, get: function() {
    return messages_1.ResponseError;
  }});
  Object.defineProperty(exports2, "ErrorCodes", {enumerable: true, get: function() {
    return messages_1.ErrorCodes;
  }});
  Object.defineProperty(exports2, "NotificationType", {enumerable: true, get: function() {
    return messages_1.NotificationType;
  }});
  Object.defineProperty(exports2, "NotificationType0", {enumerable: true, get: function() {
    return messages_1.NotificationType0;
  }});
  Object.defineProperty(exports2, "NotificationType1", {enumerable: true, get: function() {
    return messages_1.NotificationType1;
  }});
  Object.defineProperty(exports2, "NotificationType2", {enumerable: true, get: function() {
    return messages_1.NotificationType2;
  }});
  Object.defineProperty(exports2, "NotificationType3", {enumerable: true, get: function() {
    return messages_1.NotificationType3;
  }});
  Object.defineProperty(exports2, "NotificationType4", {enumerable: true, get: function() {
    return messages_1.NotificationType4;
  }});
  Object.defineProperty(exports2, "NotificationType5", {enumerable: true, get: function() {
    return messages_1.NotificationType5;
  }});
  Object.defineProperty(exports2, "NotificationType6", {enumerable: true, get: function() {
    return messages_1.NotificationType6;
  }});
  Object.defineProperty(exports2, "NotificationType7", {enumerable: true, get: function() {
    return messages_1.NotificationType7;
  }});
  Object.defineProperty(exports2, "NotificationType8", {enumerable: true, get: function() {
    return messages_1.NotificationType8;
  }});
  Object.defineProperty(exports2, "NotificationType9", {enumerable: true, get: function() {
    return messages_1.NotificationType9;
  }});
  Object.defineProperty(exports2, "ParameterStructures", {enumerable: true, get: function() {
    return messages_1.ParameterStructures;
  }});
  var linkedMap_1 = require_linkedMap2();
  Object.defineProperty(exports2, "LinkedMap", {enumerable: true, get: function() {
    return linkedMap_1.LinkedMap;
  }});
  Object.defineProperty(exports2, "LRUCache", {enumerable: true, get: function() {
    return linkedMap_1.LRUCache;
  }});
  Object.defineProperty(exports2, "Touch", {enumerable: true, get: function() {
    return linkedMap_1.Touch;
  }});
  var disposable_1 = require_disposable2();
  Object.defineProperty(exports2, "Disposable", {enumerable: true, get: function() {
    return disposable_1.Disposable;
  }});
  var events_1 = require_events2();
  Object.defineProperty(exports2, "Event", {enumerable: true, get: function() {
    return events_1.Event;
  }});
  Object.defineProperty(exports2, "Emitter", {enumerable: true, get: function() {
    return events_1.Emitter;
  }});
  var cancellation_1 = require_cancellation2();
  Object.defineProperty(exports2, "CancellationTokenSource", {enumerable: true, get: function() {
    return cancellation_1.CancellationTokenSource;
  }});
  Object.defineProperty(exports2, "CancellationToken", {enumerable: true, get: function() {
    return cancellation_1.CancellationToken;
  }});
  var messageReader_1 = require_messageReader2();
  Object.defineProperty(exports2, "MessageReader", {enumerable: true, get: function() {
    return messageReader_1.MessageReader;
  }});
  Object.defineProperty(exports2, "AbstractMessageReader", {enumerable: true, get: function() {
    return messageReader_1.AbstractMessageReader;
  }});
  Object.defineProperty(exports2, "ReadableStreamMessageReader", {enumerable: true, get: function() {
    return messageReader_1.ReadableStreamMessageReader;
  }});
  var messageWriter_1 = require_messageWriter2();
  Object.defineProperty(exports2, "MessageWriter", {enumerable: true, get: function() {
    return messageWriter_1.MessageWriter;
  }});
  Object.defineProperty(exports2, "AbstractMessageWriter", {enumerable: true, get: function() {
    return messageWriter_1.AbstractMessageWriter;
  }});
  Object.defineProperty(exports2, "WriteableStreamMessageWriter", {enumerable: true, get: function() {
    return messageWriter_1.WriteableStreamMessageWriter;
  }});
  var connection_1 = require_connection2();
  Object.defineProperty(exports2, "ConnectionStrategy", {enumerable: true, get: function() {
    return connection_1.ConnectionStrategy;
  }});
  Object.defineProperty(exports2, "ConnectionOptions", {enumerable: true, get: function() {
    return connection_1.ConnectionOptions;
  }});
  Object.defineProperty(exports2, "NullLogger", {enumerable: true, get: function() {
    return connection_1.NullLogger;
  }});
  Object.defineProperty(exports2, "createMessageConnection", {enumerable: true, get: function() {
    return connection_1.createMessageConnection;
  }});
  Object.defineProperty(exports2, "ProgressType", {enumerable: true, get: function() {
    return connection_1.ProgressType;
  }});
  Object.defineProperty(exports2, "Trace", {enumerable: true, get: function() {
    return connection_1.Trace;
  }});
  Object.defineProperty(exports2, "TraceFormat", {enumerable: true, get: function() {
    return connection_1.TraceFormat;
  }});
  Object.defineProperty(exports2, "SetTraceNotification", {enumerable: true, get: function() {
    return connection_1.SetTraceNotification;
  }});
  Object.defineProperty(exports2, "LogTraceNotification", {enumerable: true, get: function() {
    return connection_1.LogTraceNotification;
  }});
  Object.defineProperty(exports2, "ConnectionErrors", {enumerable: true, get: function() {
    return connection_1.ConnectionErrors;
  }});
  Object.defineProperty(exports2, "ConnectionError", {enumerable: true, get: function() {
    return connection_1.ConnectionError;
  }});
  Object.defineProperty(exports2, "CancellationReceiverStrategy", {enumerable: true, get: function() {
    return connection_1.CancellationReceiverStrategy;
  }});
  Object.defineProperty(exports2, "CancellationSenderStrategy", {enumerable: true, get: function() {
    return connection_1.CancellationSenderStrategy;
  }});
  Object.defineProperty(exports2, "CancellationStrategy", {enumerable: true, get: function() {
    return connection_1.CancellationStrategy;
  }});
  var ral_1 = require_ral2();
  exports2.RAL = ral_1.default;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main2 = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
  var ril_1 = require_ril2();
  ril_1.default.install();
  var api_1 = require_api2();
  var path4 = require("path");
  var os = require("os");
  var crypto_1 = require("crypto");
  var net_1 = require("net");
  __exportStar2(require_api2(), exports2);
  var IPCMessageReader = class extends api_1.AbstractMessageReader {
    constructor(process2) {
      super();
      this.process = process2;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose());
    }
    listen(callback) {
      this.process.on("message", callback);
      return api_1.Disposable.create(() => this.process.off("message", callback));
    }
  };
  exports2.IPCMessageReader = IPCMessageReader;
  var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
    constructor(process2) {
      super();
      this.process = process2;
      this.errorCount = 0;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose);
    }
    write(msg) {
      try {
        if (typeof this.process.send === "function") {
          this.process.send(msg, void 0, void 0, (error) => {
            if (error) {
              this.errorCount++;
              this.handleError(error, msg);
            } else {
              this.errorCount = 0;
            }
          });
        }
        return Promise.resolve();
      } catch (error) {
        this.handleError(error, msg);
        return Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
  };
  exports2.IPCMessageWriter = IPCMessageWriter;
  var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = "utf-8") {
      super(ril_1.default().stream.asReadableStream(socket), encoding);
    }
  };
  exports2.SocketMessageReader = SocketMessageReader;
  var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
      super(ril_1.default().stream.asWritableStream(socket), options);
      this.socket = socket;
    }
    dispose() {
      super.dispose();
      this.socket.destroy();
    }
  };
  exports2.SocketMessageWriter = SocketMessageWriter;
  var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
      super(ril_1.default().stream.asReadableStream(readble), encoding);
    }
  };
  exports2.StreamMessageReader = StreamMessageReader;
  var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
      super(ril_1.default().stream.asWritableStream(writable), options);
    }
  };
  exports2.StreamMessageWriter = StreamMessageWriter;
  var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
  var safeIpcPathLengths = new Map([
    ["linux", 107],
    ["darwin", 103]
  ]);
  function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString("hex");
    if (process.platform === "win32") {
      return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
      result = path4.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    } else {
      result = path4.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== void 0 && result.length >= limit) {
      ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
  }
  exports2.generateRandomPipeName = generateRandomPipeName;
  function createClientPipeTransport(pipeName, encoding = "utf-8") {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      let server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new SocketMessageReader(socket, encoding),
          new SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(pipeName, () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientPipeTransport = createClientPipeTransport;
  function createServerPipeTransport(pipeName, encoding = "utf-8") {
    const socket = net_1.createConnection(pipeName);
    return [
      new SocketMessageReader(socket, encoding),
      new SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerPipeTransport = createServerPipeTransport;
  function createClientSocketTransport(port, encoding = "utf-8") {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      const server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new SocketMessageReader(socket, encoding),
          new SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(port, "127.0.0.1", () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientSocketTransport = createClientSocketTransport;
  function createServerSocketTransport(port, encoding = "utf-8") {
    const socket = net_1.createConnection(port, "127.0.0.1");
    return [
      new SocketMessageReader(socket, encoding),
      new SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerSocketTransport = createServerSocketTransport;
  function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== void 0 && candidate.addListener !== void 0;
  }
  function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== void 0 && candidate.addListener !== void 0;
  }
  function createMessageConnection(input, output, logger, options) {
    if (!logger) {
      logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
      options = {connectionStrategy: options};
    }
    return api_1.createMessageConnection(reader, writer, logger, options);
  }
  exports2.createMessageConnection = createMessageConnection;
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_main2();
});

// node_modules/vscode-languageserver-protocol/node_modules/vscode-languageserver-types/lib/esm/main.js
var require_main3 = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    AnnotatedTextEdit: () => AnnotatedTextEdit,
    ChangeAnnotation: () => ChangeAnnotation,
    ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
    CodeAction: () => CodeAction2,
    CodeActionContext: () => CodeActionContext2,
    CodeActionKind: () => CodeActionKind,
    CodeDescription: () => CodeDescription,
    CodeLens: () => CodeLens,
    Color: () => Color,
    ColorInformation: () => ColorInformation,
    ColorPresentation: () => ColorPresentation,
    Command: () => Command,
    CompletionItem: () => CompletionItem,
    CompletionItemKind: () => CompletionItemKind,
    CompletionItemLabelDetails: () => CompletionItemLabelDetails,
    CompletionItemTag: () => CompletionItemTag,
    CompletionList: () => CompletionList,
    CreateFile: () => CreateFile,
    DeleteFile: () => DeleteFile,
    Diagnostic: () => Diagnostic,
    DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
    DiagnosticSeverity: () => DiagnosticSeverity,
    DiagnosticTag: () => DiagnosticTag,
    DocumentHighlight: () => DocumentHighlight,
    DocumentHighlightKind: () => DocumentHighlightKind,
    DocumentLink: () => DocumentLink,
    DocumentSymbol: () => DocumentSymbol,
    EOL: () => EOL,
    FoldingRange: () => FoldingRange,
    FoldingRangeKind: () => FoldingRangeKind,
    FormattingOptions: () => FormattingOptions,
    Hover: () => Hover,
    InsertReplaceEdit: () => InsertReplaceEdit,
    InsertTextFormat: () => InsertTextFormat,
    InsertTextMode: () => InsertTextMode,
    Location: () => Location2,
    LocationLink: () => LocationLink,
    MarkedString: () => MarkedString,
    MarkupContent: () => MarkupContent,
    MarkupKind: () => MarkupKind,
    OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
    ParameterInformation: () => ParameterInformation,
    Position: () => Position8,
    Range: () => Range5,
    RenameFile: () => RenameFile,
    SelectionRange: () => SelectionRange,
    SemanticTokenModifiers: () => SemanticTokenModifiers,
    SemanticTokenTypes: () => SemanticTokenTypes,
    SemanticTokens: () => SemanticTokens,
    SignatureInformation: () => SignatureInformation,
    SymbolInformation: () => SymbolInformation,
    SymbolKind: () => SymbolKind,
    SymbolTag: () => SymbolTag,
    TextDocument: () => TextDocument4,
    TextDocumentEdit: () => TextDocumentEdit,
    TextDocumentIdentifier: () => TextDocumentIdentifier,
    TextDocumentItem: () => TextDocumentItem,
    TextEdit: () => TextEdit2,
    VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
    WorkspaceChange: () => WorkspaceChange,
    WorkspaceEdit: () => WorkspaceEdit,
    integer: () => integer,
    uinteger: () => uinteger
  });
  "use strict";
  var integer;
  (function(integer2) {
    integer2.MIN_VALUE = -2147483648;
    integer2.MAX_VALUE = 2147483647;
  })(integer || (integer = {}));
  var uinteger;
  (function(uinteger2) {
    uinteger2.MIN_VALUE = 0;
    uinteger2.MAX_VALUE = 2147483647;
  })(uinteger || (uinteger = {}));
  var Position8;
  (function(Position9) {
    function create(line, character) {
      if (line === Number.MAX_VALUE) {
        line = uinteger.MAX_VALUE;
      }
      if (character === Number.MAX_VALUE) {
        character = uinteger.MAX_VALUE;
      }
      return {line, character};
    }
    Position9.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position9.is = is;
  })(Position8 || (Position8 = {}));
  var Range5;
  (function(Range6) {
    function create(one, two, three, four) {
      if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
        return {start: Position8.create(one, two), end: Position8.create(three, four)};
      } else if (Position8.is(one) && Position8.is(two)) {
        return {start: one, end: two};
      } else {
        throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
      }
    }
    Range6.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Position8.is(candidate.start) && Position8.is(candidate.end);
    }
    Range6.is = is;
  })(Range5 || (Range5 = {}));
  var Location2;
  (function(Location3) {
    function create(uri, range) {
      return {uri, range};
    }
    Location3.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range5.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location3.is = is;
  })(Location2 || (Location2 = {}));
  var LocationLink;
  (function(LocationLink2) {
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
      return {targetUri, targetRange, targetSelectionRange, originSelectionRange};
    }
    LocationLink2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range5.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range5.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range5.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink2.is = is;
  })(LocationLink || (LocationLink = {}));
  var Color;
  (function(Color2) {
    function create(red, green, blue, alpha) {
      return {
        red,
        green,
        blue,
        alpha
      };
    }
    Color2.create = create;
    function is(value) {
      var candidate = value;
      return Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color2.is = is;
  })(Color || (Color = {}));
  var ColorInformation;
  (function(ColorInformation2) {
    function create(range, color) {
      return {
        range,
        color
      };
    }
    ColorInformation2.create = create;
    function is(value) {
      var candidate = value;
      return Range5.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation2.is = is;
  })(ColorInformation || (ColorInformation = {}));
  var ColorPresentation;
  (function(ColorPresentation2) {
    function create(label, textEdit, additionalTextEdits) {
      return {
        label,
        textEdit,
        additionalTextEdits
      };
    }
    ColorPresentation2.create = create;
    function is(value) {
      var candidate = value;
      return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit2.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit2.is));
    }
    ColorPresentation2.is = is;
  })(ColorPresentation || (ColorPresentation = {}));
  var FoldingRangeKind;
  (function(FoldingRangeKind2) {
    FoldingRangeKind2["Comment"] = "comment";
    FoldingRangeKind2["Imports"] = "imports";
    FoldingRangeKind2["Region"] = "region";
  })(FoldingRangeKind || (FoldingRangeKind = {}));
  var FoldingRange;
  (function(FoldingRange2) {
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
      var result = {
        startLine,
        endLine
      };
      if (Is.defined(startCharacter)) {
        result.startCharacter = startCharacter;
      }
      if (Is.defined(endCharacter)) {
        result.endCharacter = endCharacter;
      }
      if (Is.defined(kind)) {
        result.kind = kind;
      }
      return result;
    }
    FoldingRange2.create = create;
    function is(value) {
      var candidate = value;
      return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange2.is = is;
  })(FoldingRange || (FoldingRange = {}));
  var DiagnosticRelatedInformation;
  (function(DiagnosticRelatedInformation2) {
    function create(location, message) {
      return {
        location,
        message
      };
    }
    DiagnosticRelatedInformation2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Location2.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation2.is = is;
  })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
  var DiagnosticSeverity;
  (function(DiagnosticSeverity2) {
    DiagnosticSeverity2.Error = 1;
    DiagnosticSeverity2.Warning = 2;
    DiagnosticSeverity2.Information = 3;
    DiagnosticSeverity2.Hint = 4;
  })(DiagnosticSeverity || (DiagnosticSeverity = {}));
  var DiagnosticTag;
  (function(DiagnosticTag2) {
    DiagnosticTag2.Unnecessary = 1;
    DiagnosticTag2.Deprecated = 2;
  })(DiagnosticTag || (DiagnosticTag = {}));
  var CodeDescription;
  (function(CodeDescription2) {
    function is(value) {
      var candidate = value;
      return candidate !== void 0 && candidate !== null && Is.string(candidate.href);
    }
    CodeDescription2.is = is;
  })(CodeDescription || (CodeDescription = {}));
  var Diagnostic;
  (function(Diagnostic2) {
    function create(range, message, severity, code, source, relatedInformation) {
      var result = {range, message};
      if (Is.defined(severity)) {
        result.severity = severity;
      }
      if (Is.defined(code)) {
        result.code = code;
      }
      if (Is.defined(source)) {
        result.source = source;
      }
      if (Is.defined(relatedInformation)) {
        result.relatedInformation = relatedInformation;
      }
      return result;
    }
    Diagnostic2.create = create;
    function is(value) {
      var _a2;
      var candidate = value;
      return Is.defined(candidate) && Range5.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic2.is = is;
  })(Diagnostic || (Diagnostic = {}));
  var Command;
  (function(Command2) {
    function create(title, command) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var result = {title, command};
      if (Is.defined(args) && args.length > 0) {
        result.arguments = args;
      }
      return result;
    }
    Command2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command2.is = is;
  })(Command || (Command = {}));
  var TextEdit2;
  (function(TextEdit3) {
    function replace(range, newText) {
      return {range, newText};
    }
    TextEdit3.replace = replace;
    function insert(position, newText) {
      return {range: {start: position, end: position}, newText};
    }
    TextEdit3.insert = insert;
    function del(range) {
      return {range, newText: ""};
    }
    TextEdit3.del = del;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range5.is(candidate.range);
    }
    TextEdit3.is = is;
  })(TextEdit2 || (TextEdit2 = {}));
  var ChangeAnnotation;
  (function(ChangeAnnotation2) {
    function create(label, needsConfirmation, description) {
      var result = {label};
      if (needsConfirmation !== void 0) {
        result.needsConfirmation = needsConfirmation;
      }
      if (description !== void 0) {
        result.description = description;
      }
      return result;
    }
    ChangeAnnotation2.create = create;
    function is(value) {
      var candidate = value;
      return candidate !== void 0 && Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    ChangeAnnotation2.is = is;
  })(ChangeAnnotation || (ChangeAnnotation = {}));
  var ChangeAnnotationIdentifier;
  (function(ChangeAnnotationIdentifier2) {
    function is(value) {
      var candidate = value;
      return typeof candidate === "string";
    }
    ChangeAnnotationIdentifier2.is = is;
  })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
  var AnnotatedTextEdit;
  (function(AnnotatedTextEdit2) {
    function replace(range, newText, annotation) {
      return {range, newText, annotationId: annotation};
    }
    AnnotatedTextEdit2.replace = replace;
    function insert(position, newText, annotation) {
      return {range: {start: position, end: position}, newText, annotationId: annotation};
    }
    AnnotatedTextEdit2.insert = insert;
    function del(range, annotation) {
      return {range, newText: "", annotationId: annotation};
    }
    AnnotatedTextEdit2.del = del;
    function is(value) {
      var candidate = value;
      return TextEdit2.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit2.is = is;
  })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
  var TextDocumentEdit;
  (function(TextDocumentEdit2) {
    function create(textDocument, edits) {
      return {textDocument, edits};
    }
    TextDocumentEdit2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
    }
    TextDocumentEdit2.is = is;
  })(TextDocumentEdit || (TextDocumentEdit = {}));
  var CreateFile;
  (function(CreateFile2) {
    function create(uri, options, annotation) {
      var result = {
        kind: "create",
        uri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    CreateFile2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile2.is = is;
  })(CreateFile || (CreateFile = {}));
  var RenameFile;
  (function(RenameFile2) {
    function create(oldUri, newUri, options, annotation) {
      var result = {
        kind: "rename",
        oldUri,
        newUri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    RenameFile2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile2.is = is;
  })(RenameFile || (RenameFile = {}));
  var DeleteFile;
  (function(DeleteFile2) {
    function create(uri, options, annotation) {
      var result = {
        kind: "delete",
        uri
      };
      if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    DeleteFile2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile2.is = is;
  })(DeleteFile || (DeleteFile = {}));
  var WorkspaceEdit;
  (function(WorkspaceEdit2) {
    function is(value) {
      var candidate = value;
      return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
        if (Is.string(change.kind)) {
          return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
        } else {
          return TextDocumentEdit.is(change);
        }
      }));
    }
    WorkspaceEdit2.is = is;
  })(WorkspaceEdit || (WorkspaceEdit = {}));
  var TextEditChangeImpl = function() {
    function TextEditChangeImpl2(edits, changeAnnotations) {
      this.edits = edits;
      this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
      var edit;
      var id;
      if (annotation === void 0) {
        edit = TextEdit2.insert(position, newText);
      } else if (ChangeAnnotationIdentifier.is(annotation)) {
        id = annotation;
        edit = AnnotatedTextEdit.insert(position, newText, annotation);
      } else {
        this.assertChangeAnnotations(this.changeAnnotations);
        id = this.changeAnnotations.manage(annotation);
        edit = AnnotatedTextEdit.insert(position, newText, id);
      }
      this.edits.push(edit);
      if (id !== void 0) {
        return id;
      }
    };
    TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
      var edit;
      var id;
      if (annotation === void 0) {
        edit = TextEdit2.replace(range, newText);
      } else if (ChangeAnnotationIdentifier.is(annotation)) {
        id = annotation;
        edit = AnnotatedTextEdit.replace(range, newText, annotation);
      } else {
        this.assertChangeAnnotations(this.changeAnnotations);
        id = this.changeAnnotations.manage(annotation);
        edit = AnnotatedTextEdit.replace(range, newText, id);
      }
      this.edits.push(edit);
      if (id !== void 0) {
        return id;
      }
    };
    TextEditChangeImpl2.prototype.delete = function(range, annotation) {
      var edit;
      var id;
      if (annotation === void 0) {
        edit = TextEdit2.del(range);
      } else if (ChangeAnnotationIdentifier.is(annotation)) {
        id = annotation;
        edit = AnnotatedTextEdit.del(range, annotation);
      } else {
        this.assertChangeAnnotations(this.changeAnnotations);
        id = this.changeAnnotations.manage(annotation);
        edit = AnnotatedTextEdit.del(range, id);
      }
      this.edits.push(edit);
      if (id !== void 0) {
        return id;
      }
    };
    TextEditChangeImpl2.prototype.add = function(edit) {
      this.edits.push(edit);
    };
    TextEditChangeImpl2.prototype.all = function() {
      return this.edits;
    };
    TextEditChangeImpl2.prototype.clear = function() {
      this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
      if (value === void 0) {
        throw new Error("Text edit change is not configured to manage change annotations.");
      }
    };
    return TextEditChangeImpl2;
  }();
  var ChangeAnnotations = function() {
    function ChangeAnnotations2(annotations) {
      this._annotations = annotations === void 0 ? Object.create(null) : annotations;
      this._counter = 0;
      this._size = 0;
    }
    ChangeAnnotations2.prototype.all = function() {
      return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations2.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: false,
      configurable: true
    });
    ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
      var id;
      if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
        id = idOrAnnotation;
      } else {
        id = this.nextId();
        annotation = idOrAnnotation;
      }
      if (this._annotations[id] !== void 0) {
        throw new Error("Id " + id + " is already in use.");
      }
      if (annotation === void 0) {
        throw new Error("No annotation provided for id " + id);
      }
      this._annotations[id] = annotation;
      this._size++;
      return id;
    };
    ChangeAnnotations2.prototype.nextId = function() {
      this._counter++;
      return this._counter.toString();
    };
    return ChangeAnnotations2;
  }();
  var WorkspaceChange = function() {
    function WorkspaceChange2(workspaceEdit) {
      var _this = this;
      this._textEditChanges = Object.create(null);
      if (workspaceEdit !== void 0) {
        this._workspaceEdit = workspaceEdit;
        if (workspaceEdit.documentChanges) {
          this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
          workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          workspaceEdit.documentChanges.forEach(function(change) {
            if (TextDocumentEdit.is(change)) {
              var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
              _this._textEditChanges[change.textDocument.uri] = textEditChange;
            }
          });
        } else if (workspaceEdit.changes) {
          Object.keys(workspaceEdit.changes).forEach(function(key) {
            var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
            _this._textEditChanges[key] = textEditChange;
          });
        }
      } else {
        this._workspaceEdit = {};
      }
    }
    Object.defineProperty(WorkspaceChange2.prototype, "edit", {
      get: function() {
        this.initDocumentChanges();
        if (this._changeAnnotations !== void 0) {
          if (this._changeAnnotations.size === 0) {
            this._workspaceEdit.changeAnnotations = void 0;
          } else {
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        }
        return this._workspaceEdit;
      },
      enumerable: false,
      configurable: true
    });
    WorkspaceChange2.prototype.getTextEditChange = function(key) {
      if (OptionalVersionedTextDocumentIdentifier.is(key)) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var textDocument = {uri: key.uri, version: key.version};
        var result = this._textEditChanges[textDocument.uri];
        if (!result) {
          var edits = [];
          var textDocumentEdit = {
            textDocument,
            edits
          };
          this._workspaceEdit.documentChanges.push(textDocumentEdit);
          result = new TextEditChangeImpl(edits, this._changeAnnotations);
          this._textEditChanges[textDocument.uri] = result;
        }
        return result;
      } else {
        this.initChanges();
        if (this._workspaceEdit.changes === void 0) {
          throw new Error("Workspace edit is not configured for normal text edit changes.");
        }
        var result = this._textEditChanges[key];
        if (!result) {
          var edits = [];
          this._workspaceEdit.changes[key] = edits;
          result = new TextEditChangeImpl(edits);
          this._textEditChanges[key] = result;
        }
        return result;
      }
    };
    WorkspaceChange2.prototype.initDocumentChanges = function() {
      if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
        this._changeAnnotations = new ChangeAnnotations();
        this._workspaceEdit.documentChanges = [];
        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
      }
    };
    WorkspaceChange2.prototype.initChanges = function() {
      if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
        this._workspaceEdit.changes = Object.create(null);
      }
    };
    WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      var annotation;
      if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
        annotation = optionsOrAnnotation;
      } else {
        options = optionsOrAnnotation;
      }
      var operation;
      var id;
      if (annotation === void 0) {
        operation = CreateFile.create(uri, options);
      } else {
        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
        operation = CreateFile.create(uri, options, id);
      }
      this._workspaceEdit.documentChanges.push(operation);
      if (id !== void 0) {
        return id;
      }
    };
    WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      var annotation;
      if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
        annotation = optionsOrAnnotation;
      } else {
        options = optionsOrAnnotation;
      }
      var operation;
      var id;
      if (annotation === void 0) {
        operation = RenameFile.create(oldUri, newUri, options);
      } else {
        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
        operation = RenameFile.create(oldUri, newUri, options, id);
      }
      this._workspaceEdit.documentChanges.push(operation);
      if (id !== void 0) {
        return id;
      }
    };
    WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      var annotation;
      if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
        annotation = optionsOrAnnotation;
      } else {
        options = optionsOrAnnotation;
      }
      var operation;
      var id;
      if (annotation === void 0) {
        operation = DeleteFile.create(uri, options);
      } else {
        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
        operation = DeleteFile.create(uri, options, id);
      }
      this._workspaceEdit.documentChanges.push(operation);
      if (id !== void 0) {
        return id;
      }
    };
    return WorkspaceChange2;
  }();
  var TextDocumentIdentifier;
  (function(TextDocumentIdentifier2) {
    function create(uri) {
      return {uri};
    }
    TextDocumentIdentifier2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier2.is = is;
  })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
  var VersionedTextDocumentIdentifier;
  (function(VersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return {uri, version};
    }
    VersionedTextDocumentIdentifier2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier2.is = is;
  })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
  var OptionalVersionedTextDocumentIdentifier;
  (function(OptionalVersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return {uri, version};
    }
    OptionalVersionedTextDocumentIdentifier2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier2.is = is;
  })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
  var TextDocumentItem;
  (function(TextDocumentItem2) {
    function create(uri, languageId, version, text) {
      return {uri, languageId, version, text};
    }
    TextDocumentItem2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem2.is = is;
  })(TextDocumentItem || (TextDocumentItem = {}));
  var MarkupKind;
  (function(MarkupKind2) {
    MarkupKind2.PlainText = "plaintext";
    MarkupKind2.Markdown = "markdown";
  })(MarkupKind || (MarkupKind = {}));
  (function(MarkupKind2) {
    function is(value) {
      var candidate = value;
      return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
    }
    MarkupKind2.is = is;
  })(MarkupKind || (MarkupKind = {}));
  var MarkupContent;
  (function(MarkupContent2) {
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent2.is = is;
  })(MarkupContent || (MarkupContent = {}));
  var CompletionItemKind;
  (function(CompletionItemKind2) {
    CompletionItemKind2.Text = 1;
    CompletionItemKind2.Method = 2;
    CompletionItemKind2.Function = 3;
    CompletionItemKind2.Constructor = 4;
    CompletionItemKind2.Field = 5;
    CompletionItemKind2.Variable = 6;
    CompletionItemKind2.Class = 7;
    CompletionItemKind2.Interface = 8;
    CompletionItemKind2.Module = 9;
    CompletionItemKind2.Property = 10;
    CompletionItemKind2.Unit = 11;
    CompletionItemKind2.Value = 12;
    CompletionItemKind2.Enum = 13;
    CompletionItemKind2.Keyword = 14;
    CompletionItemKind2.Snippet = 15;
    CompletionItemKind2.Color = 16;
    CompletionItemKind2.File = 17;
    CompletionItemKind2.Reference = 18;
    CompletionItemKind2.Folder = 19;
    CompletionItemKind2.EnumMember = 20;
    CompletionItemKind2.Constant = 21;
    CompletionItemKind2.Struct = 22;
    CompletionItemKind2.Event = 23;
    CompletionItemKind2.Operator = 24;
    CompletionItemKind2.TypeParameter = 25;
  })(CompletionItemKind || (CompletionItemKind = {}));
  var InsertTextFormat;
  (function(InsertTextFormat2) {
    InsertTextFormat2.PlainText = 1;
    InsertTextFormat2.Snippet = 2;
  })(InsertTextFormat || (InsertTextFormat = {}));
  var CompletionItemTag;
  (function(CompletionItemTag2) {
    CompletionItemTag2.Deprecated = 1;
  })(CompletionItemTag || (CompletionItemTag = {}));
  var InsertReplaceEdit;
  (function(InsertReplaceEdit2) {
    function create(newText, insert, replace) {
      return {newText, insert, replace};
    }
    InsertReplaceEdit2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && Is.string(candidate.newText) && Range5.is(candidate.insert) && Range5.is(candidate.replace);
    }
    InsertReplaceEdit2.is = is;
  })(InsertReplaceEdit || (InsertReplaceEdit = {}));
  var InsertTextMode;
  (function(InsertTextMode2) {
    InsertTextMode2.asIs = 1;
    InsertTextMode2.adjustIndentation = 2;
  })(InsertTextMode || (InsertTextMode = {}));
  var CompletionItemLabelDetails;
  (function(CompletionItemLabelDetails2) {
    function is(value) {
      var candidate = value;
      return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    CompletionItemLabelDetails2.is = is;
  })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
  var CompletionItem;
  (function(CompletionItem2) {
    function create(label) {
      return {label};
    }
    CompletionItem2.create = create;
  })(CompletionItem || (CompletionItem = {}));
  var CompletionList;
  (function(CompletionList2) {
    function create(items, isIncomplete) {
      return {items: items ? items : [], isIncomplete: !!isIncomplete};
    }
    CompletionList2.create = create;
  })(CompletionList || (CompletionList = {}));
  var MarkedString;
  (function(MarkedString2) {
    function fromPlainText(plainText) {
      return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    MarkedString2.fromPlainText = fromPlainText;
    function is(value) {
      var candidate = value;
      return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
    }
    MarkedString2.is = is;
  })(MarkedString || (MarkedString = {}));
  var Hover;
  (function(Hover2) {
    function is(value) {
      var candidate = value;
      return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range5.is(value.range));
    }
    Hover2.is = is;
  })(Hover || (Hover = {}));
  var ParameterInformation;
  (function(ParameterInformation2) {
    function create(label, documentation) {
      return documentation ? {label, documentation} : {label};
    }
    ParameterInformation2.create = create;
  })(ParameterInformation || (ParameterInformation = {}));
  var SignatureInformation;
  (function(SignatureInformation2) {
    function create(label, documentation) {
      var parameters = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        parameters[_i - 2] = arguments[_i];
      }
      var result = {label};
      if (Is.defined(documentation)) {
        result.documentation = documentation;
      }
      if (Is.defined(parameters)) {
        result.parameters = parameters;
      } else {
        result.parameters = [];
      }
      return result;
    }
    SignatureInformation2.create = create;
  })(SignatureInformation || (SignatureInformation = {}));
  var DocumentHighlightKind;
  (function(DocumentHighlightKind2) {
    DocumentHighlightKind2.Text = 1;
    DocumentHighlightKind2.Read = 2;
    DocumentHighlightKind2.Write = 3;
  })(DocumentHighlightKind || (DocumentHighlightKind = {}));
  var DocumentHighlight;
  (function(DocumentHighlight2) {
    function create(range, kind) {
      var result = {range};
      if (Is.number(kind)) {
        result.kind = kind;
      }
      return result;
    }
    DocumentHighlight2.create = create;
  })(DocumentHighlight || (DocumentHighlight = {}));
  var SymbolKind;
  (function(SymbolKind2) {
    SymbolKind2.File = 1;
    SymbolKind2.Module = 2;
    SymbolKind2.Namespace = 3;
    SymbolKind2.Package = 4;
    SymbolKind2.Class = 5;
    SymbolKind2.Method = 6;
    SymbolKind2.Property = 7;
    SymbolKind2.Field = 8;
    SymbolKind2.Constructor = 9;
    SymbolKind2.Enum = 10;
    SymbolKind2.Interface = 11;
    SymbolKind2.Function = 12;
    SymbolKind2.Variable = 13;
    SymbolKind2.Constant = 14;
    SymbolKind2.String = 15;
    SymbolKind2.Number = 16;
    SymbolKind2.Boolean = 17;
    SymbolKind2.Array = 18;
    SymbolKind2.Object = 19;
    SymbolKind2.Key = 20;
    SymbolKind2.Null = 21;
    SymbolKind2.EnumMember = 22;
    SymbolKind2.Struct = 23;
    SymbolKind2.Event = 24;
    SymbolKind2.Operator = 25;
    SymbolKind2.TypeParameter = 26;
  })(SymbolKind || (SymbolKind = {}));
  var SymbolTag;
  (function(SymbolTag2) {
    SymbolTag2.Deprecated = 1;
  })(SymbolTag || (SymbolTag = {}));
  var SymbolInformation;
  (function(SymbolInformation2) {
    function create(name, kind, range, uri, containerName) {
      var result = {
        name,
        kind,
        location: {uri, range}
      };
      if (containerName) {
        result.containerName = containerName;
      }
      return result;
    }
    SymbolInformation2.create = create;
  })(SymbolInformation || (SymbolInformation = {}));
  var DocumentSymbol;
  (function(DocumentSymbol2) {
    function create(name, detail, kind, range, selectionRange, children) {
      var result = {
        name,
        detail,
        kind,
        range,
        selectionRange
      };
      if (children !== void 0) {
        result.children = children;
      }
      return result;
    }
    DocumentSymbol2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range5.is(candidate.range) && Range5.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
    }
    DocumentSymbol2.is = is;
  })(DocumentSymbol || (DocumentSymbol = {}));
  var CodeActionKind;
  (function(CodeActionKind2) {
    CodeActionKind2.Empty = "";
    CodeActionKind2.QuickFix = "quickfix";
    CodeActionKind2.Refactor = "refactor";
    CodeActionKind2.RefactorExtract = "refactor.extract";
    CodeActionKind2.RefactorInline = "refactor.inline";
    CodeActionKind2.RefactorRewrite = "refactor.rewrite";
    CodeActionKind2.Source = "source";
    CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
    CodeActionKind2.SourceFixAll = "source.fixAll";
  })(CodeActionKind || (CodeActionKind = {}));
  var CodeActionContext2;
  (function(CodeActionContext3) {
    function create(diagnostics, only) {
      var result = {diagnostics};
      if (only !== void 0 && only !== null) {
        result.only = only;
      }
      return result;
    }
    CodeActionContext3.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext3.is = is;
  })(CodeActionContext2 || (CodeActionContext2 = {}));
  var CodeAction2;
  (function(CodeAction3) {
    function create(title, kindOrCommandOrEdit, kind) {
      var result = {title};
      var checkKind = true;
      if (typeof kindOrCommandOrEdit === "string") {
        checkKind = false;
        result.kind = kindOrCommandOrEdit;
      } else if (Command.is(kindOrCommandOrEdit)) {
        result.command = kindOrCommandOrEdit;
      } else {
        result.edit = kindOrCommandOrEdit;
      }
      if (checkKind && kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    CodeAction3.create = create;
    function is(value) {
      var candidate = value;
      return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction3.is = is;
  })(CodeAction2 || (CodeAction2 = {}));
  var CodeLens;
  (function(CodeLens2) {
    function create(range, data) {
      var result = {range};
      if (Is.defined(data)) {
        result.data = data;
      }
      return result;
    }
    CodeLens2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range5.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens2.is = is;
  })(CodeLens || (CodeLens = {}));
  var FormattingOptions;
  (function(FormattingOptions2) {
    function create(tabSize, insertSpaces) {
      return {tabSize, insertSpaces};
    }
    FormattingOptions2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions2.is = is;
  })(FormattingOptions || (FormattingOptions = {}));
  var DocumentLink;
  (function(DocumentLink2) {
    function create(range, target, data) {
      return {range, target, data};
    }
    DocumentLink2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range5.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink2.is = is;
  })(DocumentLink || (DocumentLink = {}));
  var SelectionRange;
  (function(SelectionRange2) {
    function create(range, parent) {
      return {range, parent};
    }
    SelectionRange2.create = create;
    function is(value) {
      var candidate = value;
      return candidate !== void 0 && Range5.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
    }
    SelectionRange2.is = is;
  })(SelectionRange || (SelectionRange = {}));
  var SemanticTokenTypes;
  (function(SemanticTokenTypes2) {
    SemanticTokenTypes2["namespace"] = "namespace";
    SemanticTokenTypes2["type"] = "type";
    SemanticTokenTypes2["class"] = "class";
    SemanticTokenTypes2["enum"] = "enum";
    SemanticTokenTypes2["interface"] = "interface";
    SemanticTokenTypes2["struct"] = "struct";
    SemanticTokenTypes2["typeParameter"] = "typeParameter";
    SemanticTokenTypes2["parameter"] = "parameter";
    SemanticTokenTypes2["variable"] = "variable";
    SemanticTokenTypes2["property"] = "property";
    SemanticTokenTypes2["enumMember"] = "enumMember";
    SemanticTokenTypes2["event"] = "event";
    SemanticTokenTypes2["function"] = "function";
    SemanticTokenTypes2["method"] = "method";
    SemanticTokenTypes2["macro"] = "macro";
    SemanticTokenTypes2["keyword"] = "keyword";
    SemanticTokenTypes2["modifier"] = "modifier";
    SemanticTokenTypes2["comment"] = "comment";
    SemanticTokenTypes2["string"] = "string";
    SemanticTokenTypes2["number"] = "number";
    SemanticTokenTypes2["regexp"] = "regexp";
    SemanticTokenTypes2["operator"] = "operator";
  })(SemanticTokenTypes || (SemanticTokenTypes = {}));
  var SemanticTokenModifiers;
  (function(SemanticTokenModifiers2) {
    SemanticTokenModifiers2["declaration"] = "declaration";
    SemanticTokenModifiers2["definition"] = "definition";
    SemanticTokenModifiers2["readonly"] = "readonly";
    SemanticTokenModifiers2["static"] = "static";
    SemanticTokenModifiers2["deprecated"] = "deprecated";
    SemanticTokenModifiers2["abstract"] = "abstract";
    SemanticTokenModifiers2["async"] = "async";
    SemanticTokenModifiers2["modification"] = "modification";
    SemanticTokenModifiers2["documentation"] = "documentation";
    SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
  })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
  var SemanticTokens;
  (function(SemanticTokens2) {
    function is(value) {
      var candidate = value;
      return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
    }
    SemanticTokens2.is = is;
  })(SemanticTokens || (SemanticTokens = {}));
  var EOL = ["\n", "\r\n", "\r"];
  var TextDocument4;
  (function(TextDocument5) {
    function create(uri, languageId, version, content) {
      return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument5.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument5.is = is;
    function applyEdits(document2, edits) {
      var text = document2.getText();
      var sortedEdits = mergeSort(edits, function(a, b) {
        var diff = a.range.start.line - b.range.start.line;
        if (diff === 0) {
          return a.range.start.character - b.range.start.character;
        }
        return diff;
      });
      var lastModifiedOffset = text.length;
      for (var i = sortedEdits.length - 1; i >= 0; i--) {
        var e = sortedEdits[i];
        var startOffset = document2.offsetAt(e.range.start);
        var endOffset = document2.offsetAt(e.range.end);
        if (endOffset <= lastModifiedOffset) {
          text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
        } else {
          throw new Error("Overlapping edit");
        }
        lastModifiedOffset = startOffset;
      }
      return text;
    }
    TextDocument5.applyEdits = applyEdits;
    function mergeSort(data, compare) {
      if (data.length <= 1) {
        return data;
      }
      var p = data.length / 2 | 0;
      var left = data.slice(0, p);
      var right = data.slice(p);
      mergeSort(left, compare);
      mergeSort(right, compare);
      var leftIdx = 0;
      var rightIdx = 0;
      var i = 0;
      while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
          data[i++] = left[leftIdx++];
        } else {
          data[i++] = right[rightIdx++];
        }
      }
      while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
      }
      while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
      }
      return data;
    }
  })(TextDocument4 || (TextDocument4 = {}));
  var FullTextDocument = function() {
    function FullTextDocument2(uri, languageId, version, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version;
      this._content = content;
      this._lineOffsets = void 0;
    }
    Object.defineProperty(FullTextDocument2.prototype, "uri", {
      get: function() {
        return this._uri;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FullTextDocument2.prototype, "languageId", {
      get: function() {
        return this._languageId;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FullTextDocument2.prototype, "version", {
      get: function() {
        return this._version;
      },
      enumerable: false,
      configurable: true
    });
    FullTextDocument2.prototype.getText = function(range) {
      if (range) {
        var start = this.offsetAt(range.start);
        var end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    };
    FullTextDocument2.prototype.update = function(event, version) {
      this._content = event.text;
      this._version = version;
      this._lineOffsets = void 0;
    };
    FullTextDocument2.prototype.getLineOffsets = function() {
      if (this._lineOffsets === void 0) {
        var lineOffsets = [];
        var text = this._content;
        var isLineStart = true;
        for (var i = 0; i < text.length; i++) {
          if (isLineStart) {
            lineOffsets.push(i);
            isLineStart = false;
          }
          var ch = text.charAt(i);
          isLineStart = ch === "\r" || ch === "\n";
          if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
            i++;
          }
        }
        if (isLineStart && text.length > 0) {
          lineOffsets.push(text.length);
        }
        this._lineOffsets = lineOffsets;
      }
      return this._lineOffsets;
    };
    FullTextDocument2.prototype.positionAt = function(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      var lineOffsets = this.getLineOffsets();
      var low = 0, high = lineOffsets.length;
      if (high === 0) {
        return Position8.create(0, offset);
      }
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      var line = low - 1;
      return Position8.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument2.prototype.offsetAt = function(position) {
      var lineOffsets = this.getLineOffsets();
      if (position.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position.line < 0) {
        return 0;
      }
      var lineOffset = lineOffsets[position.line];
      var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
      get: function() {
        return this.getLineOffsets().length;
      },
      enumerable: false,
      configurable: true
    });
    return FullTextDocument2;
  }();
  var Is;
  (function(Is2) {
    var toString = Object.prototype.toString;
    function defined(value) {
      return typeof value !== "undefined";
    }
    Is2.defined = defined;
    function undefined2(value) {
      return typeof value === "undefined";
    }
    Is2.undefined = undefined2;
    function boolean(value) {
      return value === true || value === false;
    }
    Is2.boolean = boolean;
    function string(value) {
      return toString.call(value) === "[object String]";
    }
    Is2.string = string;
    function number(value) {
      return toString.call(value) === "[object Number]";
    }
    Is2.number = number;
    function numberRange(value, min, max) {
      return toString.call(value) === "[object Number]" && min <= value && value <= max;
    }
    Is2.numberRange = numberRange;
    function integer2(value) {
      return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
    }
    Is2.integer = integer2;
    function uinteger2(value) {
      return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
    }
    Is2.uinteger = uinteger2;
    function func(value) {
      return toString.call(value) === "[object Function]";
    }
    Is2.func = func;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    Is2.objectLiteral = objectLiteral;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    Is2.typedArray = typedArray;
  })(Is || (Is = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = void 0;
  var vscode_jsonrpc_1 = require_main2();
  var RegistrationType = class {
    constructor(method) {
      this.method = method;
    }
  };
  exports2.RegistrationType = RegistrationType;
  var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolRequestType0 = ProtocolRequestType0;
  var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
      super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
  };
  exports2.ProtocolRequestType = ProtocolRequestType;
  var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
  var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
      super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
  };
  exports2.ProtocolNotificationType = ProtocolNotificationType;
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
  function boolean(value) {
    return value === true || value === false;
  }
  exports2.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports2.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports2.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports2.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports2.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports2.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string(elem));
  }
  exports2.stringArray = stringArray;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  exports2.typedArray = typedArray;
  function objectLiteral(value) {
    return value !== null && typeof value === "object";
  }
  exports2.objectLiteral = objectLiteral;
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ImplementationRequest = void 0;
  var messages_1 = require_messages3();
  var ImplementationRequest;
  (function(ImplementationRequest2) {
    ImplementationRequest2.method = "textDocument/implementation";
    ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
  })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.TypeDefinitionRequest = void 0;
  var messages_1 = require_messages3();
  var TypeDefinitionRequest;
  (function(TypeDefinitionRequest2) {
    TypeDefinitionRequest2.method = "textDocument/typeDefinition";
    TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
  })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
  var messages_1 = require_messages3();
  var WorkspaceFoldersRequest;
  (function(WorkspaceFoldersRequest2) {
    WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
  })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
  var DidChangeWorkspaceFoldersNotification;
  (function(DidChangeWorkspaceFoldersNotification2) {
    DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
  })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ConfigurationRequest = void 0;
  var messages_1 = require_messages3();
  var ConfigurationRequest;
  (function(ConfigurationRequest2) {
    ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
  })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
  var messages_1 = require_messages3();
  var DocumentColorRequest;
  (function(DocumentColorRequest2) {
    DocumentColorRequest2.method = "textDocument/documentColor";
    DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
  })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
  var ColorPresentationRequest;
  (function(ColorPresentationRequest2) {
    ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
  })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.FoldingRangeRequest = exports2.FoldingRangeKind = void 0;
  var messages_1 = require_messages3();
  var FoldingRangeKind;
  (function(FoldingRangeKind2) {
    FoldingRangeKind2["Comment"] = "comment";
    FoldingRangeKind2["Imports"] = "imports";
    FoldingRangeKind2["Region"] = "region";
  })(FoldingRangeKind = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
  var FoldingRangeRequest;
  (function(FoldingRangeRequest2) {
    FoldingRangeRequest2.method = "textDocument/foldingRange";
    FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
  })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DeclarationRequest = void 0;
  var messages_1 = require_messages3();
  var DeclarationRequest;
  (function(DeclarationRequest2) {
    DeclarationRequest2.method = "textDocument/declaration";
    DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
  })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SelectionRangeRequest = void 0;
  var messages_1 = require_messages3();
  var SelectionRangeRequest;
  (function(SelectionRangeRequest2) {
    SelectionRangeRequest2.method = "textDocument/selectionRange";
    SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
  })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
  var vscode_jsonrpc_1 = require_main2();
  var messages_1 = require_messages3();
  var WorkDoneProgress;
  (function(WorkDoneProgress2) {
    WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
      return value === WorkDoneProgress2.type;
    }
    WorkDoneProgress2.is = is;
  })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
  var WorkDoneProgressCreateRequest;
  (function(WorkDoneProgressCreateRequest2) {
    WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
  })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
  var WorkDoneProgressCancelNotification;
  (function(WorkDoneProgressCancelNotification2) {
    WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
  })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
  var messages_1 = require_messages3();
  var CallHierarchyPrepareRequest;
  (function(CallHierarchyPrepareRequest2) {
    CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
    CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
  })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
  var CallHierarchyIncomingCallsRequest;
  (function(CallHierarchyIncomingCallsRequest2) {
    CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
    CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
  })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
  var CallHierarchyOutgoingCallsRequest;
  (function(CallHierarchyOutgoingCallsRequest2) {
    CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
    CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
  })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
  var messages_1 = require_messages3();
  var TokenFormat;
  (function(TokenFormat2) {
    TokenFormat2.Relative = "relative";
  })(TokenFormat = exports2.TokenFormat || (exports2.TokenFormat = {}));
  var SemanticTokensRegistrationType;
  (function(SemanticTokensRegistrationType2) {
    SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
    SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
  })(SemanticTokensRegistrationType = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
  var SemanticTokensRequest;
  (function(SemanticTokensRequest2) {
    SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
    SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
  })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
  var SemanticTokensDeltaRequest;
  (function(SemanticTokensDeltaRequest2) {
    SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
    SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
  })(SemanticTokensDeltaRequest = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
  var SemanticTokensRangeRequest;
  (function(SemanticTokensRangeRequest2) {
    SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
    SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
  })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
  var SemanticTokensRefreshRequest;
  (function(SemanticTokensRefreshRequest2) {
    SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
  })(SemanticTokensRefreshRequest = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ShowDocumentRequest = void 0;
  var messages_1 = require_messages3();
  var ShowDocumentRequest;
  (function(ShowDocumentRequest2) {
    ShowDocumentRequest2.method = "window/showDocument";
    ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
  })(ShowDocumentRequest = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.LinkedEditingRangeRequest = void 0;
  var messages_1 = require_messages3();
  var LinkedEditingRangeRequest;
  (function(LinkedEditingRangeRequest2) {
    LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
    LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
  })(LinkedEditingRangeRequest = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
  var messages_1 = require_messages3();
  var FileOperationPatternKind;
  (function(FileOperationPatternKind2) {
    FileOperationPatternKind2.file = "file";
    FileOperationPatternKind2.folder = "folder";
  })(FileOperationPatternKind = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
  var WillCreateFilesRequest;
  (function(WillCreateFilesRequest2) {
    WillCreateFilesRequest2.method = "workspace/willCreateFiles";
    WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
  })(WillCreateFilesRequest = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
  var DidCreateFilesNotification;
  (function(DidCreateFilesNotification2) {
    DidCreateFilesNotification2.method = "workspace/didCreateFiles";
    DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
  })(DidCreateFilesNotification = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
  var WillRenameFilesRequest;
  (function(WillRenameFilesRequest2) {
    WillRenameFilesRequest2.method = "workspace/willRenameFiles";
    WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
  })(WillRenameFilesRequest = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
  var DidRenameFilesNotification;
  (function(DidRenameFilesNotification2) {
    DidRenameFilesNotification2.method = "workspace/didRenameFiles";
    DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
  })(DidRenameFilesNotification = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
  var DidDeleteFilesNotification;
  (function(DidDeleteFilesNotification2) {
    DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
    DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
  })(DidDeleteFilesNotification = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
  var WillDeleteFilesRequest;
  (function(WillDeleteFilesRequest2) {
    WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
    WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
  })(WillDeleteFilesRequest = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
  var messages_1 = require_messages3();
  var UniquenessLevel;
  (function(UniquenessLevel2) {
    UniquenessLevel2["document"] = "document";
    UniquenessLevel2["project"] = "project";
    UniquenessLevel2["group"] = "group";
    UniquenessLevel2["scheme"] = "scheme";
    UniquenessLevel2["global"] = "global";
  })(UniquenessLevel = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
  var MonikerKind;
  (function(MonikerKind2) {
    MonikerKind2["import"] = "import";
    MonikerKind2["export"] = "export";
    MonikerKind2["local"] = "local";
  })(MonikerKind = exports2.MonikerKind || (exports2.MonikerKind = {}));
  var MonikerRequest;
  (function(MonikerRequest2) {
    MonikerRequest2.method = "textDocument/moniker";
    MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
  })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeError = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.DocumentFilter = void 0;
  exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = void 0;
  var messages_1 = require_messages3();
  var Is = require_is3();
  var protocol_implementation_1 = require_protocol_implementation();
  Object.defineProperty(exports2, "ImplementationRequest", {enumerable: true, get: function() {
    return protocol_implementation_1.ImplementationRequest;
  }});
  var protocol_typeDefinition_1 = require_protocol_typeDefinition();
  Object.defineProperty(exports2, "TypeDefinitionRequest", {enumerable: true, get: function() {
    return protocol_typeDefinition_1.TypeDefinitionRequest;
  }});
  var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
  Object.defineProperty(exports2, "WorkspaceFoldersRequest", {enumerable: true, get: function() {
    return protocol_workspaceFolders_1.WorkspaceFoldersRequest;
  }});
  Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", {enumerable: true, get: function() {
    return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
  }});
  var protocol_configuration_1 = require_protocol_configuration();
  Object.defineProperty(exports2, "ConfigurationRequest", {enumerable: true, get: function() {
    return protocol_configuration_1.ConfigurationRequest;
  }});
  var protocol_colorProvider_1 = require_protocol_colorProvider();
  Object.defineProperty(exports2, "DocumentColorRequest", {enumerable: true, get: function() {
    return protocol_colorProvider_1.DocumentColorRequest;
  }});
  Object.defineProperty(exports2, "ColorPresentationRequest", {enumerable: true, get: function() {
    return protocol_colorProvider_1.ColorPresentationRequest;
  }});
  var protocol_foldingRange_1 = require_protocol_foldingRange();
  Object.defineProperty(exports2, "FoldingRangeRequest", {enumerable: true, get: function() {
    return protocol_foldingRange_1.FoldingRangeRequest;
  }});
  var protocol_declaration_1 = require_protocol_declaration();
  Object.defineProperty(exports2, "DeclarationRequest", {enumerable: true, get: function() {
    return protocol_declaration_1.DeclarationRequest;
  }});
  var protocol_selectionRange_1 = require_protocol_selectionRange();
  Object.defineProperty(exports2, "SelectionRangeRequest", {enumerable: true, get: function() {
    return protocol_selectionRange_1.SelectionRangeRequest;
  }});
  var protocol_progress_1 = require_protocol_progress();
  Object.defineProperty(exports2, "WorkDoneProgress", {enumerable: true, get: function() {
    return protocol_progress_1.WorkDoneProgress;
  }});
  Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", {enumerable: true, get: function() {
    return protocol_progress_1.WorkDoneProgressCreateRequest;
  }});
  Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", {enumerable: true, get: function() {
    return protocol_progress_1.WorkDoneProgressCancelNotification;
  }});
  var protocol_callHierarchy_1 = require_protocol_callHierarchy();
  Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", {enumerable: true, get: function() {
    return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
  }});
  Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", {enumerable: true, get: function() {
    return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
  }});
  Object.defineProperty(exports2, "CallHierarchyPrepareRequest", {enumerable: true, get: function() {
    return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
  }});
  var protocol_semanticTokens_1 = require_protocol_semanticTokens();
  Object.defineProperty(exports2, "TokenFormat", {enumerable: true, get: function() {
    return protocol_semanticTokens_1.TokenFormat;
  }});
  Object.defineProperty(exports2, "SemanticTokensRequest", {enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensRequest;
  }});
  Object.defineProperty(exports2, "SemanticTokensDeltaRequest", {enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
  }});
  Object.defineProperty(exports2, "SemanticTokensRangeRequest", {enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensRangeRequest;
  }});
  Object.defineProperty(exports2, "SemanticTokensRefreshRequest", {enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
  }});
  Object.defineProperty(exports2, "SemanticTokensRegistrationType", {enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensRegistrationType;
  }});
  var protocol_showDocument_1 = require_protocol_showDocument();
  Object.defineProperty(exports2, "ShowDocumentRequest", {enumerable: true, get: function() {
    return protocol_showDocument_1.ShowDocumentRequest;
  }});
  var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
  Object.defineProperty(exports2, "LinkedEditingRangeRequest", {enumerable: true, get: function() {
    return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
  }});
  var protocol_fileOperations_1 = require_protocol_fileOperations();
  Object.defineProperty(exports2, "FileOperationPatternKind", {enumerable: true, get: function() {
    return protocol_fileOperations_1.FileOperationPatternKind;
  }});
  Object.defineProperty(exports2, "DidCreateFilesNotification", {enumerable: true, get: function() {
    return protocol_fileOperations_1.DidCreateFilesNotification;
  }});
  Object.defineProperty(exports2, "WillCreateFilesRequest", {enumerable: true, get: function() {
    return protocol_fileOperations_1.WillCreateFilesRequest;
  }});
  Object.defineProperty(exports2, "DidRenameFilesNotification", {enumerable: true, get: function() {
    return protocol_fileOperations_1.DidRenameFilesNotification;
  }});
  Object.defineProperty(exports2, "WillRenameFilesRequest", {enumerable: true, get: function() {
    return protocol_fileOperations_1.WillRenameFilesRequest;
  }});
  Object.defineProperty(exports2, "DidDeleteFilesNotification", {enumerable: true, get: function() {
    return protocol_fileOperations_1.DidDeleteFilesNotification;
  }});
  Object.defineProperty(exports2, "WillDeleteFilesRequest", {enumerable: true, get: function() {
    return protocol_fileOperations_1.WillDeleteFilesRequest;
  }});
  var protocol_moniker_1 = require_protocol_moniker();
  Object.defineProperty(exports2, "UniquenessLevel", {enumerable: true, get: function() {
    return protocol_moniker_1.UniquenessLevel;
  }});
  Object.defineProperty(exports2, "MonikerKind", {enumerable: true, get: function() {
    return protocol_moniker_1.MonikerKind;
  }});
  Object.defineProperty(exports2, "MonikerRequest", {enumerable: true, get: function() {
    return protocol_moniker_1.MonikerRequest;
  }});
  var DocumentFilter;
  (function(DocumentFilter2) {
    function is(value) {
      const candidate = value;
      return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter2.is = is;
  })(DocumentFilter = exports2.DocumentFilter || (exports2.DocumentFilter = {}));
  var DocumentSelector2;
  (function(DocumentSelector3) {
    function is(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (let elem of value) {
        if (!Is.string(elem) && !DocumentFilter.is(elem)) {
          return false;
        }
      }
      return true;
    }
    DocumentSelector3.is = is;
  })(DocumentSelector2 = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
  var RegistrationRequest;
  (function(RegistrationRequest2) {
    RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
  })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
  var UnregistrationRequest;
  (function(UnregistrationRequest2) {
    UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
  })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
  var ResourceOperationKind;
  (function(ResourceOperationKind2) {
    ResourceOperationKind2.Create = "create";
    ResourceOperationKind2.Rename = "rename";
    ResourceOperationKind2.Delete = "delete";
  })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
  var FailureHandlingKind;
  (function(FailureHandlingKind2) {
    FailureHandlingKind2.Abort = "abort";
    FailureHandlingKind2.Transactional = "transactional";
    FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
    FailureHandlingKind2.Undo = "undo";
  })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
  var StaticRegistrationOptions;
  (function(StaticRegistrationOptions2) {
    function hasId(value) {
      const candidate = value;
      return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions2.hasId = hasId;
  })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
  var TextDocumentRegistrationOptions;
  (function(TextDocumentRegistrationOptions2) {
    function is(value) {
      const candidate = value;
      return candidate && (candidate.documentSelector === null || DocumentSelector2.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions2.is = is;
  })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
  var WorkDoneProgressOptions;
  (function(WorkDoneProgressOptions2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions2.is = is;
    function hasWorkDoneProgress(value) {
      const candidate = value;
      return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
  })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
  var InitializeRequest;
  (function(InitializeRequest2) {
    InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
  })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
  var InitializeError;
  (function(InitializeError2) {
    InitializeError2.unknownProtocolVersion = 1;
  })(InitializeError = exports2.InitializeError || (exports2.InitializeError = {}));
  var InitializedNotification;
  (function(InitializedNotification2) {
    InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
  })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
  var ShutdownRequest;
  (function(ShutdownRequest2) {
    ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
  })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
  var ExitNotification;
  (function(ExitNotification2) {
    ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
  })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
  var DidChangeConfigurationNotification;
  (function(DidChangeConfigurationNotification2) {
    DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
  })(DidChangeConfigurationNotification = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2.Error = 1;
    MessageType2.Warning = 2;
    MessageType2.Info = 3;
    MessageType2.Log = 4;
  })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
  var ShowMessageNotification;
  (function(ShowMessageNotification2) {
    ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
  })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
  var ShowMessageRequest;
  (function(ShowMessageRequest2) {
    ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
  })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
  var LogMessageNotification;
  (function(LogMessageNotification2) {
    LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
  })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
  var TelemetryEventNotification;
  (function(TelemetryEventNotification2) {
    TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
  })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
  var TextDocumentSyncKind;
  (function(TextDocumentSyncKind2) {
    TextDocumentSyncKind2.None = 0;
    TextDocumentSyncKind2.Full = 1;
    TextDocumentSyncKind2.Incremental = 2;
  })(TextDocumentSyncKind = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
  var DidOpenTextDocumentNotification;
  (function(DidOpenTextDocumentNotification2) {
    DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
    DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
  })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
  var TextDocumentContentChangeEvent3;
  (function(TextDocumentContentChangeEvent4) {
    function isIncremental(event) {
      let candidate = event;
      return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
    }
    TextDocumentContentChangeEvent4.isIncremental = isIncremental;
    function isFull(event) {
      let candidate = event;
      return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
    }
    TextDocumentContentChangeEvent4.isFull = isFull;
  })(TextDocumentContentChangeEvent3 = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
  var DidChangeTextDocumentNotification;
  (function(DidChangeTextDocumentNotification2) {
    DidChangeTextDocumentNotification2.method = "textDocument/didChange";
    DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
  })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
  var DidCloseTextDocumentNotification;
  (function(DidCloseTextDocumentNotification2) {
    DidCloseTextDocumentNotification2.method = "textDocument/didClose";
    DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
  })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
  var DidSaveTextDocumentNotification;
  (function(DidSaveTextDocumentNotification2) {
    DidSaveTextDocumentNotification2.method = "textDocument/didSave";
    DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
  })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
  var TextDocumentSaveReason;
  (function(TextDocumentSaveReason2) {
    TextDocumentSaveReason2.Manual = 1;
    TextDocumentSaveReason2.AfterDelay = 2;
    TextDocumentSaveReason2.FocusOut = 3;
  })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
  var WillSaveTextDocumentNotification;
  (function(WillSaveTextDocumentNotification2) {
    WillSaveTextDocumentNotification2.method = "textDocument/willSave";
    WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
  })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
  var WillSaveTextDocumentWaitUntilRequest;
  (function(WillSaveTextDocumentWaitUntilRequest2) {
    WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
    WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
  })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
  var DidChangeWatchedFilesNotification;
  (function(DidChangeWatchedFilesNotification2) {
    DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
  })(DidChangeWatchedFilesNotification = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
  var FileChangeType;
  (function(FileChangeType2) {
    FileChangeType2.Created = 1;
    FileChangeType2.Changed = 2;
    FileChangeType2.Deleted = 3;
  })(FileChangeType = exports2.FileChangeType || (exports2.FileChangeType = {}));
  var WatchKind;
  (function(WatchKind2) {
    WatchKind2.Create = 1;
    WatchKind2.Change = 2;
    WatchKind2.Delete = 4;
  })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
  var PublishDiagnosticsNotification;
  (function(PublishDiagnosticsNotification2) {
    PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
  })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
  var CompletionTriggerKind;
  (function(CompletionTriggerKind2) {
    CompletionTriggerKind2.Invoked = 1;
    CompletionTriggerKind2.TriggerCharacter = 2;
    CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
  })(CompletionTriggerKind = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
  var CompletionRequest;
  (function(CompletionRequest2) {
    CompletionRequest2.method = "textDocument/completion";
    CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
  })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
  var CompletionResolveRequest;
  (function(CompletionResolveRequest2) {
    CompletionResolveRequest2.method = "completionItem/resolve";
    CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
  })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
  var HoverRequest;
  (function(HoverRequest2) {
    HoverRequest2.method = "textDocument/hover";
    HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
  })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
  var SignatureHelpTriggerKind;
  (function(SignatureHelpTriggerKind2) {
    SignatureHelpTriggerKind2.Invoked = 1;
    SignatureHelpTriggerKind2.TriggerCharacter = 2;
    SignatureHelpTriggerKind2.ContentChange = 3;
  })(SignatureHelpTriggerKind = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
  var SignatureHelpRequest;
  (function(SignatureHelpRequest2) {
    SignatureHelpRequest2.method = "textDocument/signatureHelp";
    SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
  })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
  var DefinitionRequest;
  (function(DefinitionRequest2) {
    DefinitionRequest2.method = "textDocument/definition";
    DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
  })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
  var ReferencesRequest;
  (function(ReferencesRequest2) {
    ReferencesRequest2.method = "textDocument/references";
    ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
  })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
  var DocumentHighlightRequest;
  (function(DocumentHighlightRequest2) {
    DocumentHighlightRequest2.method = "textDocument/documentHighlight";
    DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
  })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
  var DocumentSymbolRequest;
  (function(DocumentSymbolRequest2) {
    DocumentSymbolRequest2.method = "textDocument/documentSymbol";
    DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
  })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
  var CodeActionRequest;
  (function(CodeActionRequest2) {
    CodeActionRequest2.method = "textDocument/codeAction";
    CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
  })(CodeActionRequest = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
  var CodeActionResolveRequest;
  (function(CodeActionResolveRequest2) {
    CodeActionResolveRequest2.method = "codeAction/resolve";
    CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
  })(CodeActionResolveRequest = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
  var WorkspaceSymbolRequest;
  (function(WorkspaceSymbolRequest2) {
    WorkspaceSymbolRequest2.method = "workspace/symbol";
    WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
  })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
  var CodeLensRequest;
  (function(CodeLensRequest2) {
    CodeLensRequest2.method = "textDocument/codeLens";
    CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
  })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
  var CodeLensResolveRequest;
  (function(CodeLensResolveRequest2) {
    CodeLensResolveRequest2.method = "codeLens/resolve";
    CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
  })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
  var CodeLensRefreshRequest;
  (function(CodeLensRefreshRequest2) {
    CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
  })(CodeLensRefreshRequest = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
  var DocumentLinkRequest;
  (function(DocumentLinkRequest2) {
    DocumentLinkRequest2.method = "textDocument/documentLink";
    DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
  })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
  var DocumentLinkResolveRequest;
  (function(DocumentLinkResolveRequest2) {
    DocumentLinkResolveRequest2.method = "documentLink/resolve";
    DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
  })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
  var DocumentFormattingRequest;
  (function(DocumentFormattingRequest2) {
    DocumentFormattingRequest2.method = "textDocument/formatting";
    DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
  })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
  var DocumentRangeFormattingRequest;
  (function(DocumentRangeFormattingRequest2) {
    DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
    DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
  })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
  var DocumentOnTypeFormattingRequest;
  (function(DocumentOnTypeFormattingRequest2) {
    DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
    DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
  })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
  var PrepareSupportDefaultBehavior;
  (function(PrepareSupportDefaultBehavior2) {
    PrepareSupportDefaultBehavior2.Identifier = 1;
  })(PrepareSupportDefaultBehavior = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
  var RenameRequest;
  (function(RenameRequest2) {
    RenameRequest2.method = "textDocument/rename";
    RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
  })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
  var PrepareRenameRequest;
  (function(PrepareRenameRequest2) {
    PrepareRenameRequest2.method = "textDocument/prepareRename";
    PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
  })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
  var ExecuteCommandRequest;
  (function(ExecuteCommandRequest2) {
    ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
  })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
  var ApplyWorkspaceEditRequest;
  (function(ApplyWorkspaceEditRequest2) {
    ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
  })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createProtocolConnection = void 0;
  var vscode_jsonrpc_1 = require_main2();
  function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
      options = {connectionStrategy: options};
    }
    return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
  }
  exports2.createProtocolConnection = createProtocolConnection;
});

// node_modules/vscode-languageserver-protocol/lib/common/proposed.diagnostic.js
var require_proposed_diagnostic = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
  var vscode_jsonrpc_1 = require_main2();
  var Is = require_is3();
  var messages_1 = require_messages3();
  var DiagnosticServerCancellationData;
  (function(DiagnosticServerCancellationData2) {
    function is(value) {
      const candidate = value;
      return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData2.is = is;
  })(DiagnosticServerCancellationData = exports2.DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = {}));
  var DocumentDiagnosticReportKind;
  (function(DocumentDiagnosticReportKind2) {
    DocumentDiagnosticReportKind2["full"] = "full";
    DocumentDiagnosticReportKind2["unChanged"] = "unChanged";
  })(DocumentDiagnosticReportKind = exports2.DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = {}));
  var DocumentDiagnosticRequest;
  (function(DocumentDiagnosticRequest2) {
    DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
    DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
    DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
  })(DocumentDiagnosticRequest = exports2.DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = {}));
  var WorkspaceDiagnosticRequest;
  (function(WorkspaceDiagnosticRequest2) {
    WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
    WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
    WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
  })(WorkspaceDiagnosticRequest = exports2.WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = {}));
  var DiagnosticRefreshRequest;
  (function(DiagnosticRefreshRequest2) {
    DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
  })(DiagnosticRefreshRequest = exports2.DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api3 = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Proposed = exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
  __exportStar2(require_main2(), exports2);
  __exportStar2(require_main3(), exports2);
  __exportStar2(require_messages3(), exports2);
  __exportStar2(require_protocol(), exports2);
  var connection_1 = require_connection3();
  Object.defineProperty(exports2, "createProtocolConnection", {enumerable: true, get: function() {
    return connection_1.createProtocolConnection;
  }});
  var LSPErrorCodes;
  (function(LSPErrorCodes2) {
    LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
    LSPErrorCodes2.ServerCancelled = -32802;
    LSPErrorCodes2.ContentModified = -32801;
    LSPErrorCodes2.RequestCancelled = -32800;
    LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
  })(LSPErrorCodes = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
  var diag = require_proposed_diagnostic();
  var Proposed;
  (function(Proposed2) {
    Proposed2.DiagnosticServerCancellationData = diag.DiagnosticServerCancellationData;
    Proposed2.DocumentDiagnosticReportKind = diag.DocumentDiagnosticReportKind;
    Proposed2.DocumentDiagnosticRequest = diag.DocumentDiagnosticRequest;
    Proposed2.WorkspaceDiagnosticRequest = diag.WorkspaceDiagnosticRequest;
    Proposed2.DiagnosticRefreshRequest = diag.DiagnosticRefreshRequest;
  })(Proposed = exports2.Proposed || (exports2.Proposed = {}));
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main4 = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createProtocolConnection = void 0;
  var node_1 = require_node();
  __exportStar2(require_node(), exports2);
  __exportStar2(require_api3(), exports2);
  function createProtocolConnection(input, output, logger, options) {
    return node_1.createMessageConnection(input, output, logger, options);
  }
  exports2.createProtocolConnection = createProtocolConnection;
});

// node_modules/@vue/shared/dist/shared.esm-bundler.js
var require_shared_esm_bundler = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    EMPTY_ARR: () => EMPTY_ARR,
    EMPTY_OBJ: () => EMPTY_OBJ,
    NO: () => NO,
    NOOP: () => NOOP2,
    PatchFlagNames: () => PatchFlagNames,
    babelParserDefaultPlugins: () => babelParserDefaultPlugins,
    camelize: () => camelize,
    capitalize: () => capitalize2,
    def: () => def2,
    escapeHtml: () => escapeHtml,
    escapeHtmlComment: () => escapeHtmlComment,
    extend: () => extend2,
    generateCodeFrame: () => generateCodeFrame,
    getGlobalThis: () => getGlobalThis,
    hasChanged: () => hasChanged2,
    hasOwn: () => hasOwn2,
    hyphenate: () => hyphenate,
    includeBooleanAttr: () => includeBooleanAttr,
    invokeArrayFns: () => invokeArrayFns,
    isArray: () => isArray2,
    isBooleanAttr: () => isBooleanAttr,
    isDate: () => isDate,
    isFunction: () => isFunction2,
    isGloballyWhitelisted: () => isGloballyWhitelisted,
    isHTMLTag: () => isHTMLTag,
    isIntegerKey: () => isIntegerKey2,
    isKnownHtmlAttr: () => isKnownHtmlAttr,
    isKnownSvgAttr: () => isKnownSvgAttr,
    isMap: () => isMap2,
    isModelListener: () => isModelListener,
    isNoUnitNumericStyleProp: () => isNoUnitNumericStyleProp,
    isObject: () => isObject2,
    isOn: () => isOn,
    isPlainObject: () => isPlainObject,
    isPromise: () => isPromise,
    isReservedProp: () => isReservedProp,
    isSSRSafeAttrName: () => isSSRSafeAttrName,
    isSVGTag: () => isSVGTag,
    isSet: () => isSet,
    isSpecialBooleanAttr: () => isSpecialBooleanAttr,
    isString: () => isString,
    isSymbol: () => isSymbol2,
    isVoidTag: () => isVoidTag,
    looseEqual: () => looseEqual,
    looseIndexOf: () => looseIndexOf,
    makeMap: () => makeMap2,
    normalizeClass: () => normalizeClass,
    normalizeProps: () => normalizeProps,
    normalizeStyle: () => normalizeStyle,
    objectToString: () => objectToString,
    parseStringStyle: () => parseStringStyle,
    propsToAttrMap: () => propsToAttrMap,
    remove: () => remove,
    slotFlagsText: () => slotFlagsText,
    stringifyStyle: () => stringifyStyle,
    toDisplayString: () => toDisplayString,
    toHandlerKey: () => toHandlerKey,
    toNumber: () => toNumber,
    toRawType: () => toRawType2,
    toTypeString: () => toTypeString
  });
  function makeMap2(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  var PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
  };
  var slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
  };
  var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
  var isGloballyWhitelisted = /* @__PURE__ */ makeMap2(GLOBALS_WHITE_LISTED);
  var range = 2;
  function generateCodeFrame(source, start = 0, end = source.length) {
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
      count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
      if (count >= start) {
        for (let j = i - range; j <= i + range || end > count; j++) {
          if (j < 0 || j >= lines.length)
            continue;
          const line = j + 1;
          res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
          const lineLength = lines[j].length;
          const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
          if (j === i) {
            const pad = start - (count - (lineLength + newLineSeqLength));
            const length = Math.max(1, end > count ? lineLength - pad : end - start);
            res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
          } else if (j > i) {
            if (end > count) {
              const length = Math.max(Math.min(end - count, lineLength), 1);
              res.push(`   |  ` + "^".repeat(length));
            }
            count += lineLength + newLineSeqLength;
          }
        }
        break;
      }
    }
    return res.join("\n");
  }
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap2(specialBooleanAttrs);
  var isBooleanAttr = /* @__PURE__ */ makeMap2(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
  var attrValidationCache = {};
  function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
      return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
      console.error(`unsafe attribute name: ${name}`);
    }
    return attrValidationCache[name] = !isUnsafe;
  }
  var propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
  };
  var isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap2(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
  var isKnownHtmlAttr = /* @__PURE__ */ makeMap2(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
  var isKnownSvgAttr = /* @__PURE__ */ makeMap2(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
  function normalizeStyle(value) {
    if (isArray2(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value)) {
      return value;
    } else if (isObject2(value)) {
      return value;
    }
  }
  var listDelimiterRE = /;(?![^(]*\))/g;
  var propertyDelimiterRE = /:(.+)/;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function stringifyStyle(styles) {
    let ret = "";
    if (!styles || isString(styles)) {
      return ret;
    }
    for (const key in styles) {
      const value = styles[key];
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      if (isString(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
        ret += `${normalizedKey}:${value};`;
      }
    }
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray2(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject2(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps(props) {
    if (!props)
      return null;
    let {class: klass, style} = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (style) {
      props.style = normalizeStyle(style);
    }
    return props;
  }
  var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
  var isHTMLTag = /* @__PURE__ */ makeMap2(HTML_TAGS);
  var isSVGTag = /* @__PURE__ */ makeMap2(SVG_TAGS);
  var isVoidTag = /* @__PURE__ */ makeMap2(VOID_TAGS);
  var escapeRE = /["'&<>]/;
  function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) {
      return str;
    }
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          escaped = "&quot;";
          break;
        case 38:
          escaped = "&amp;";
          break;
        case 39:
          escaped = "&#39;";
          break;
        case 60:
          escaped = "&lt;";
          break;
        case 62:
          escaped = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escaped;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
  function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
  }
  function looseCompareArrays(a, b) {
    if (a.length !== b.length)
      return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
      equal = looseEqual(a[i], b[i]);
    }
    return equal;
  }
  function looseEqual(a, b) {
    if (a === b)
      return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray2(a);
    bValidType = isArray2(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject2(a);
    bValidType = isObject2(b);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a).length;
      const bKeysCount = Object.keys(b).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a) {
        const aHasKey = a.hasOwnProperty(key);
        const bHasKey = b.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
          return false;
        }
      }
    }
    return String(a) === String(b);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  var toDisplayString = (val) => {
    return val == null ? "" : isArray2(val) || isObject2(val) && (val.toString === objectToString || !isFunction2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
  };
  var replacer = (_key, val) => {
    if (val && val.__v_isRef) {
      return replacer(_key, val.value);
    } else if (isMap2(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
          entries[`${key} =>`] = val2;
          return entries;
        }, {})
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()]
      };
    } else if (isObject2(val) && !isArray2(val) && !isPlainObject(val)) {
      return String(val);
    }
    return val;
  };
  var babelParserDefaultPlugins = [
    "bigInt",
    "optionalChaining",
    "nullishCoalescingOperator"
  ];
  var EMPTY_OBJ = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
  var EMPTY_ARR = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
  var NOOP2 = () => {
  };
  var NO = () => false;
  var onRE = /^on[^a-z]/;
  var isOn = (key) => onRE.test(key);
  var isModelListener = (key) => key.startsWith("onUpdate:");
  var extend2 = Object.assign;
  var remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn2 = (val, key) => hasOwnProperty.call(val, key);
  var isArray2 = Array.isArray;
  var isMap2 = (val) => toTypeString(val) === "[object Map]";
  var isSet = (val) => toTypeString(val) === "[object Set]";
  var isDate = (val) => val instanceof Date;
  var isFunction2 = (val) => typeof val === "function";
  var isString = (val) => typeof val === "string";
  var isSymbol2 = (val) => typeof val === "symbol";
  var isObject2 = (val) => val !== null && typeof val === "object";
  var isPromise = (val) => {
    return isObject2(val) && isFunction2(val.then) && isFunction2(val.catch);
  };
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType2 = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isPlainObject = (val) => toTypeString(val) === "[object Object]";
  var isIntegerKey2 = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var isReservedProp = /* @__PURE__ */ makeMap2(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
  var cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
  var capitalize2 = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize2(str)}` : ``);
  var hasChanged2 = (value, oldValue) => !Object.is(value, oldValue);
  var invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](arg);
    }
  };
  var def2 = (obj, key, value) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      value
    });
  };
  var toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  var _globalThis;
  var getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
});

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
var require_compiler_core_esm_bundler = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    BASE_TRANSITION: () => BASE_TRANSITION,
    CAMELIZE: () => CAMELIZE,
    CAPITALIZE: () => CAPITALIZE,
    CREATE_BLOCK: () => CREATE_BLOCK,
    CREATE_COMMENT: () => CREATE_COMMENT,
    CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
    CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
    CREATE_SLOTS: () => CREATE_SLOTS,
    CREATE_STATIC: () => CREATE_STATIC,
    CREATE_TEXT: () => CREATE_TEXT,
    CREATE_VNODE: () => CREATE_VNODE,
    FRAGMENT: () => FRAGMENT,
    GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
    IS_MEMO_SAME: () => IS_MEMO_SAME,
    IS_REF: () => IS_REF,
    KEEP_ALIVE: () => KEEP_ALIVE,
    MERGE_PROPS: () => MERGE_PROPS,
    NORMALIZE_CLASS: () => NORMALIZE_CLASS,
    NORMALIZE_PROPS: () => NORMALIZE_PROPS,
    NORMALIZE_STYLE: () => NORMALIZE_STYLE,
    OPEN_BLOCK: () => OPEN_BLOCK,
    POP_SCOPE_ID: () => POP_SCOPE_ID,
    PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
    RENDER_LIST: () => RENDER_LIST,
    RENDER_SLOT: () => RENDER_SLOT,
    RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
    RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
    RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
    RESOLVE_FILTER: () => RESOLVE_FILTER,
    SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
    SUSPENSE: () => SUSPENSE,
    TELEPORT: () => TELEPORT,
    TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
    TO_HANDLERS: () => TO_HANDLERS,
    TO_HANDLER_KEY: () => TO_HANDLER_KEY,
    UNREF: () => UNREF,
    WITH_CTX: () => WITH_CTX,
    WITH_DIRECTIVES: () => WITH_DIRECTIVES,
    WITH_MEMO: () => WITH_MEMO,
    WITH_SCOPE_ID: () => WITH_SCOPE_ID,
    advancePositionWithClone: () => advancePositionWithClone,
    advancePositionWithMutation: () => advancePositionWithMutation,
    assert: () => assert,
    baseCompile: () => baseCompile,
    baseParse: () => baseParse,
    buildProps: () => buildProps,
    buildSlots: () => buildSlots,
    checkCompatEnabled: () => checkCompatEnabled,
    createArrayExpression: () => createArrayExpression,
    createAssignmentExpression: () => createAssignmentExpression,
    createBlockStatement: () => createBlockStatement,
    createCacheExpression: () => createCacheExpression,
    createCallExpression: () => createCallExpression,
    createCompilerError: () => createCompilerError,
    createCompoundExpression: () => createCompoundExpression,
    createConditionalExpression: () => createConditionalExpression,
    createForLoopParams: () => createForLoopParams,
    createFunctionExpression: () => createFunctionExpression,
    createIfStatement: () => createIfStatement,
    createInterpolation: () => createInterpolation,
    createObjectExpression: () => createObjectExpression,
    createObjectProperty: () => createObjectProperty,
    createReturnStatement: () => createReturnStatement,
    createRoot: () => createRoot,
    createSequenceExpression: () => createSequenceExpression,
    createSimpleExpression: () => createSimpleExpression,
    createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
    createTemplateLiteral: () => createTemplateLiteral,
    createTransformContext: () => createTransformContext,
    createVNodeCall: () => createVNodeCall,
    findDir: () => findDir,
    findProp: () => findProp,
    generate: () => generate,
    generateCodeFrame: () => import_shared3.generateCodeFrame,
    getBaseTransformPreset: () => getBaseTransformPreset,
    getInnerRange: () => getInnerRange,
    getMemoedVNodeCall: () => getMemoedVNodeCall,
    getVNodeBlockHelper: () => getVNodeBlockHelper,
    getVNodeHelper: () => getVNodeHelper,
    hasDynamicKeyVBind: () => hasDynamicKeyVBind,
    hasScopeRef: () => hasScopeRef,
    helperNameMap: () => helperNameMap,
    injectProp: () => injectProp,
    isBindKey: () => isBindKey,
    isBuiltInType: () => isBuiltInType,
    isCoreComponent: () => isCoreComponent,
    isMemberExpression: () => isMemberExpression,
    isSimpleIdentifier: () => isSimpleIdentifier,
    isSlotOutlet: () => isSlotOutlet,
    isStaticExp: () => isStaticExp,
    isTemplateNode: () => isTemplateNode,
    isText: () => isText,
    isVSlot: () => isVSlot,
    locStub: () => locStub,
    makeBlock: () => makeBlock,
    noopDirectiveTransform: () => noopDirectiveTransform,
    processExpression: () => processExpression,
    processFor: () => processFor,
    processIf: () => processIf,
    processSlotOutlet: () => processSlotOutlet,
    registerRuntimeHelpers: () => registerRuntimeHelpers,
    resolveComponentType: () => resolveComponentType,
    toValidAssetId: () => toValidAssetId,
    trackSlotScopes: () => trackSlotScopes,
    trackVForSlotScopes: () => trackVForSlotScopes,
    transform: () => transform,
    transformBind: () => transformBind,
    transformElement: () => transformElement,
    transformExpression: () => transformExpression,
    transformModel: () => transformModel,
    transformOn: () => transformOn,
    traverseNode: () => traverseNode,
    warnDeprecation: () => warnDeprecation
  });
  var import_shared2 = require_shared_esm_bundler();
  var import_shared3 = require_shared_esm_bundler();
  function defaultOnError(error) {
    throw error;
  }
  function defaultOnWarn(msg) {
    process.env.NODE_ENV !== "production" && console.warn(`[Vue warn] ${msg.message}`);
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
    const msg = process.env.NODE_ENV !== "production" || false ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
  }
  var errorMessages = {
    [0]: "Illegal comment.",
    [1]: "CDATA section is allowed only in XML context.",
    [2]: "Duplicate attribute.",
    [3]: "End tag cannot have attributes.",
    [4]: "Illegal '/' in tags.",
    [5]: "Unexpected EOF in tag.",
    [6]: "Unexpected EOF in CDATA section.",
    [7]: "Unexpected EOF in comment.",
    [8]: "Unexpected EOF in script.",
    [9]: "Unexpected EOF in tag.",
    [10]: "Incorrectly closed comment.",
    [11]: "Incorrectly opened comment.",
    [12]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13]: "Attribute value was expected.",
    [14]: "End tag name was expected.",
    [15]: "Whitespace was expected.",
    [16]: "Unexpected '<!--' in comment.",
    [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
    [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
    [19]: "Attribute name cannot start with '='.",
    [21]: "'<?' is allowed only in XML context.",
    [20]: `Unexpected null cahracter.`,
    [22]: "Illegal '/' in tags.",
    [23]: "Invalid end tag.",
    [24]: "Element is missing end tag.",
    [25]: "Interpolation end sign was not found.",
    [26]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
    [27]: `v-if/v-else-if is missing expression.`,
    [28]: `v-if/else branches must use unique keys.`,
    [29]: `v-else/v-else-if has no adjacent v-if.`,
    [30]: `v-for is missing expression.`,
    [31]: `v-for has invalid expression.`,
    [32]: `<template v-for> key should be placed on the <template> tag.`,
    [33]: `v-bind is missing expression.`,
    [34]: `v-on is missing expression.`,
    [35]: `Unexpected custom directive on <slot> outlet.`,
    [36]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
    [37]: `Duplicate slot names found. `,
    [38]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
    [39]: `v-slot can only be used on components or <template> tags.`,
    [40]: `v-model is missing expression.`,
    [41]: `v-model value must be a valid JavaScript member expression.`,
    [42]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [43]: `Error parsing JavaScript expression: `,
    [44]: `<KeepAlive> expects exactly one child component.`,
    [45]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [46]: `ES module mode is not supported in this build of compiler.`,
    [47]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [48]: `"scopeId" option is only supported in module mode.`,
    [49]: ``
  };
  var FRAGMENT = Symbol(process.env.NODE_ENV !== "production" ? `Fragment` : ``);
  var TELEPORT = Symbol(process.env.NODE_ENV !== "production" ? `Teleport` : ``);
  var SUSPENSE = Symbol(process.env.NODE_ENV !== "production" ? `Suspense` : ``);
  var KEEP_ALIVE = Symbol(process.env.NODE_ENV !== "production" ? `KeepAlive` : ``);
  var BASE_TRANSITION = Symbol(process.env.NODE_ENV !== "production" ? `BaseTransition` : ``);
  var OPEN_BLOCK = Symbol(process.env.NODE_ENV !== "production" ? `openBlock` : ``);
  var CREATE_BLOCK = Symbol(process.env.NODE_ENV !== "production" ? `createBlock` : ``);
  var CREATE_ELEMENT_BLOCK = Symbol(process.env.NODE_ENV !== "production" ? `createElementBlock` : ``);
  var CREATE_VNODE = Symbol(process.env.NODE_ENV !== "production" ? `createVNode` : ``);
  var CREATE_ELEMENT_VNODE = Symbol(process.env.NODE_ENV !== "production" ? `createElementVNode` : ``);
  var CREATE_COMMENT = Symbol(process.env.NODE_ENV !== "production" ? `createCommentVNode` : ``);
  var CREATE_TEXT = Symbol(process.env.NODE_ENV !== "production" ? `createTextVNode` : ``);
  var CREATE_STATIC = Symbol(process.env.NODE_ENV !== "production" ? `createStaticVNode` : ``);
  var RESOLVE_COMPONENT = Symbol(process.env.NODE_ENV !== "production" ? `resolveComponent` : ``);
  var RESOLVE_DYNAMIC_COMPONENT = Symbol(process.env.NODE_ENV !== "production" ? `resolveDynamicComponent` : ``);
  var RESOLVE_DIRECTIVE = Symbol(process.env.NODE_ENV !== "production" ? `resolveDirective` : ``);
  var RESOLVE_FILTER = Symbol(process.env.NODE_ENV !== "production" ? `resolveFilter` : ``);
  var WITH_DIRECTIVES = Symbol(process.env.NODE_ENV !== "production" ? `withDirectives` : ``);
  var RENDER_LIST = Symbol(process.env.NODE_ENV !== "production" ? `renderList` : ``);
  var RENDER_SLOT = Symbol(process.env.NODE_ENV !== "production" ? `renderSlot` : ``);
  var CREATE_SLOTS = Symbol(process.env.NODE_ENV !== "production" ? `createSlots` : ``);
  var TO_DISPLAY_STRING = Symbol(process.env.NODE_ENV !== "production" ? `toDisplayString` : ``);
  var MERGE_PROPS = Symbol(process.env.NODE_ENV !== "production" ? `mergeProps` : ``);
  var NORMALIZE_CLASS = Symbol(process.env.NODE_ENV !== "production" ? `normalizeClass` : ``);
  var NORMALIZE_STYLE = Symbol(process.env.NODE_ENV !== "production" ? `normalizeStyle` : ``);
  var NORMALIZE_PROPS = Symbol(process.env.NODE_ENV !== "production" ? `normalizeProps` : ``);
  var GUARD_REACTIVE_PROPS = Symbol(process.env.NODE_ENV !== "production" ? `guardReactiveProps` : ``);
  var TO_HANDLERS = Symbol(process.env.NODE_ENV !== "production" ? `toHandlers` : ``);
  var CAMELIZE = Symbol(process.env.NODE_ENV !== "production" ? `camelize` : ``);
  var CAPITALIZE = Symbol(process.env.NODE_ENV !== "production" ? `capitalize` : ``);
  var TO_HANDLER_KEY = Symbol(process.env.NODE_ENV !== "production" ? `toHandlerKey` : ``);
  var SET_BLOCK_TRACKING = Symbol(process.env.NODE_ENV !== "production" ? `setBlockTracking` : ``);
  var PUSH_SCOPE_ID = Symbol(process.env.NODE_ENV !== "production" ? `pushScopeId` : ``);
  var POP_SCOPE_ID = Symbol(process.env.NODE_ENV !== "production" ? `popScopeId` : ``);
  var WITH_SCOPE_ID = Symbol(process.env.NODE_ENV !== "production" ? `withScopeId` : ``);
  var WITH_CTX = Symbol(process.env.NODE_ENV !== "production" ? `withCtx` : ``);
  var UNREF = Symbol(process.env.NODE_ENV !== "production" ? `unref` : ``);
  var IS_REF = Symbol(process.env.NODE_ENV !== "production" ? `isRef` : ``);
  var WITH_MEMO = Symbol(process.env.NODE_ENV !== "production" ? `withMemo` : ``);
  var IS_MEMO_SAME = Symbol(process.env.NODE_ENV !== "production" ? `isMemoSame` : ``);
  var helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [RESOLVE_FILTER]: `resolveFilter`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [NORMALIZE_CLASS]: `normalizeClass`,
    [NORMALIZE_STYLE]: `normalizeStyle`,
    [NORMALIZE_PROPS]: `normalizeProps`,
    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_SCOPE_ID]: `withScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`,
    [WITH_MEMO]: `withMemo`,
    [IS_MEMO_SAME]: `isMemoSame`
  };
  function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach((s) => {
      helperNameMap[s] = helpers[s];
    });
  }
  var locStub = {
    source: "",
    start: {line: 1, column: 1, offset: 0},
    end: {line: 1, column: 1, offset: 0}
  };
  function createRoot(children, loc = locStub) {
    return {
      type: 0,
      children,
      helpers: [],
      components: [],
      directives: [],
      hoists: [],
      imports: [],
      cached: 0,
      temps: 0,
      codegenNode: void 0,
      loc
    };
  }
  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
    if (context) {
      if (isBlock) {
        context.helper(OPEN_BLOCK);
        context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
      } else {
        context.helper(getVNodeHelper(context.inSSR, isComponent2));
      }
      if (directives) {
        context.helper(WITH_DIRECTIVES);
      }
    }
    return {
      type: 13,
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent: isComponent2,
      loc
    };
  }
  function createArrayExpression(elements, loc = locStub) {
    return {
      type: 17,
      loc,
      elements
    };
  }
  function createObjectExpression(properties, loc = locStub) {
    return {
      type: 15,
      loc,
      properties
    };
  }
  function createObjectProperty(key, value) {
    return {
      type: 16,
      loc: locStub,
      key: (0, import_shared2.isString)(key) ? createSimpleExpression(key, true) : key,
      value
    };
  }
  function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
    return {
      type: 4,
      loc,
      content,
      isStatic,
      constType: isStatic ? 3 : constType
    };
  }
  function createInterpolation(content, loc) {
    return {
      type: 5,
      loc,
      content: (0, import_shared2.isString)(content) ? createSimpleExpression(content, false, loc) : content
    };
  }
  function createCompoundExpression(children, loc = locStub) {
    return {
      type: 8,
      loc,
      children
    };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
    return {
      type: 14,
      loc,
      callee,
      arguments: args
    };
  }
  function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
    return {
      type: 18,
      params,
      returns,
      newline,
      isSlot,
      loc
    };
  }
  function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
      type: 19,
      test,
      consequent,
      alternate,
      newline,
      loc: locStub
    };
  }
  function createCacheExpression(index, value, isVNode = false) {
    return {
      type: 20,
      index,
      value,
      isVNode,
      loc: locStub
    };
  }
  function createBlockStatement(body) {
    return {
      type: 21,
      body,
      loc: locStub
    };
  }
  function createTemplateLiteral(elements) {
    return {
      type: 22,
      elements,
      loc: locStub
    };
  }
  function createIfStatement(test, consequent, alternate) {
    return {
      type: 23,
      test,
      consequent,
      alternate,
      loc: locStub
    };
  }
  function createAssignmentExpression(left, right) {
    return {
      type: 24,
      left,
      right,
      loc: locStub
    };
  }
  function createSequenceExpression(expressions) {
    return {
      type: 25,
      expressions,
      loc: locStub
    };
  }
  function createReturnStatement(returns) {
    return {
      type: 26,
      returns,
      loc: locStub
    };
  }
  var isStaticExp = (p) => p.type === 4 && p.isStatic;
  var isBuiltInType = (tag, expected) => tag === expected || tag === (0, import_shared2.hyphenate)(expected);
  function isCoreComponent(tag) {
    if (isBuiltInType(tag, "Teleport")) {
      return TELEPORT;
    } else if (isBuiltInType(tag, "Suspense")) {
      return SUSPENSE;
    } else if (isBuiltInType(tag, "KeepAlive")) {
      return KEEP_ALIVE;
    } else if (isBuiltInType(tag, "BaseTransition")) {
      return BASE_TRANSITION;
    }
  }
  var nonIdentifierRE = /^\d|[^\$\w]/;
  var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
  var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
  var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
  var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
  var isMemberExpression = (path4) => {
    path4 = path4.trim().replace(whitespaceRE, (s) => s.trim());
    let state = 0;
    let stateStack = [];
    let currentOpenBracketCount = 0;
    let currentOpenParensCount = 0;
    let currentStringType = null;
    for (let i = 0; i < path4.length; i++) {
      const char = path4.charAt(i);
      switch (state) {
        case 0:
          if (char === "[") {
            stateStack.push(state);
            state = 1;
            currentOpenBracketCount++;
          } else if (char === "(") {
            stateStack.push(state);
            state = 2;
            currentOpenParensCount++;
          } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
            return false;
          }
          break;
        case 1:
          if (char === `'` || char === `"` || char === "`") {
            stateStack.push(state);
            state = 3;
            currentStringType = char;
          } else if (char === `[`) {
            currentOpenBracketCount++;
          } else if (char === `]`) {
            if (!--currentOpenBracketCount) {
              state = stateStack.pop();
            }
          }
          break;
        case 2:
          if (char === `'` || char === `"` || char === "`") {
            stateStack.push(state);
            state = 3;
            currentStringType = char;
          } else if (char === `(`) {
            currentOpenParensCount++;
          } else if (char === `)`) {
            if (i === path4.length - 1) {
              return false;
            }
            if (!--currentOpenParensCount) {
              state = stateStack.pop();
            }
          }
          break;
        case 3:
          if (char === currentStringType) {
            state = stateStack.pop();
            currentStringType = null;
          }
          break;
      }
    }
    return !currentOpenBracketCount && !currentOpenParensCount;
  };
  function getInnerRange(loc, offset, length) {
    const source = loc.source.substr(offset, length);
    const newLoc = {
      source,
      start: advancePositionWithClone(loc.start, loc.source, offset),
      end: loc.end
    };
    if (length != null) {
      newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
    }
    return newLoc;
  }
  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation((0, import_shared2.extend)({}, pos), source, numberOfCharacters);
  }
  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
      if (source.charCodeAt(i) === 10) {
        linesCount++;
        lastNewLinePos = i;
      }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
    return pos;
  }
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg || `unexpected compiler condition`);
    }
  }
  function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i];
      if (p.type === 7 && (allowEmpty || p.exp) && ((0, import_shared2.isString)(name) ? p.name === name : name.test(p.name))) {
        return p;
      }
    }
  }
  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i];
      if (p.type === 6) {
        if (dynamicOnly)
          continue;
        if (p.name === name && (p.value || allowEmpty)) {
          return p;
        }
      } else if (p.name === "bind" && (p.exp || allowEmpty) && isBindKey(p.arg, name)) {
        return p;
      }
    }
  }
  function isBindKey(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function hasDynamicKeyVBind(node) {
    return node.props.some((p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic));
  }
  function isText(node) {
    return node.type === 5 || node.type === 2;
  }
  function isVSlot(p) {
    return p.type === 7 && p.name === "slot";
  }
  function isTemplateNode(node) {
    return node.type === 1 && node.tagType === 3;
  }
  function isSlotOutlet(node) {
    return node.type === 1 && node.tagType === 2;
  }
  function getVNodeHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
  }
  function getVNodeBlockHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
  }
  var propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
  function getUnnormalizedProps(props, callPath = []) {
    if (props && !(0, import_shared2.isString)(props) && props.type === 14) {
      const callee = props.callee;
      if (!(0, import_shared2.isString)(callee) && propsHelperSet.has(callee)) {
        return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
      }
    }
    return [props, callPath];
  }
  function injectProp(node, prop, context) {
    let propsWithInjection;
    const originalProps = node.type === 13 ? node.props : node.arguments[2];
    let props = originalProps;
    let callPath = [];
    let parentCall;
    if (props && !(0, import_shared2.isString)(props) && props.type === 14) {
      const ret = getUnnormalizedProps(props);
      props = ret[0];
      callPath = ret[1];
      parentCall = callPath[callPath.length - 1];
    }
    if (props == null || (0, import_shared2.isString)(props)) {
      propsWithInjection = createObjectExpression([prop]);
    } else if (props.type === 14) {
      const first = props.arguments[0];
      if (!(0, import_shared2.isString)(first) && first.type === 15) {
        first.properties.unshift(prop);
      } else {
        if (props.callee === TO_HANDLERS) {
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
          ]);
        } else {
          props.arguments.unshift(createObjectExpression([prop]));
        }
      }
      !propsWithInjection && (propsWithInjection = props);
    } else if (props.type === 15) {
      let alreadyExists = false;
      if (prop.key.type === 4) {
        const propKeyName = prop.key.content;
        alreadyExists = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
      }
      if (!alreadyExists) {
        props.properties.unshift(prop);
      }
      propsWithInjection = props;
    } else {
      propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
        createObjectExpression([prop]),
        props
      ]);
      if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
        parentCall = callPath[callPath.length - 2];
      }
    }
    if (node.type === 13) {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.props = propsWithInjection;
      }
    } else {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.arguments[2] = propsWithInjection;
      }
    }
  }
  function toValidAssetId(name, type) {
    return `_${type}_${name.replace(/[^\w]/g, "_")}`;
  }
  function hasScopeRef(node, ids) {
    if (!node || Object.keys(ids).length === 0) {
      return false;
    }
    switch (node.type) {
      case 1:
        for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
            return true;
          }
        }
        return node.children.some((c) => hasScopeRef(c, ids));
      case 11:
        if (hasScopeRef(node.source, ids)) {
          return true;
        }
        return node.children.some((c) => hasScopeRef(c, ids));
      case 9:
        return node.branches.some((b) => hasScopeRef(b, ids));
      case 10:
        if (hasScopeRef(node.condition, ids)) {
          return true;
        }
        return node.children.some((c) => hasScopeRef(c, ids));
      case 4:
        return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
      case 8:
        return node.children.some((c) => (0, import_shared2.isObject)(c) && hasScopeRef(c, ids));
      case 5:
      case 12:
        return hasScopeRef(node.content, ids);
      case 2:
      case 3:
        return false;
      default:
        if (process.env.NODE_ENV !== "production")
          ;
        return false;
    }
  }
  function getMemoedVNodeCall(node) {
    if (node.type === 14 && node.callee === WITH_MEMO) {
      return node.arguments[1].returns;
    } else {
      return node;
    }
  }
  function makeBlock(node, {helper, removeHelper, inSSR}) {
    if (!node.isBlock) {
      node.isBlock = true;
      removeHelper(getVNodeHelper(inSSR, node.isComponent));
      helper(OPEN_BLOCK);
      helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
  }
  var deprecationData = {
    ["COMPILER_IS_ON_ELEMENT"]: {
      message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
      link: `https://v3.vuejs.org/guide/migration/custom-elements-interop.html`
    },
    ["COMPILER_V_BIND_SYNC"]: {
      message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
      link: `https://v3.vuejs.org/guide/migration/v-model.html`
    },
    ["COMPILER_V_BIND_PROP"]: {
      message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
    },
    ["COMPILER_V_BIND_OBJECT_ORDER"]: {
      message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
      link: `https://v3.vuejs.org/guide/migration/v-bind.html`
    },
    ["COMPILER_V_ON_NATIVE"]: {
      message: `.native modifier for v-on has been removed as is no longer necessary.`,
      link: `https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html`
    },
    ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
      message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
      link: `https://v3.vuejs.org/guide/migration/v-if-v-for.html`
    },
    ["COMPILER_V_FOR_REF"]: {
      message: `Ref usage on v-for no longer creates array ref values in Vue 3. Consider using function refs or refactor to avoid ref usage altogether.`,
      link: `https://v3.vuejs.org/guide/migration/array-refs.html`
    },
    ["COMPILER_NATIVE_TEMPLATE"]: {
      message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
    },
    ["COMPILER_INLINE_TEMPLATE"]: {
      message: `"inline-template" has been removed in Vue 3.`,
      link: `https://v3.vuejs.org/guide/migration/inline-template-attribute.html`
    },
    ["COMPILER_FILTER"]: {
      message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
      link: `https://v3.vuejs.org/guide/migration/filters.html`
    }
  };
  function getCompatValue(key, context) {
    const config = context.options ? context.options.compatConfig : context.compatConfig;
    const value = config && config[key];
    if (key === "MODE") {
      return value || 3;
    } else {
      return value;
    }
  }
  function isCompatEnabled(key, context) {
    const mode = getCompatValue("MODE", context);
    const value = getCompatValue(key, context);
    return mode === 3 ? value === true : value !== false;
  }
  function checkCompatEnabled(key, context, loc, ...args) {
    const enabled = isCompatEnabled(key, context);
    if (process.env.NODE_ENV !== "production" && enabled) {
      warnDeprecation(key, context, loc, ...args);
    }
    return enabled;
  }
  function warnDeprecation(key, context, loc, ...args) {
    const val = getCompatValue(key, context);
    if (val === "suppress-warning") {
      return;
    }
    const {message, link} = deprecationData[key];
    const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key;
    if (loc)
      err.loc = loc;
    context.onWarn(err);
  }
  var decodeRE = /&(gt|lt|amp|apos|quot);/g;
  var decodeMap = {
    gt: ">",
    lt: "<",
    amp: "&",
    apos: "'",
    quot: '"'
  };
  var defaultParserOptions = {
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0,
    getTextMode: () => 0,
    isVoidTag: import_shared2.NO,
    isPreTag: import_shared2.NO,
    isCustomElement: import_shared2.NO,
    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
    onError: defaultOnError,
    onWarn: defaultOnWarn,
    comments: process.env.NODE_ENV !== "production"
  };
  function baseParse(content, options = {}) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(parseChildren(context, 0, []), getSelection(context, start));
  }
  function createParserContext(content, rawOptions) {
    const options = (0, import_shared2.extend)({}, defaultParserOptions);
    let key;
    for (key in rawOptions) {
      options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
    }
    return {
      options,
      column: 1,
      line: 1,
      offset: 0,
      originalSource: content,
      source: content,
      inPre: false,
      inVPre: false,
      onWarn: options.onWarn
    };
  }
  function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0;
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
      const s = context.source;
      let node = void 0;
      if (mode === 0 || mode === 1) {
        if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
          node = parseInterpolation(context, mode);
        } else if (mode === 0 && s[0] === "<") {
          if (s.length === 1) {
            emitError(context, 5, 1);
          } else if (s[1] === "!") {
            if (startsWith(s, "<!--")) {
              node = parseComment(context);
            } else if (startsWith(s, "<!DOCTYPE")) {
              node = parseBogusComment(context);
            } else if (startsWith(s, "<![CDATA[")) {
              if (ns !== 0) {
                node = parseCDATA(context, ancestors);
              } else {
                emitError(context, 1);
                node = parseBogusComment(context);
              }
            } else {
              emitError(context, 11);
              node = parseBogusComment(context);
            }
          } else if (s[1] === "/") {
            if (s.length === 2) {
              emitError(context, 5, 2);
            } else if (s[2] === ">") {
              emitError(context, 14, 2);
              advanceBy(context, 3);
              continue;
            } else if (/[a-z]/i.test(s[2])) {
              emitError(context, 23);
              parseTag(context, 1, parent);
              continue;
            } else {
              emitError(context, 12, 2);
              node = parseBogusComment(context);
            }
          } else if (/[a-z]/i.test(s[1])) {
            node = parseElement(context, ancestors);
            if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
              process.env.NODE_ENV !== "production" && warnDeprecation("COMPILER_NATIVE_TEMPLATE", context, node.loc);
              node = node.children;
            }
          } else if (s[1] === "?") {
            emitError(context, 21, 1);
            node = parseBogusComment(context);
          } else {
            emitError(context, 12, 1);
          }
        }
      }
      if (!node) {
        node = parseText(context, mode);
      }
      if ((0, import_shared2.isArray)(node)) {
        for (let i = 0; i < node.length; i++) {
          pushNode(nodes, node[i]);
        }
      } else {
        pushNode(nodes, node);
      }
    }
    let removedWhitespace = false;
    if (mode !== 2 && mode !== 1) {
      const shouldCondense = context.options.whitespace !== "preserve";
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!context.inPre && node.type === 2) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i - 1];
            const next = nodes[i + 1];
            if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
              removedWhitespace = true;
              nodes[i] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
          }
        } else if (node.type === 3 && !context.options.comments) {
          removedWhitespace = true;
          nodes[i] = null;
        }
      }
      if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
        const first = nodes[0];
        if (first && first.type === 2) {
          first.content = first.content.replace(/^\r?\n/, "");
        }
      }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function pushNode(nodes, node) {
    if (node.type === 2) {
      const prev = last(nodes);
      if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
        prev.content += node.content;
        prev.loc.end = node.loc.end;
        prev.loc.source += node.loc.source;
        return;
      }
    }
    nodes.push(node);
  }
  function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3, ancestors);
    if (context.source.length === 0) {
      emitError(context, 6);
    } else {
      advanceBy(context, 3);
    }
    return nodes;
  }
  function parseComment(context) {
    const start = getCursor(context);
    let content;
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
      content = context.source.slice(4);
      advanceBy(context, context.source.length);
      emitError(context, 7);
    } else {
      if (match.index <= 3) {
        emitError(context, 0);
      }
      if (match[1]) {
        emitError(context, 10);
      }
      content = context.source.slice(4, match.index);
      const s = context.source.slice(0, match.index);
      let prevIndex = 1, nestedIndex = 0;
      while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
        advanceBy(context, nestedIndex - prevIndex + 1);
        if (nestedIndex + 4 < s.length) {
          emitError(context, 16);
        }
        prevIndex = nestedIndex + 1;
      }
      advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
      type: 3,
      content,
      loc: getSelection(context, start)
    };
  }
  function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === "?" ? 1 : 2;
    let content;
    const closeIndex = context.source.indexOf(">");
    if (closeIndex === -1) {
      content = context.source.slice(contentStart);
      advanceBy(context, context.source.length);
    } else {
      content = context.source.slice(contentStart, closeIndex);
      advanceBy(context, closeIndex + 1);
    }
    return {
      type: 3,
      content,
      loc: getSelection(context, start)
    };
  }
  function parseElement(context, ancestors) {
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context, 0, parent);
    const isPreBoundary = context.inPre && !wasInPre;
    const isVPreBoundary = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
      if (isPreBoundary) {
        context.inPre = false;
      }
      if (isVPreBoundary) {
        context.inVPre = false;
      }
      return element;
    }
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    ancestors.pop();
    {
      const inlineTemplateProp = element.props.find((p) => p.type === 6 && p.name === "inline-template");
      if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
        const loc = getSelection(context, element.loc.end);
        inlineTemplateProp.value = {
          type: 2,
          content: loc.source,
          loc
        };
      }
    }
    element.children = children;
    if (startsWithEndTagOpen(context.source, element.tag)) {
      parseTag(context, 1, parent);
    } else {
      emitError(context, 24, 0, element.loc.start);
      if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
        const first = children[0];
        if (first && startsWith(first.loc.source, "<!--")) {
          emitError(context, 8);
        }
      }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  var isSpecialTemplateDirective = /* @__PURE__ */ (0, import_shared2.makeMap)(`if,else,else-if,for,slot`);
  function parseTag(context, type, parent) {
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    const cursor = getCursor(context);
    const currentSource = context.source;
    if (context.options.isPreTag(tag)) {
      context.inPre = true;
    }
    let props = parseAttributes(context, type);
    if (type === 0 && !context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
      context.inVPre = true;
      (0, import_shared2.extend)(context, cursor);
      context.source = currentSource;
      props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
    }
    let isSelfClosing = false;
    if (context.source.length === 0) {
      emitError(context, 9);
    } else {
      isSelfClosing = startsWith(context.source, "/>");
      if (type === 1 && isSelfClosing) {
        emitError(context, 4);
      }
      advanceBy(context, isSelfClosing ? 2 : 1);
    }
    if (type === 1) {
      return;
    }
    if (process.env.NODE_ENV !== "production" && isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context)) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 7) {
          if (p.name === "if") {
            hasIf = true;
          } else if (p.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context, getSelection(context, start));
        }
      }
    }
    let tagType = 0;
    if (!context.inVPre) {
      if (tag === "slot") {
        tagType = 2;
      } else if (tag === "template") {
        if (props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
          tagType = 3;
        }
      } else if (isComponent(tag, props, context)) {
        tagType = 1;
      }
    }
    return {
      type: 1,
      ns,
      tag,
      tagType,
      props,
      isSelfClosing,
      children: [],
      loc: getSelection(context, start),
      codegenNode: void 0
    };
  }
  function isComponent(tag, props, context) {
    const options = context.options;
    if (options.isCustomElement(tag)) {
      return false;
    }
    if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
      return true;
    }
    for (let i = 0; i < props.length; i++) {
      const p = props[i];
      if (p.type === 6) {
        if (p.name === "is" && p.value) {
          if (p.value.content.startsWith("vue:")) {
            return true;
          } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
            return true;
          }
        }
      } else {
        if (p.name === "is") {
          return true;
        } else if (p.name === "bind" && isBindKey(p.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
          return true;
        }
      }
    }
  }
  function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
      if (startsWith(context.source, "/")) {
        emitError(context, 22);
        advanceBy(context, 1);
        advanceSpaces(context);
        continue;
      }
      if (type === 1) {
        emitError(context, 3);
      }
      const attr = parseAttribute(context, attributeNames);
      if (type === 0) {
        props.push(attr);
      }
      if (/^[^\t\r\n\f />]/.test(context.source)) {
        emitError(context, 15);
      }
      advanceSpaces(context);
    }
    return props;
  }
  function parseAttribute(context, nameSet) {
    const start = getCursor(context);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
      emitError(context, 2);
    }
    nameSet.add(name);
    if (name[0] === "=") {
      emitError(context, 19);
    }
    {
      const pattern = /["'<]/g;
      let m;
      while (m = pattern.exec(name)) {
        emitError(context, 17, m.index);
      }
    }
    advanceBy(context, name.length);
    let value = void 0;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
      advanceSpaces(context);
      advanceBy(context, 1);
      advanceSpaces(context);
      value = parseAttributeValue(context);
      if (!value) {
        emitError(context, 13);
      }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-|:|\.|@|#)/.test(name)) {
      const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
      let isPropShorthand = startsWith(name, ".");
      let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
      let arg;
      if (match2[2]) {
        const isSlot = dirName === "slot";
        const startOffset = name.lastIndexOf(match2[2]);
        const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
        let content = match2[2];
        let isStatic = true;
        if (content.startsWith("[")) {
          isStatic = false;
          if (!content.endsWith("]")) {
            emitError(context, 26);
          }
          content = content.substr(1, content.length - 2);
        } else if (isSlot) {
          content += match2[3] || "";
        }
        arg = {
          type: 4,
          content,
          isStatic,
          constType: isStatic ? 3 : 0,
          loc: loc2
        };
      }
      if (value && value.isQuoted) {
        const valueLoc = value.loc;
        valueLoc.start.offset++;
        valueLoc.start.column++;
        valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
        valueLoc.source = valueLoc.source.slice(1, -1);
      }
      const modifiers = match2[3] ? match2[3].substr(1).split(".") : [];
      if (isPropShorthand)
        modifiers.push("prop");
      if (dirName === "bind" && arg) {
        if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
          dirName = "model";
          modifiers.splice(modifiers.indexOf("sync"), 1);
        }
        if (process.env.NODE_ENV !== "production" && modifiers.includes("prop")) {
          checkCompatEnabled("COMPILER_V_BIND_PROP", context, loc);
        }
      }
      return {
        type: 7,
        name: dirName,
        exp: value && {
          type: 4,
          content: value.content,
          isStatic: false,
          constType: 0,
          loc: value.loc
        },
        arg,
        modifiers,
        loc
      };
    }
    return {
      type: 6,
      name,
      value: value && {
        type: 2,
        content: value.content,
        loc: value.loc
      },
      loc
    };
  }
  function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
      advanceBy(context, 1);
      const endIndex = context.source.indexOf(quote);
      if (endIndex === -1) {
        content = parseTextData(context, context.source.length, 4);
      } else {
        content = parseTextData(context, endIndex, 4);
        advanceBy(context, 1);
      }
    } else {
      const match = /^[^\t\r\n\f >]+/.exec(context.source);
      if (!match) {
        return void 0;
      }
      const unexpectedChars = /["'<=`]/g;
      let m;
      while (m = unexpectedChars.exec(match[0])) {
        emitError(context, 18, m.index);
      }
      content = parseTextData(context, match[0].length, 4);
    }
    return {content, isQuoted, loc: getSelection(context, start)};
  }
  function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
      emitError(context, 25);
      return void 0;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
      advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
      type: 5,
      content: {
        type: 4,
        isStatic: false,
        constType: 0,
        content,
        loc: getSelection(context, innerStart, innerEnd)
      },
      loc: getSelection(context, start)
    };
  }
  function parseText(context, mode) {
    const endTokens = ["<", context.options.delimiters[0]];
    if (mode === 3) {
      endTokens.push("]]>");
    }
    let endIndex = context.source.length;
    for (let i = 0; i < endTokens.length; i++) {
      const index = context.source.indexOf(endTokens[i], 1);
      if (index !== -1 && endIndex > index) {
        endIndex = index;
      }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
      type: 2,
      content,
      loc: getSelection(context, start)
    };
  }
  function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (mode === 2 || mode === 3 || rawText.indexOf("&") === -1) {
      return rawText;
    } else {
      return context.options.decodeEntities(rawText, mode === 4);
    }
  }
  function getCursor(context) {
    const {column, line, offset} = context;
    return {column, line, offset};
  }
  function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
      start,
      end,
      source: context.originalSource.slice(start.offset, end.offset)
    };
  }
  function last(xs) {
    return xs[xs.length - 1];
  }
  function startsWith(source, searchString) {
    return source.startsWith(searchString);
  }
  function advanceBy(context, numberOfCharacters) {
    const {source} = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
  }
  function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
      advanceBy(context, match[0].length);
    }
  }
  function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
  }
  function emitError(context, code, offset, loc = getCursor(context)) {
    if (offset) {
      loc.offset += offset;
      loc.column += offset;
    }
    context.options.onError(createCompilerError(code, {
      start: loc,
      end: loc,
      source: ""
    }));
  }
  function isEnd(context, mode, ancestors) {
    const s = context.source;
    switch (mode) {
      case 0:
        if (startsWith(s, "</")) {
          for (let i = ancestors.length - 1; i >= 0; --i) {
            if (startsWithEndTagOpen(s, ancestors[i].tag)) {
              return true;
            }
          }
        }
        break;
      case 1:
      case 2: {
        const parent = last(ancestors);
        if (parent && startsWithEndTagOpen(s, parent.tag)) {
          return true;
        }
        break;
      }
      case 3:
        if (startsWith(s, "]]>")) {
          return true;
        }
        break;
    }
    return !s;
  }
  function startsWithEndTagOpen(source, tag) {
    return startsWith(source, "</") && source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
  }
  function hoistStatic(root, context) {
    walk(root, context, isSingleElementRoot(root, root.children[0]));
  }
  function isSingleElementRoot(root, child) {
    const {children} = root;
    return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
  }
  function walk(node, context, doNotHoistNode = false) {
    let canStringify = true;
    const {children} = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.type === 1 && child.tagType === 0) {
        const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
        if (constantType > 0) {
          if (constantType < 3) {
            canStringify = false;
          }
          if (constantType >= 2) {
            child.codegenNode.patchFlag = -1 + (process.env.NODE_ENV !== "production" ? ` /* HOISTED */` : ``);
            child.codegenNode = context.hoist(child.codegenNode);
            hoistedCount++;
            continue;
          }
        } else {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            const flag = getPatchFlag(codegenNode);
            if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
              const props = getNodeProps(child);
              if (props) {
                codegenNode.props = context.hoist(props);
              }
            }
            if (codegenNode.dynamicProps) {
              codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
            }
          }
        }
      } else if (child.type === 12) {
        const contentType = getConstantType(child.content, context);
        if (contentType > 0) {
          if (contentType < 3) {
            canStringify = false;
          }
          if (contentType >= 2) {
            child.codegenNode = context.hoist(child.codegenNode);
            hoistedCount++;
          }
        }
      }
      if (child.type === 1) {
        const isComponent2 = child.tagType === 1;
        if (isComponent2) {
          context.scopes.vSlot++;
        }
        walk(child, context);
        if (isComponent2) {
          context.scopes.vSlot--;
        }
      } else if (child.type === 11) {
        walk(child, context, child.children.length === 1);
      } else if (child.type === 9) {
        for (let i2 = 0; i2 < child.branches.length; i2++) {
          walk(child.branches[i2], context, child.branches[i2].children.length === 1);
        }
      }
    }
    if (canStringify && hoistedCount && context.transformHoist) {
      context.transformHoist(children, context, node);
    }
    if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && (0, import_shared2.isArray)(node.codegenNode.children)) {
      node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
    }
  }
  function getConstantType(node, context) {
    const {constantCache} = context;
    switch (node.type) {
      case 1:
        if (node.tagType !== 0) {
          return 0;
        }
        const cached = constantCache.get(node);
        if (cached !== void 0) {
          return cached;
        }
        const codegenNode = node.codegenNode;
        if (codegenNode.type !== 13) {
          return 0;
        }
        const flag = getPatchFlag(codegenNode);
        if (!flag) {
          let returnType2 = 3;
          const generatedPropsType = getGeneratedPropsConstantType(node, context);
          if (generatedPropsType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (generatedPropsType < returnType2) {
            returnType2 = generatedPropsType;
          }
          for (let i = 0; i < node.children.length; i++) {
            const childType = getConstantType(node.children[i], context);
            if (childType === 0) {
              constantCache.set(node, 0);
              return 0;
            }
            if (childType < returnType2) {
              returnType2 = childType;
            }
          }
          if (returnType2 > 1) {
            for (let i = 0; i < node.props.length; i++) {
              const p = node.props[i];
              if (p.type === 7 && p.name === "bind" && p.exp) {
                const expType = getConstantType(p.exp, context);
                if (expType === 0) {
                  constantCache.set(node, 0);
                  return 0;
                }
                if (expType < returnType2) {
                  returnType2 = expType;
                }
              }
            }
          }
          if (codegenNode.isBlock) {
            context.removeHelper(OPEN_BLOCK);
            context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
            codegenNode.isBlock = false;
            context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
          }
          constantCache.set(node, returnType2);
          return returnType2;
        } else {
          constantCache.set(node, 0);
          return 0;
        }
      case 2:
      case 3:
        return 3;
      case 9:
      case 11:
      case 10:
        return 0;
      case 5:
      case 12:
        return getConstantType(node.content, context);
      case 4:
        return node.constType;
      case 8:
        let returnType = 3;
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if ((0, import_shared2.isString)(child) || (0, import_shared2.isSymbol)(child)) {
            continue;
          }
          const childType = getConstantType(child, context);
          if (childType === 0) {
            return 0;
          } else if (childType < returnType) {
            returnType = childType;
          }
        }
        return returnType;
      default:
        if (process.env.NODE_ENV !== "production")
          ;
        return 0;
    }
  }
  var allowHoistedHelperSet = new Set([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
  ]);
  function getConstantTypeOfHelperCall(value, context) {
    if (value.type === 14 && !(0, import_shared2.isString)(value.callee) && allowHoistedHelperSet.has(value.callee)) {
      const arg = value.arguments[0];
      if (arg.type === 4) {
        return getConstantType(arg, context);
      } else if (arg.type === 14) {
        return getConstantTypeOfHelperCall(arg, context);
      }
    }
    return 0;
  }
  function getGeneratedPropsConstantType(node, context) {
    let returnType = 3;
    const props = getNodeProps(node);
    if (props && props.type === 15) {
      const {properties} = props;
      for (let i = 0; i < properties.length; i++) {
        const {key, value} = properties[i];
        const keyType = getConstantType(key, context);
        if (keyType === 0) {
          return keyType;
        }
        if (keyType < returnType) {
          returnType = keyType;
        }
        let valueType;
        if (value.type === 4) {
          valueType = getConstantType(value, context);
        } else if (value.type === 14) {
          valueType = getConstantTypeOfHelperCall(value, context);
        } else {
          valueType = 0;
        }
        if (valueType === 0) {
          return valueType;
        }
        if (valueType < returnType) {
          returnType = valueType;
        }
      }
    }
    return returnType;
  }
  function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13) {
      return codegenNode.props;
    }
  }
  function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : void 0;
  }
  function createTransformContext(root, {filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = import_shared2.NOOP, isCustomElement = import_shared2.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = import_shared2.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig}) {
    const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
    const context = {
      selfName: nameMatch && (0, import_shared2.capitalize)((0, import_shared2.camelize)(nameMatch[1])),
      prefixIdentifiers,
      hoistStatic: hoistStatic2,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      isCustomElement,
      expressionPlugins,
      scopeId,
      slotted,
      ssr,
      inSSR,
      ssrCssVars,
      bindingMetadata,
      inline,
      isTS,
      onError,
      onWarn,
      compatConfig,
      root,
      helpers: new Map(),
      components: new Set(),
      directives: new Set(),
      hoists: [],
      imports: [],
      constantCache: new Map(),
      temps: 0,
      cached: 0,
      identifiers: Object.create(null),
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0
      },
      parent: null,
      currentNode: root,
      childIndex: 0,
      inVOnce: false,
      helper(name) {
        const count = context.helpers.get(name) || 0;
        context.helpers.set(name, count + 1);
        return name;
      },
      removeHelper(name) {
        const count = context.helpers.get(name);
        if (count) {
          const currentCount = count - 1;
          if (!currentCount) {
            context.helpers.delete(name);
          } else {
            context.helpers.set(name, currentCount);
          }
        }
      },
      helperString(name) {
        return `_${helperNameMap[context.helper(name)]}`;
      },
      replaceNode(node) {
        if (process.env.NODE_ENV !== "production") {
          if (!context.currentNode) {
            throw new Error(`Node being replaced is already removed.`);
          }
          if (!context.parent) {
            throw new Error(`Cannot replace root node.`);
          }
        }
        context.parent.children[context.childIndex] = context.currentNode = node;
      },
      removeNode(node) {
        if (process.env.NODE_ENV !== "production" && !context.parent) {
          throw new Error(`Cannot remove root node.`);
        }
        const list = context.parent.children;
        const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
        if (process.env.NODE_ENV !== "production" && removalIndex < 0) {
          throw new Error(`node being removed is not a child of current parent`);
        }
        if (!node || node === context.currentNode) {
          context.currentNode = null;
          context.onNodeRemoved();
        } else {
          if (context.childIndex > removalIndex) {
            context.childIndex--;
            context.onNodeRemoved();
          }
        }
        context.parent.children.splice(removalIndex, 1);
      },
      onNodeRemoved: () => {
      },
      addIdentifiers(exp) {
      },
      removeIdentifiers(exp) {
      },
      hoist(exp) {
        if ((0, import_shared2.isString)(exp))
          exp = createSimpleExpression(exp);
        context.hoists.push(exp);
        const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
        identifier.hoisted = exp;
        return identifier;
      },
      cache(exp, isVNode = false) {
        return createCacheExpression(context.cached++, exp, isVNode);
      }
    };
    {
      context.filters = new Set();
    }
    return context;
  }
  function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
      hoistStatic(root, context);
    }
    if (!options.ssr) {
      createRootCodegen(root, context);
    }
    root.helpers = [...context.helpers.keys()];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    {
      root.filters = [...context.filters];
    }
  }
  function createRootCodegen(root, context) {
    const {helper} = context;
    const {children} = root;
    if (children.length === 1) {
      const child = children[0];
      if (isSingleElementRoot(root, child) && child.codegenNode) {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          makeBlock(codegenNode, context);
        }
        root.codegenNode = codegenNode;
      } else {
        root.codegenNode = child;
      }
    } else if (children.length > 1) {
      let patchFlag = 64;
      let patchFlagText = import_shared2.PatchFlagNames[64];
      if (process.env.NODE_ENV !== "production" && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${import_shared2.PatchFlagNames[2048]}`;
      }
      root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag + (process.env.NODE_ENV !== "production" ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, void 0, false);
    } else
      ;
  }
  function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
      i--;
    };
    for (; i < parent.children.length; i++) {
      const child = parent.children[i];
      if ((0, import_shared2.isString)(child))
        continue;
      context.parent = parent;
      context.childIndex = i;
      context.onNodeRemoved = nodeRemoved;
      traverseNode(child, context);
    }
  }
  function traverseNode(node, context) {
    context.currentNode = node;
    const {nodeTransforms} = context;
    const exitFns = [];
    for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
      const onExit = nodeTransforms[i2](node, context);
      if (onExit) {
        if ((0, import_shared2.isArray)(onExit)) {
          exitFns.push(...onExit);
        } else {
          exitFns.push(onExit);
        }
      }
      if (!context.currentNode) {
        return;
      } else {
        node = context.currentNode;
      }
    }
    switch (node.type) {
      case 3:
        if (!context.ssr) {
          context.helper(CREATE_COMMENT);
        }
        break;
      case 5:
        if (!context.ssr) {
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case 9:
        for (let i2 = 0; i2 < node.branches.length; i2++) {
          traverseNode(node.branches[i2], context);
        }
        break;
      case 10:
      case 11:
      case 1:
      case 0:
        traverseChildren(node, context);
        break;
    }
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
      exitFns[i]();
    }
  }
  function createStructuralDirectiveTransform(name, fn) {
    const matches = (0, import_shared2.isString)(name) ? (n) => n === name : (n) => name.test(n);
    return (node, context) => {
      if (node.type === 1) {
        const {props} = node;
        if (node.tagType === 3 && props.some(isVSlot)) {
          return;
        }
        const exitFns = [];
        for (let i = 0; i < props.length; i++) {
          const prop = props[i];
          if (prop.type === 7 && matches(prop.name)) {
            props.splice(i, 1);
            i--;
            const onExit = fn(node, prop, context);
            if (onExit)
              exitFns.push(onExit);
          }
        }
        return exitFns;
      }
    };
  }
  var PURE_ANNOTATION = `/*#__PURE__*/`;
  function createCodegenContext(ast, {mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false, isTS = false, inSSR = false}) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeImports,
      runtimeGlobalName,
      runtimeModuleName,
      ssr,
      isTS,
      inSSR,
      source: ast.loc.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: void 0,
      helper(key) {
        return `_${helperNameMap[key]}`;
      },
      push(code, node) {
        context.code += code;
      },
      indent() {
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      }
    };
    function newline(n) {
      context.push("\n" + `  `.repeat(n));
    }
    return context;
  }
  function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated)
      options.onContextCreated(context);
    const {mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr} = context;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    const preambleContext = context;
    {
      genFunctionPreamble(ast, preambleContext);
    }
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
    const signature = args.join(", ");
    {
      push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
      push(`with (_ctx) {`);
      indent();
      if (hasHelpers) {
        push(`const { ${ast.helpers.map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`).join(", ")} } = _Vue`);
        push(`
`);
        newline();
      }
    }
    if (ast.components.length) {
      genAssets(ast.components, "component", context);
      if (ast.directives.length || ast.temps > 0) {
        newline();
      }
    }
    if (ast.directives.length) {
      genAssets(ast.directives, "directive", context);
      if (ast.temps > 0) {
        newline();
      }
    }
    if (ast.filters && ast.filters.length) {
      newline();
      genAssets(ast.filters, "filter", context);
      newline();
    }
    if (ast.temps > 0) {
      push(`let `);
      for (let i = 0; i < ast.temps; i++) {
        push(`${i > 0 ? `, ` : ``}_temp${i}`);
      }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
      push(`
`);
      newline();
    }
    if (!ssr) {
      push(`return `);
    }
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }
    if (useWithBlock) {
      deindent();
      push(`}`);
    }
    deindent();
    push(`}`);
    return {
      ast,
      code: context.code,
      preamble: ``,
      map: context.map ? context.map.toJSON() : void 0
    };
  }
  function genFunctionPreamble(ast, context) {
    const {ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName} = context;
    const VueBinding = runtimeGlobalName;
    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    if (ast.helpers.length > 0) {
      {
        push(`const _Vue = ${VueBinding}
`);
        if (ast.hoists.length) {
          const staticHelpers = [
            CREATE_VNODE,
            CREATE_ELEMENT_VNODE,
            CREATE_COMMENT,
            CREATE_TEXT,
            CREATE_STATIC
          ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
          push(`const { ${staticHelpers} } = _Vue
`);
        }
      }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
  }
  function genAssets(assets, type, {helper, push, newline, isTS}) {
    const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
    for (let i = 0; i < assets.length; i++) {
      let id = assets[i];
      const maybeSelfReference = id.endsWith("__self");
      if (maybeSelfReference) {
        id = id.slice(0, -6);
      }
      push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
      if (i < assets.length - 1) {
        newline();
      }
    }
  }
  function genHoists(hoists, context) {
    if (!hoists.length) {
      return;
    }
    context.pure = true;
    const {push, newline, helper, scopeId, mode} = context;
    newline();
    hoists.forEach((exp, i) => {
      if (exp) {
        push(`const _hoisted_${i + 1} = `);
        genNode(exp, context);
        newline();
      }
    });
    context.pure = false;
  }
  function isText$1(n) {
    return (0, import_shared2.isString)(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
  }
  function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 || process.env.NODE_ENV !== "production" && nodes.some((n) => (0, import_shared2.isArray)(n) || !isText$1(n));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
  }
  function genNodeList(nodes, context, multilines = false, comma = true) {
    const {push, newline} = context;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if ((0, import_shared2.isString)(node)) {
        push(node);
      } else if ((0, import_shared2.isArray)(node)) {
        genNodeListAsArray(node, context);
      } else {
        genNode(node, context);
      }
      if (i < nodes.length - 1) {
        if (multilines) {
          comma && push(",");
          newline();
        } else {
          comma && push(", ");
        }
      }
    }
  }
  function genNode(node, context) {
    if ((0, import_shared2.isString)(node)) {
      context.push(node);
      return;
    }
    if ((0, import_shared2.isSymbol)(node)) {
      context.push(context.helper(node));
      return;
    }
    switch (node.type) {
      case 1:
      case 9:
      case 11:
        process.env.NODE_ENV !== "production" && assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
        genNode(node.codegenNode, context);
        break;
      case 2:
        genText(node, context);
        break;
      case 4:
        genExpression(node, context);
        break;
      case 5:
        genInterpolation(node, context);
        break;
      case 12:
        genNode(node.codegenNode, context);
        break;
      case 8:
        genCompoundExpression(node, context);
        break;
      case 3:
        genComment(node, context);
        break;
      case 13:
        genVNodeCall(node, context);
        break;
      case 14:
        genCallExpression(node, context);
        break;
      case 15:
        genObjectExpression(node, context);
        break;
      case 17:
        genArrayExpression(node, context);
        break;
      case 18:
        genFunctionExpression(node, context);
        break;
      case 19:
        genConditionalExpression(node, context);
        break;
      case 20:
        genCacheExpression(node, context);
        break;
      case 21:
        genNodeList(node.body, context, true, false);
        break;
      case 22:
        break;
      case 23:
        break;
      case 24:
        break;
      case 25:
        break;
      case 26:
        break;
      case 10:
        break;
      default:
        if (process.env.NODE_ENV !== "production") {
          assert(false, `unhandled codegen node type: ${node.type}`);
          const exhaustiveCheck = node;
          return exhaustiveCheck;
        }
    }
  }
  function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
  }
  function genExpression(node, context) {
    const {content, isStatic} = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
  }
  function genInterpolation(node, context) {
    const {push, helper, pure} = context;
    if (pure)
      push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
  }
  function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if ((0, import_shared2.isString)(child)) {
        context.push(child);
      } else {
        genNode(child, context);
      }
    }
  }
  function genExpressionAsPropertyKey(node, context) {
    const {push} = context;
    if (node.type === 8) {
      push(`[`);
      genCompoundExpression(node, context);
      push(`]`);
    } else if (node.isStatic) {
      const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
      push(text, node);
    } else {
      push(`[${node.content}]`, node);
    }
  }
  function genComment(node, context) {
    const {push, helper, pure} = context;
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
  }
  function genVNodeCall(node, context) {
    const {push, helper, pure} = context;
    const {tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2} = node;
    if (directives) {
      push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
      push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
      push(PURE_ANNOTATION);
    }
    const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
    push(helper(callHelper) + `(`, node);
    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
    push(`)`);
    if (isBlock) {
      push(`)`);
    }
    if (directives) {
      push(`, `);
      genNode(directives, context);
      push(`)`);
    }
  }
  function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
      if (args[i] != null)
        break;
    }
    return args.slice(0, i + 1).map((arg) => arg || `null`);
  }
  function genCallExpression(node, context) {
    const {push, helper, pure} = context;
    const callee = (0, import_shared2.isString)(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context);
    push(`)`);
  }
  function genObjectExpression(node, context) {
    const {push, indent, deindent, newline} = context;
    const {properties} = node;
    if (!properties.length) {
      push(`{}`, node);
      return;
    }
    const multilines = properties.length > 1 || process.env.NODE_ENV !== "production" && properties.some((p) => p.value.type !== 4);
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
      const {key, value} = properties[i];
      genExpressionAsPropertyKey(key, context);
      push(`: `);
      genNode(value, context);
      if (i < properties.length - 1) {
        push(`,`);
        newline();
      }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
  }
  function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
  }
  function genFunctionExpression(node, context) {
    const {push, indent, deindent} = context;
    const {params, returns, body, newline, isSlot} = node;
    if (isSlot) {
      push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if ((0, import_shared2.isArray)(params)) {
      genNodeList(params, context);
    } else if (params) {
      genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
      push(`{`);
      indent();
    }
    if (returns) {
      if (newline) {
        push(`return `);
      }
      if ((0, import_shared2.isArray)(returns)) {
        genNodeListAsArray(returns, context);
      } else {
        genNode(returns, context);
      }
    } else if (body) {
      genNode(body, context);
    }
    if (newline || body) {
      deindent();
      push(`}`);
    }
    if (isSlot) {
      if (node.isNonScopedSlot) {
        push(`, undefined, true`);
      }
      push(`)`);
    }
  }
  function genConditionalExpression(node, context) {
    const {test, consequent, alternate, newline: needNewline} = node;
    const {push, indent, deindent, newline} = context;
    if (test.type === 4) {
      const needsParens = !isSimpleIdentifier(test.content);
      needsParens && push(`(`);
      genExpression(test, context);
      needsParens && push(`)`);
    } else {
      push(`(`);
      genNode(test, context);
      push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19;
    if (!isNested) {
      context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
      context.indentLevel--;
    }
    needNewline && deindent(true);
  }
  function genCacheExpression(node, context) {
    const {push, helper, indent, deindent, newline} = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
      indent();
      push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
      newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
      push(`,`);
      newline();
      push(`${helper(SET_BLOCK_TRACKING)}(1),`);
      newline();
      push(`_cache[${node.index}]`);
      deindent();
    }
    push(`)`);
  }
  var prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
  function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    if (!exp.trim()) {
      return;
    }
    try {
      new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
    } catch (e) {
      let message = e.message;
      const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
      if (keywordMatch) {
        message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
      }
      context.onError(createCompilerError(43, node.loc, void 0, message));
    }
  }
  var transformExpression = (node, context) => {
    if (node.type === 5) {
      node.content = processExpression(node.content, context);
    } else if (node.type === 1) {
      for (let i = 0; i < node.props.length; i++) {
        const dir = node.props[i];
        if (dir.type === 7 && dir.name !== "for") {
          const exp = dir.exp;
          const arg = dir.arg;
          if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
            dir.exp = processExpression(exp, context, dir.name === "slot");
          }
          if (arg && arg.type === 4 && !arg.isStatic) {
            dir.arg = processExpression(arg, context);
          }
        }
      }
    }
  };
  function processExpression(node, context, asParams = false, asRawStatements = false) {
    {
      if (process.env.NODE_ENV !== "production") {
        validateBrowserExpression(node, context, asParams, asRawStatements);
      }
      return node;
    }
  }
  var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children;
      let i = siblings.indexOf(ifNode);
      let key = 0;
      while (i-- >= 0) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 9) {
          key += sibling.branches.length;
        }
      }
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
        } else {
          const parentCondition = getParentCondition(ifNode.codegenNode);
          parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
        }
      };
    });
  });
  function processIf(node, dir, context, processCodegen) {
    if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
      const loc = dir.exp ? dir.exp.loc : node.loc;
      context.onError(createCompilerError(27, dir.loc));
      dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if (process.env.NODE_ENV !== "production" && true && dir.exp) {
      validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === "if") {
      const branch = createIfBranch(node, dir);
      const ifNode = {
        type: 9,
        loc: node.loc,
        branches: [branch]
      };
      context.replaceNode(ifNode);
      if (processCodegen) {
        return processCodegen(ifNode, branch, true);
      }
    } else {
      const siblings = context.parent.children;
      const comments = [];
      let i = siblings.indexOf(node);
      while (i-- >= -1) {
        const sibling = siblings[i];
        if (process.env.NODE_ENV !== "production" && sibling && sibling.type === 3) {
          context.removeNode(sibling);
          comments.unshift(sibling);
          continue;
        }
        if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
          context.removeNode(sibling);
          continue;
        }
        if (sibling && sibling.type === 9) {
          context.removeNode();
          const branch = createIfBranch(node, dir);
          if (process.env.NODE_ENV !== "production" && comments.length && !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
            branch.children = [...comments, ...branch.children];
          }
          if (process.env.NODE_ENV !== "production" || false) {
            const key = branch.userKey;
            if (key) {
              sibling.branches.forEach(({userKey}) => {
                if (isSameKey(userKey, key)) {
                  context.onError(createCompilerError(28, branch.userKey.loc));
                }
              });
            }
          }
          sibling.branches.push(branch);
          const onExit = processCodegen && processCodegen(sibling, branch, false);
          traverseNode(branch, context);
          if (onExit)
            onExit();
          context.currentNode = null;
        } else {
          context.onError(createCompilerError(29, node.loc));
        }
        break;
      }
    }
  }
  function createIfBranch(node, dir) {
    return {
      type: 10,
      loc: node.loc,
      condition: dir.name === "else" ? void 0 : dir.exp,
      children: node.tagType === 3 && !findDir(node, "for") ? node.children : [node],
      userKey: findProp(node, `key`)
    };
  }
  function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
      return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), [
        process.env.NODE_ENV !== "production" ? '"v-if"' : '""',
        "true"
      ]));
    } else {
      return createChildrenCodegenNode(branch, keyIndex, context);
    }
  }
  function createChildrenCodegenNode(branch, keyIndex, context) {
    const {helper} = context;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
    const {children} = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
    if (needFragmentWrapper) {
      if (children.length === 1 && firstChild.type === 11) {
        const vnodeCall = firstChild.codegenNode;
        injectProp(vnodeCall, keyProperty, context);
        return vnodeCall;
      } else {
        let patchFlag = 64;
        let patchFlagText = import_shared2.PatchFlagNames[64];
        if (process.env.NODE_ENV !== "production" && children.filter((c) => c.type !== 3).length === 1) {
          patchFlag |= 2048;
          patchFlagText += `, ${import_shared2.PatchFlagNames[2048]}`;
        }
        return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (process.env.NODE_ENV !== "production" ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, false, branch.loc);
      }
    } else {
      const ret = firstChild.codegenNode;
      const vnodeCall = getMemoedVNodeCall(ret);
      if (vnodeCall.type === 13) {
        makeBlock(vnodeCall, context);
      }
      injectProp(vnodeCall, keyProperty, context);
      return ret;
    }
  }
  function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
      return false;
    }
    if (a.type === 6) {
      if (a.value.content !== b.value.content) {
        return false;
      }
    } else {
      const exp = a.exp;
      const branchExp = b.exp;
      if (exp.type !== branchExp.type) {
        return false;
      }
      if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
        return false;
      }
    }
    return true;
  }
  function getParentCondition(node) {
    while (true) {
      if (node.type === 19) {
        if (node.alternate.type === 19) {
          node = node.alternate;
        } else {
          return node;
        }
      } else if (node.type === 20) {
        node = node.value;
      }
    }
  }
  var transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
    const {helper, removeHelper} = context;
    return processFor(node, dir, context, (forNode) => {
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ]);
      const memo = findDir(node, "memo");
      const keyProp = findProp(node, `key`);
      const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
      forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (process.env.NODE_ENV !== "production" ? ` /* ${import_shared2.PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, false, node.loc);
      return () => {
        let childBlock;
        const isTemplate = isTemplateNode(node);
        const {children} = forNode;
        if ((process.env.NODE_ENV !== "production" || false) && isTemplate) {
          node.children.some((c) => {
            if (c.type === 1) {
              const key = findProp(c, "key");
              if (key) {
                context.onError(createCompilerError(32, key.loc));
                return true;
              }
            }
          });
        }
        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
        if (slotOutlet) {
          childBlock = slotOutlet.codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
        } else if (needFragmentWrapper) {
          childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + (process.env.NODE_ENV !== "production" ? ` /* ${import_shared2.PatchFlagNames[64]} */` : ``), void 0, void 0, true, void 0, false);
        } else {
          childBlock = children[0].codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              removeHelper(OPEN_BLOCK);
              removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
            } else {
              removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
            }
          }
          childBlock.isBlock = !isStableFragment;
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        if (memo) {
          const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
            createSimpleExpression(`_cached`)
          ]));
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...keyExp ? [` && _cached.key === `, keyExp] : [],
              ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ]);
          renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
        } else {
          renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
        }
      };
    });
  });
  function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
      context.onError(createCompilerError(30, dir.loc));
      return;
    }
    const parseResult = parseForExpression(dir.exp, context);
    if (!parseResult) {
      context.onError(createCompilerError(31, dir.loc));
      return;
    }
    const {addIdentifiers, removeIdentifiers, scopes} = context;
    const {source, value, key, index} = parseResult;
    const forNode = {
      type: 11,
      loc: dir.loc,
      source,
      valueAlias: value,
      keyAlias: key,
      objectIndexAlias: index,
      parseResult,
      children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
      scopes.vFor--;
      if (onExit)
        onExit();
    };
  }
  var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;
  function parseForExpression(input, context) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
      return;
    const [, LHS, RHS] = inMatch;
    const result = {
      source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
      value: void 0,
      key: void 0,
      index: void 0
    };
    if (process.env.NODE_ENV !== "production" && true) {
      validateBrowserExpression(result.source, context);
    }
    let valueContent = LHS.trim().replace(stripParensRE, "").trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
      valueContent = valueContent.replace(forIteratorRE, "").trim();
      const keyContent = iteratorMatch[1].trim();
      let keyOffset;
      if (keyContent) {
        keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
        result.key = createAliasExpression(loc, keyContent, keyOffset);
        if (process.env.NODE_ENV !== "production" && true) {
          validateBrowserExpression(result.key, context, true);
        }
      }
      if (iteratorMatch[2]) {
        const indexContent = iteratorMatch[2].trim();
        if (indexContent) {
          result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
          if (process.env.NODE_ENV !== "production" && true) {
            validateBrowserExpression(result.index, context, true);
          }
        }
      }
    }
    if (valueContent) {
      result.value = createAliasExpression(loc, valueContent, trimmedOffset);
      if (process.env.NODE_ENV !== "production" && true) {
        validateBrowserExpression(result.value, context, true);
      }
    }
    return result;
  }
  function createAliasExpression(range, content, offset) {
    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
  }
  function createForLoopParams({value, key, index}, memoArgs = []) {
    return createParamsList([value, key, index, ...memoArgs]);
  }
  function createParamsList(args) {
    let i = args.length;
    while (i--) {
      if (args[i])
        break;
    }
    return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
  }
  var defaultFallback = createSimpleExpression(`undefined`, false);
  var trackSlotScopes = (node, context) => {
    if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
      const vSlot = findDir(node, "slot");
      if (vSlot) {
        vSlot.exp;
        context.scopes.vSlot++;
        return () => {
          context.scopes.vSlot--;
        };
      }
    }
  };
  var trackVForSlotScopes = (node, context) => {
    let vFor;
    if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
      const result = vFor.parseResult = parseForExpression(vFor.exp, context);
      if (result) {
        const {value, key, index} = result;
        const {addIdentifiers, removeIdentifiers} = context;
        value && addIdentifiers(value);
        key && addIdentifiers(key);
        index && addIdentifiers(index);
        return () => {
          value && removeIdentifiers(value);
          key && removeIdentifiers(key);
          index && removeIdentifiers(index);
        };
      }
    }
  };
  var buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const {children, loc} = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    const onComponentSlot = findDir(node, "slot", true);
    if (onComponentSlot) {
      const {arg, exp} = onComponentSlot;
      if (arg && !isStaticExp(arg)) {
        hasDynamicSlots = true;
      }
      slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
    }
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = new Set();
    for (let i = 0; i < children.length; i++) {
      const slotElement = children[i];
      let slotDir;
      if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
        if (slotElement.type !== 3) {
          implicitDefaultChildren.push(slotElement);
        }
        continue;
      }
      if (onComponentSlot) {
        context.onError(createCompilerError(36, slotDir.loc));
        break;
      }
      hasTemplateSlots = true;
      const {children: slotChildren, loc: slotLoc} = slotElement;
      const {arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc} = slotDir;
      let staticSlotName;
      if (isStaticExp(slotName)) {
        staticSlotName = slotName ? slotName.content : `default`;
      } else {
        hasDynamicSlots = true;
      }
      const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
      let vIf;
      let vElse;
      let vFor;
      if (vIf = findDir(slotElement, "if")) {
        hasDynamicSlots = true;
        dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
      } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
        let j = i;
        let prev;
        while (j--) {
          prev = children[j];
          if (prev.type !== 3) {
            break;
          }
        }
        if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
          children.splice(i, 1);
          i--;
          let conditional = dynamicSlots[dynamicSlots.length - 1];
          while (conditional.alternate.type === 19) {
            conditional = conditional.alternate;
          }
          conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
        } else {
          context.onError(createCompilerError(29, vElse.loc));
        }
      } else if (vFor = findDir(slotElement, "for")) {
        hasDynamicSlots = true;
        const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
        if (parseResult) {
          dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
          ]));
        } else {
          context.onError(createCompilerError(31, vFor.loc));
        }
      } else {
        if (staticSlotName) {
          if (seenSlotNames.has(staticSlotName)) {
            context.onError(createCompilerError(37, dirLoc));
            continue;
          }
          seenSlotNames.add(staticSlotName);
          if (staticSlotName === "default") {
            hasNamedDefaultSlot = true;
          }
        }
        slotsProperties.push(createObjectProperty(slotName, slotFunction));
      }
    }
    if (!onComponentSlot) {
      const buildDefaultSlotProperty = (props, children2) => {
        const fn = buildSlotFn(props, children2, loc);
        if (context.compatConfig) {
          fn.isNonScopedSlot = true;
        }
        return createObjectProperty(`default`, fn);
      };
      if (!hasTemplateSlots) {
        slotsProperties.push(buildDefaultSlotProperty(void 0, children));
      } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
        if (hasNamedDefaultSlot) {
          context.onError(createCompilerError(38, implicitDefaultChildren[0].loc));
        } else {
          slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
        }
      }
    }
    const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + (process.env.NODE_ENV !== "production" ? ` /* ${import_shared2.slotFlagsText[slotFlag]} */` : ``), false))), loc);
    if (dynamicSlots.length) {
      slots = createCallExpression(context.helper(CREATE_SLOTS), [
        slots,
        createArrayExpression(dynamicSlots)
      ]);
    }
    return {
      slots,
      hasDynamicSlots
    };
  }
  function buildDynamicSlot(name, fn) {
    return createObjectExpression([
      createObjectProperty(`name`, name),
      createObjectProperty(`fn`, fn)
    ]);
  }
  function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      switch (child.type) {
        case 1:
          if (child.tagType === 2 || hasForwardedSlots(child.children)) {
            return true;
          }
          break;
        case 9:
          if (hasForwardedSlots(child.branches))
            return true;
          break;
        case 10:
        case 11:
          if (hasForwardedSlots(child.children))
            return true;
          break;
      }
    }
    return false;
  }
  function isNonWhitespaceContent(node) {
    if (node.type !== 2 && node.type !== 12)
      return true;
    return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
  }
  var directiveImportMap = new WeakMap();
  var transformElement = (node, context) => {
    return function postTransformElement() {
      node = context.currentNode;
      if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
        return;
      }
      const {tag, props} = node;
      const isComponent2 = node.tagType === 1;
      let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
      const isDynamicComponent = (0, import_shared2.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
      let vnodeProps;
      let vnodeChildren;
      let vnodePatchFlag;
      let patchFlag = 0;
      let vnodeDynamicProps;
      let dynamicPropNames;
      let vnodeDirectives;
      let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject" || findProp(node, "key", true));
      if (props.length > 0) {
        const propsBuildResult = buildProps(node, context);
        vnodeProps = propsBuildResult.props;
        patchFlag = propsBuildResult.patchFlag;
        dynamicPropNames = propsBuildResult.dynamicPropNames;
        const directives = propsBuildResult.directives;
        vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
      }
      if (node.children.length > 0) {
        if (vnodeTag === KEEP_ALIVE) {
          shouldUseBlock = true;
          patchFlag |= 1024;
          if (process.env.NODE_ENV !== "production" && node.children.length > 1) {
            context.onError(createCompilerError(44, {
              start: node.children[0].loc.start,
              end: node.children[node.children.length - 1].loc.end,
              source: ""
            }));
          }
        }
        const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
        if (shouldBuildAsSlots) {
          const {slots, hasDynamicSlots} = buildSlots(node, context);
          vnodeChildren = slots;
          if (hasDynamicSlots) {
            patchFlag |= 1024;
          }
        } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
          const child = node.children[0];
          const type = child.type;
          const hasDynamicTextChild = type === 5 || type === 8;
          if (hasDynamicTextChild && getConstantType(child, context) === 0) {
            patchFlag |= 1;
          }
          if (hasDynamicTextChild || type === 2) {
            vnodeChildren = child;
          } else {
            vnodeChildren = node.children;
          }
        } else {
          vnodeChildren = node.children;
        }
      }
      if (patchFlag !== 0) {
        if (process.env.NODE_ENV !== "production") {
          if (patchFlag < 0) {
            vnodePatchFlag = patchFlag + ` /* ${import_shared2.PatchFlagNames[patchFlag]} */`;
          } else {
            const flagNames = Object.keys(import_shared2.PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => import_shared2.PatchFlagNames[n]).join(`, `);
            vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
          }
        } else {
          vnodePatchFlag = String(patchFlag);
        }
        if (dynamicPropNames && dynamicPropNames.length) {
          vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
        }
      }
      node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
    };
  };
  function resolveComponentType(node, context, ssr = false) {
    let {tag} = node;
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(node, "is");
    if (isProp) {
      if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
        const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
        if (exp) {
          return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            exp
          ]);
        }
      } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
        tag = isProp.value.content.slice(4);
      }
    }
    const isDir = !isExplicitDynamic && findDir(node, "is");
    if (isDir && isDir.exp) {
      return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
        isDir.exp
      ]);
    }
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
      if (!ssr)
        context.helper(builtIn);
      return builtIn;
    }
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
  }
  function buildProps(node, context, props = node.props, ssr = false) {
    const {tag, loc: elementLoc} = node;
    const isComponent2 = node.tagType === 1;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const analyzePatchFlag = ({key, value}) => {
      if (isStaticExp(key)) {
        const name = key.content;
        const isEventHandler = (0, import_shared2.isOn)(name);
        if (!isComponent2 && isEventHandler && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !(0, import_shared2.isReservedProp)(name)) {
          hasHydrationEventBinding = true;
        }
        if (isEventHandler && (0, import_shared2.isReservedProp)(name)) {
          hasVnodeHook = true;
        }
        if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
          return;
        }
        if (name === "ref") {
          hasRef = true;
        } else if (name === "class") {
          hasClassBinding = true;
        } else if (name === "style") {
          hasStyleBinding = true;
        } else if (name !== "key" && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
        if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
      } else {
        hasDynamicKeys = true;
      }
    };
    for (let i = 0; i < props.length; i++) {
      const prop = props[i];
      if (prop.type === 6) {
        const {loc, name, value} = prop;
        let isStatic = true;
        if (name === "ref") {
          hasRef = true;
        }
        if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
          continue;
        }
        properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
      } else {
        const {name, arg, exp, loc} = prop;
        const isVBind = name === "bind";
        const isVOn = name === "on";
        if (name === "slot") {
          if (!isComponent2) {
            context.onError(createCompilerError(39, loc));
          }
          continue;
        }
        if (name === "once" || name === "memo") {
          continue;
        }
        if (name === "is" || isVBind && isBindKey(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
          continue;
        }
        if (isVOn && ssr) {
          continue;
        }
        if (!arg && (isVBind || isVOn)) {
          hasDynamicKeys = true;
          if (exp) {
            if (properties.length) {
              mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
              properties = [];
            }
            if (isVBind) {
              {
                if (process.env.NODE_ENV !== "production") {
                  const hasOverridableKeys = mergeArgs.some((arg2) => {
                    if (arg2.type === 15) {
                      return arg2.properties.some(({key}) => {
                        if (key.type !== 4 || !key.isStatic) {
                          return true;
                        }
                        return key.content !== "class" && key.content !== "style" && !(0, import_shared2.isOn)(key.content);
                      });
                    } else {
                      return true;
                    }
                  });
                  if (hasOverridableKeys) {
                    checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context, loc);
                  }
                }
                if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                  mergeArgs.unshift(exp);
                  continue;
                }
              }
              mergeArgs.push(exp);
            } else {
              mergeArgs.push({
                type: 14,
                loc,
                callee: context.helper(TO_HANDLERS),
                arguments: [exp]
              });
            }
          } else {
            context.onError(createCompilerError(isVBind ? 33 : 34, loc));
          }
          continue;
        }
        const directiveTransform = context.directiveTransforms[name];
        if (directiveTransform) {
          const {props: props2, needRuntime} = directiveTransform(prop, node, context);
          !ssr && props2.forEach(analyzePatchFlag);
          properties.push(...props2);
          if (needRuntime) {
            runtimeDirectives.push(prop);
            if ((0, import_shared2.isSymbol)(needRuntime)) {
              directiveImportMap.set(prop, needRuntime);
            }
          }
        } else {
          runtimeDirectives.push(prop);
        }
      }
      if (prop.type === 6 && prop.name === "ref" && context.scopes.vFor > 0 && checkCompatEnabled("COMPILER_V_FOR_REF", context, prop.loc)) {
        properties.push(createObjectProperty(createSimpleExpression("refInFor", true), createSimpleExpression("true", false)));
      }
    }
    let propsExpression = void 0;
    if (mergeArgs.length) {
      if (properties.length) {
        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
      }
      if (mergeArgs.length > 1) {
        propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
      } else {
        propsExpression = mergeArgs[0];
      }
    } else if (properties.length) {
      propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    if (hasDynamicKeys) {
      patchFlag |= 16;
    } else {
      if (hasClassBinding && !isComponent2) {
        patchFlag |= 2;
      }
      if (hasStyleBinding && !isComponent2) {
        patchFlag |= 4;
      }
      if (dynamicPropNames.length) {
        patchFlag |= 8;
      }
      if (hasHydrationEventBinding) {
        patchFlag |= 32;
      }
    }
    if ((patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
      patchFlag |= 512;
    }
    if (!context.inSSR && propsExpression) {
      switch (propsExpression.type) {
        case 15:
          let classKeyIndex = -1;
          let styleKeyIndex = -1;
          let hasDynamicKey = false;
          for (let i = 0; i < propsExpression.properties.length; i++) {
            const key = propsExpression.properties[i].key;
            if (isStaticExp(key)) {
              if (key.content === "class") {
                classKeyIndex = i;
              } else if (key.content === "style") {
                styleKeyIndex = i;
              }
            } else if (!key.isHandlerKey) {
              hasDynamicKey = true;
            }
          }
          const classProp = propsExpression.properties[classKeyIndex];
          const styleProp = propsExpression.properties[styleKeyIndex];
          if (!hasDynamicKey) {
            if (classProp && !isStaticExp(classProp.value)) {
              classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
            }
            if (styleProp && !isStaticExp(styleProp.value) && (hasStyleBinding || styleProp.value.type === 17)) {
              styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
            }
          } else {
            propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
          }
          break;
        case 14:
          break;
        default:
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]);
          break;
      }
    }
    return {
      props: propsExpression,
      directives: runtimeDirectives,
      patchFlag,
      dynamicPropNames
    };
  }
  function dedupeProperties(properties) {
    const knownProps = new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
      const prop = properties[i];
      if (prop.key.type === 8 || !prop.key.isStatic) {
        deduped.push(prop);
        continue;
      }
      const name = prop.key.content;
      const existing = knownProps.get(name);
      if (existing) {
        if (name === "style" || name === "class" || name.startsWith("on")) {
          mergeAsArray(existing, prop);
        }
      } else {
        knownProps.set(name, prop);
        deduped.push(prop);
      }
    }
    return deduped;
  }
  function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17) {
      existing.value.elements.push(incoming.value);
    } else {
      existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
  }
  function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
      dirArgs.push(context.helperString(runtime));
    } else {
      {
        context.helper(RESOLVE_DIRECTIVE);
        context.directives.add(dir.name);
        dirArgs.push(toValidAssetId(dir.name, `directive`));
      }
    }
    const {loc} = dir;
    if (dir.exp)
      dirArgs.push(dir.exp);
    if (dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
      if (!dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(`void 0`);
      }
      const trueExpression = createSimpleExpression(`true`, false, loc);
      dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
  }
  function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
      propsNamesString += JSON.stringify(props[i]);
      if (i < l - 1)
        propsNamesString += ", ";
    }
    return propsNamesString + `]`;
  }
  function isComponentTag(tag) {
    return tag[0].toLowerCase() + tag.slice(1) === "component";
  }
  process.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
  process.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
  var cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  var transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
      const {children, loc} = node;
      const {slotName, slotProps} = processSlotOutlet(node, context);
      const slotArgs = [
        context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
        slotName
      ];
      if (slotProps) {
        slotArgs.push(slotProps);
      }
      if (children.length) {
        if (!slotProps) {
          slotArgs.push(`{}`);
        }
        slotArgs.push(createFunctionExpression([], children, false, false, loc));
      }
      if (context.scopeId && !context.slotted) {
        if (!slotProps) {
          slotArgs.push(`{}`);
        }
        if (!children.length) {
          slotArgs.push(`undefined`);
        }
        slotArgs.push(`true`);
      }
      node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
    }
  };
  function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = void 0;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i];
      if (p.type === 6) {
        if (p.value) {
          if (p.name === "name") {
            slotName = JSON.stringify(p.value.content);
          } else {
            p.name = camelize(p.name);
            nonNameProps.push(p);
          }
        }
      } else {
        if (p.name === "bind" && isBindKey(p.arg, "name")) {
          if (p.exp)
            slotName = p.exp;
        } else {
          if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
            p.arg.content = camelize(p.arg.content);
          }
          nonNameProps.push(p);
        }
      }
    }
    if (nonNameProps.length > 0) {
      const {props, directives} = buildProps(node, context, nonNameProps);
      slotProps = props;
      if (directives.length) {
        context.onError(createCompilerError(35, directives[0].loc));
      }
    }
    return {
      slotName,
      slotProps
    };
  }
  var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/;
  var transformOn = (dir, node, context, augmentor) => {
    const {loc, modifiers, arg} = dir;
    if (!dir.exp && !modifiers.length) {
      context.onError(createCompilerError(34, loc));
    }
    let eventName;
    if (arg.type === 4) {
      if (arg.isStatic) {
        const rawName = arg.content;
        eventName = createSimpleExpression((0, import_shared2.toHandlerKey)((0, import_shared2.camelize)(rawName)), true, arg.loc);
      } else {
        eventName = createCompoundExpression([
          `${context.helperString(TO_HANDLER_KEY)}(`,
          arg,
          `)`
        ]);
      }
    } else {
      eventName = arg;
      eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
      eventName.children.push(`)`);
    }
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
      exp = void 0;
    }
    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
    if (exp) {
      const isMemberExp = isMemberExpression(exp.content);
      const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
      const hasMultipleStatements = exp.content.includes(`;`);
      if (process.env.NODE_ENV !== "production" && true) {
        validateBrowserExpression(exp, context, false, hasMultipleStatements);
      }
      if (isInlineStatement || shouldCache && isMemberExp) {
        exp = createCompoundExpression([
          `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
          exp,
          hasMultipleStatements ? `}` : `)`
        ]);
      }
    }
    let ret = {
      props: [
        createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
      ]
    };
    if (augmentor) {
      ret = augmentor(ret);
    }
    if (shouldCache) {
      ret.props[0].value = context.cache(ret.props[0].value);
    }
    ret.props.forEach((p) => p.key.isHandlerKey = true);
    return ret;
  };
  var transformBind = (dir, _node, context) => {
    const {exp, modifiers, loc} = dir;
    const arg = dir.arg;
    if (arg.type !== 4) {
      arg.children.unshift(`(`);
      arg.children.push(`) || ""`);
    } else if (!arg.isStatic) {
      arg.content = `${arg.content} || ""`;
    }
    if (modifiers.includes("camel")) {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = (0, import_shared2.camelize)(arg.content);
        } else {
          arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
        }
      } else {
        arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
        arg.children.push(`)`);
      }
    }
    if (!context.inSSR) {
      if (modifiers.includes("prop")) {
        injectPrefix(arg, ".");
      }
      if (modifiers.includes("attr")) {
        injectPrefix(arg, "^");
      }
    }
    if (!exp || exp.type === 4 && !exp.content.trim()) {
      context.onError(createCompilerError(33, loc));
      return {
        props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
      };
    }
    return {
      props: [createObjectProperty(arg, exp)]
    };
  };
  var injectPrefix = (arg, prefix) => {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = prefix + arg.content;
      } else {
        arg.content = `\`${prefix}\${${arg.content}}\``;
      }
    } else {
      arg.children.unshift(`'${prefix}' + (`);
      arg.children.push(`)`);
    }
  };
  var transformText = (node, context) => {
    if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
      return () => {
        const children = node.children;
        let currentContainer = void 0;
        let hasText = false;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isText(child)) {
            hasText = true;
            for (let j = i + 1; j < children.length; j++) {
              const next = children[j];
              if (isText(next)) {
                if (!currentContainer) {
                  currentContainer = children[i] = {
                    type: 8,
                    loc: child.loc,
                    children: [child]
                  };
                }
                currentContainer.children.push(` + `, next);
                children.splice(j, 1);
                j--;
              } else {
                currentContainer = void 0;
                break;
              }
            }
          }
        }
        if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p) => p.type === 7 && !context.directiveTransforms[p.name]) && !(node.tag === "template"))) {
          return;
        }
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isText(child) || child.type === 8) {
            const callArgs = [];
            if (child.type !== 2 || child.content !== " ") {
              callArgs.push(child);
            }
            if (!context.ssr && getConstantType(child, context) === 0) {
              callArgs.push(1 + (process.env.NODE_ENV !== "production" ? ` /* ${import_shared2.PatchFlagNames[1]} */` : ``));
            }
            children[i] = {
              type: 12,
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
            };
          }
        }
      };
    }
  };
  var seen = new WeakSet();
  var transformOnce = (node, context) => {
    if (node.type === 1 && findDir(node, "once", true)) {
      if (seen.has(node) || context.inVOnce) {
        return;
      }
      seen.add(node);
      context.inVOnce = true;
      context.helper(SET_BLOCK_TRACKING);
      return () => {
        context.inVOnce = false;
        const cur = context.currentNode;
        if (cur.codegenNode) {
          cur.codegenNode = context.cache(cur.codegenNode, true);
        }
      };
    }
  };
  var transformModel = (dir, node, context) => {
    const {exp, arg} = dir;
    if (!exp) {
      context.onError(createCompilerError(40, dir.loc));
      return createTransformProps();
    }
    const rawExp = exp.loc.source;
    const expString = exp.type === 4 ? exp.content : rawExp;
    context.bindingMetadata[rawExp];
    const maybeRef = false;
    if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
      context.onError(createCompilerError(41, exp.loc));
      return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression("modelValue", true);
    const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
      assignmentExp = createCompoundExpression([
        `${eventArg} => (`,
        exp,
        ` = $event)`
      ]);
    }
    const props = [
      createObjectProperty(propName, dir.exp),
      createObjectProperty(eventName, assignmentExp)
    ];
    if (dir.modifiers.length && node.tagType === 1) {
      const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
      const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
      props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
    }
    return createTransformProps(props);
  };
  function createTransformProps(props = []) {
    return {props};
  }
  var validDivisionCharRE = /[\w).+\-_$\]]/;
  var transformFilter = (node, context) => {
    if (!isCompatEnabled("COMPILER_FILTER", context)) {
      return;
    }
    if (node.type === 5) {
      rewriteFilter(node.content, context);
    }
    if (node.type === 1) {
      node.props.forEach((prop) => {
        if (prop.type === 7 && prop.name !== "for" && prop.exp) {
          rewriteFilter(prop.exp, context);
        }
      });
    }
  };
  function rewriteFilter(node, context) {
    if (node.type === 4) {
      parseFilter(node, context);
    } else {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (typeof child !== "object")
          continue;
        if (child.type === 4) {
          parseFilter(child, context);
        } else if (child.type === 8) {
          rewriteFilter(node, context);
        } else if (child.type === 5) {
          rewriteFilter(child.content, context);
        }
      }
    }
  }
  function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters = [];
    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 39 && prev !== 92)
          inSingle = false;
      } else if (inDouble) {
        if (c === 34 && prev !== 92)
          inDouble = false;
      } else if (inTemplateString) {
        if (c === 96 && prev !== 92)
          inTemplateString = false;
      } else if (inRegex) {
        if (c === 47 && prev !== 92)
          inRegex = false;
      } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
        if (expression === void 0) {
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 34:
            inDouble = true;
            break;
          case 39:
            inSingle = true;
            break;
          case 96:
            inTemplateString = true;
            break;
          case 40:
            paren++;
            break;
          case 41:
            paren--;
            break;
          case 91:
            square++;
            break;
          case 93:
            square--;
            break;
          case 123:
            curly++;
            break;
          case 125:
            curly--;
            break;
        }
        if (c === 47) {
          let j = i - 1;
          let p;
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== " ")
              break;
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }
    if (expression === void 0) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }
    function pushFilter() {
      filters.push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }
    if (filters.length) {
      process.env.NODE_ENV !== "production" && warnDeprecation("COMPILER_FILTER", context, node.loc);
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i], context);
      }
      node.content = expression;
    }
  }
  function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i = filter.indexOf("(");
    if (i < 0) {
      context.filters.add(filter);
      return `${toValidAssetId(filter, "filter")}(${exp})`;
    } else {
      const name = filter.slice(0, i);
      const args = filter.slice(i + 1);
      context.filters.add(name);
      return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
    }
  }
  var seen$1 = new WeakSet();
  var transformMemo = (node, context) => {
    if (node.type === 1) {
      const dir = findDir(node, "memo");
      if (!dir || seen$1.has(node)) {
        return;
      }
      seen$1.add(node);
      return () => {
        const codegenNode = node.codegenNode || context.currentNode.codegenNode;
        if (codegenNode && codegenNode.type === 13) {
          if (node.tagType !== 1) {
            makeBlock(codegenNode, context);
          }
          node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
            dir.exp,
            createFunctionExpression(void 0, codegenNode),
            `_cache`,
            String(context.cached++)
          ]);
        }
      };
    }
  };
  function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        transformOnce,
        transformIf,
        transformMemo,
        transformFor,
        ...[transformFilter],
        ...process.env.NODE_ENV !== "production" ? [transformExpression] : [],
        transformSlotOutlet,
        transformElement,
        trackSlotScopes,
        transformText
      ],
      {
        on: transformOn,
        bind: transformBind,
        model: transformModel
      }
    ];
  }
  function baseCompile(template, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === "module";
    {
      if (options.prefixIdentifiers === true) {
        onError(createCompilerError(45));
      } else if (isModuleMode) {
        onError(createCompilerError(46));
      }
    }
    const prefixIdentifiers = false;
    if (options.cacheHandlers) {
      onError(createCompilerError(47));
    }
    if (options.scopeId && !isModuleMode) {
      onError(createCompilerError(48));
    }
    const ast = (0, import_shared2.isString)(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, (0, import_shared2.extend)({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: (0, import_shared2.extend)({}, directiveTransforms, options.directiveTransforms || {})
    }));
    return generate(ast, (0, import_shared2.extend)({}, options, {
      prefixIdentifiers
    }));
  }
  var noopDirectiveTransform = () => ({props: []});
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var require_compiler_dom_esm_bundler = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    DOMDirectiveTransforms: () => DOMDirectiveTransforms,
    DOMNodeTransforms: () => DOMNodeTransforms,
    TRANSITION: () => TRANSITION,
    TRANSITION_GROUP: () => TRANSITION_GROUP,
    V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
    V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
    V_MODEL_RADIO: () => V_MODEL_RADIO,
    V_MODEL_SELECT: () => V_MODEL_SELECT,
    V_MODEL_TEXT: () => V_MODEL_TEXT,
    V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
    V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
    V_SHOW: () => V_SHOW,
    compile: () => compile,
    createDOMCompilerError: () => createDOMCompilerError,
    parse: () => parse2,
    parserOptions: () => parserOptions,
    transformStyle: () => transformStyle
  });
  var import_compiler_core = require_compiler_core_esm_bundler();
  __exportStar(exports2, require_compiler_core_esm_bundler());
  var import_shared2 = require_shared_esm_bundler();
  var V_MODEL_RADIO = Symbol(process.env.NODE_ENV !== "production" ? `vModelRadio` : ``);
  var V_MODEL_CHECKBOX = Symbol(process.env.NODE_ENV !== "production" ? `vModelCheckbox` : ``);
  var V_MODEL_TEXT = Symbol(process.env.NODE_ENV !== "production" ? `vModelText` : ``);
  var V_MODEL_SELECT = Symbol(process.env.NODE_ENV !== "production" ? `vModelSelect` : ``);
  var V_MODEL_DYNAMIC = Symbol(process.env.NODE_ENV !== "production" ? `vModelDynamic` : ``);
  var V_ON_WITH_MODIFIERS = Symbol(process.env.NODE_ENV !== "production" ? `vOnModifiersGuard` : ``);
  var V_ON_WITH_KEYS = Symbol(process.env.NODE_ENV !== "production" ? `vOnKeysGuard` : ``);
  var V_SHOW = Symbol(process.env.NODE_ENV !== "production" ? `vShow` : ``);
  var TRANSITION = Symbol(process.env.NODE_ENV !== "production" ? `Transition` : ``);
  var TRANSITION_GROUP = Symbol(process.env.NODE_ENV !== "production" ? `TransitionGroup` : ``);
  (0, import_compiler_core.registerRuntimeHelpers)({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
  });
  var decoder;
  function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
      decoder = document.createElement("div");
    }
    if (asAttr) {
      decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
      return decoder.children[0].getAttribute("foo");
    } else {
      decoder.innerHTML = raw;
      return decoder.textContent;
    }
  }
  var isRawTextContainer = /* @__PURE__ */ (0, import_shared2.makeMap)("style,iframe,script,noscript", true);
  var parserOptions = {
    isVoidTag: import_shared2.isVoidTag,
    isNativeTag: (tag) => (0, import_shared2.isHTMLTag)(tag) || (0, import_shared2.isSVGTag)(tag),
    isPreTag: (tag) => tag === "pre",
    decodeEntities: decodeHtmlBrowser,
    isBuiltInComponent: (tag) => {
      if ((0, import_compiler_core.isBuiltInType)(tag, `Transition`)) {
        return TRANSITION;
      } else if ((0, import_compiler_core.isBuiltInType)(tag, `TransitionGroup`)) {
        return TRANSITION_GROUP;
      }
    },
    getNamespace(tag, parent) {
      let ns = parent ? parent.ns : 0;
      if (parent && ns === 2) {
        if (parent.tag === "annotation-xml") {
          if (tag === "svg") {
            return 1;
          }
          if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
            ns = 0;
          }
        } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
          ns = 0;
        }
      } else if (parent && ns === 1) {
        if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
          ns = 0;
        }
      }
      if (ns === 0) {
        if (tag === "svg") {
          return 1;
        }
        if (tag === "math") {
          return 2;
        }
      }
      return ns;
    },
    getTextMode({tag, ns}) {
      if (ns === 0) {
        if (tag === "textarea" || tag === "title") {
          return 1;
        }
        if (isRawTextContainer(tag)) {
          return 2;
        }
      }
      return 0;
    }
  };
  var transformStyle = (node) => {
    if (node.type === 1) {
      node.props.forEach((p, i) => {
        if (p.type === 6 && p.name === "style" && p.value) {
          node.props[i] = {
            type: 7,
            name: `bind`,
            arg: (0, import_compiler_core.createSimpleExpression)(`style`, true, p.loc),
            exp: parseInlineCSS(p.value.content, p.loc),
            modifiers: [],
            loc: p.loc
          };
        }
      });
    }
  };
  var parseInlineCSS = (cssText, loc) => {
    const normalized = (0, import_shared2.parseStringStyle)(cssText);
    return (0, import_compiler_core.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3);
  };
  function createDOMCompilerError(code, loc) {
    return (0, import_compiler_core.createCompilerError)(code, loc, process.env.NODE_ENV !== "production" || false ? DOMErrorMessages : void 0);
  }
  var DOMErrorMessages = {
    [49]: `v-html is missing expression.`,
    [50]: `v-html will override element children.`,
    [51]: `v-text is missing expression.`,
    [52]: `v-text will override element children.`,
    [53]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [54]: `v-model argument is not supported on plain elements.`,
    [55]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [56]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [57]: `v-show is missing expression.`,
    [58]: `<Transition> expects exactly one child element or component.`,
    [59]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
  };
  var transformVHtml = (dir, node, context) => {
    const {exp, loc} = dir;
    if (!exp) {
      context.onError(createDOMCompilerError(49, loc));
    }
    if (node.children.length) {
      context.onError(createDOMCompilerError(50, loc));
      node.children.length = 0;
    }
    return {
      props: [
        (0, import_compiler_core.createObjectProperty)((0, import_compiler_core.createSimpleExpression)(`innerHTML`, true, loc), exp || (0, import_compiler_core.createSimpleExpression)("", true))
      ]
    };
  };
  var transformVText = (dir, node, context) => {
    const {exp, loc} = dir;
    if (!exp) {
      context.onError(createDOMCompilerError(51, loc));
    }
    if (node.children.length) {
      context.onError(createDOMCompilerError(52, loc));
      node.children.length = 0;
    }
    return {
      props: [
        (0, import_compiler_core.createObjectProperty)((0, import_compiler_core.createSimpleExpression)(`textContent`, true), exp ? (0, import_compiler_core.createCallExpression)(context.helperString(import_compiler_core.TO_DISPLAY_STRING), [exp], loc) : (0, import_compiler_core.createSimpleExpression)("", true))
      ]
    };
  };
  var transformModel = (dir, node, context) => {
    const baseResult = (0, import_compiler_core.transformModel)(dir, node, context);
    if (!baseResult.props.length || node.tagType === 1) {
      return baseResult;
    }
    if (dir.arg) {
      context.onError(createDOMCompilerError(54, dir.arg.loc));
    }
    function checkDuplicatedValue() {
      const value = (0, import_compiler_core.findProp)(node, "value");
      if (value) {
        context.onError(createDOMCompilerError(56, value.loc));
      }
    }
    const {tag} = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
      let directiveToUse = V_MODEL_TEXT;
      let isInvalidType = false;
      if (tag === "input" || isCustomElement) {
        const type = (0, import_compiler_core.findProp)(node, `type`);
        if (type) {
          if (type.type === 7) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else if (type.value) {
            switch (type.value.content) {
              case "radio":
                directiveToUse = V_MODEL_RADIO;
                break;
              case "checkbox":
                directiveToUse = V_MODEL_CHECKBOX;
                break;
              case "file":
                isInvalidType = true;
                context.onError(createDOMCompilerError(55, dir.loc));
                break;
              default:
                process.env.NODE_ENV !== "production" && checkDuplicatedValue();
                break;
            }
          }
        } else if ((0, import_compiler_core.hasDynamicKeyVBind)(node)) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else {
          process.env.NODE_ENV !== "production" && checkDuplicatedValue();
        }
      } else if (tag === "select") {
        directiveToUse = V_MODEL_SELECT;
      } else {
        process.env.NODE_ENV !== "production" && checkDuplicatedValue();
      }
      if (!isInvalidType) {
        baseResult.needRuntime = context.helper(directiveToUse);
      }
    } else {
      context.onError(createDOMCompilerError(53, dir.loc));
    }
    baseResult.props = baseResult.props.filter((p) => !(p.key.type === 4 && p.key.content === "modelValue"));
    return baseResult;
  };
  var isEventOptionModifier = /* @__PURE__ */ (0, import_shared2.makeMap)(`passive,once,capture`);
  var isNonKeyModifier = /* @__PURE__ */ (0, import_shared2.makeMap)(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
  var maybeKeyModifier = /* @__PURE__ */ (0, import_shared2.makeMap)("left,right");
  var isKeyboardEvent = /* @__PURE__ */ (0, import_shared2.makeMap)(`onkeyup,onkeydown,onkeypress`, true);
  var resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
      const modifier = modifiers[i];
      if (modifier === "native" && (0, import_compiler_core.checkCompatEnabled)("COMPILER_V_ON_NATIVE", context, loc)) {
        eventOptionModifiers.push(modifier);
      } else if (isEventOptionModifier(modifier)) {
        eventOptionModifiers.push(modifier);
      } else {
        if (maybeKeyModifier(modifier)) {
          if ((0, import_compiler_core.isStaticExp)(key)) {
            if (isKeyboardEvent(key.content)) {
              keyModifiers.push(modifier);
            } else {
              nonKeyModifiers.push(modifier);
            }
          } else {
            keyModifiers.push(modifier);
            nonKeyModifiers.push(modifier);
          }
        } else {
          if (isNonKeyModifier(modifier)) {
            nonKeyModifiers.push(modifier);
          } else {
            keyModifiers.push(modifier);
          }
        }
      }
    }
    return {
      keyModifiers,
      nonKeyModifiers,
      eventOptionModifiers
    };
  };
  var transformClick = (key, event) => {
    const isStaticClick = (0, import_compiler_core.isStaticExp)(key) && key.content.toLowerCase() === "onclick";
    return isStaticClick ? (0, import_compiler_core.createSimpleExpression)(event, true) : key.type !== 4 ? (0, import_compiler_core.createCompoundExpression)([
      `(`,
      key,
      `) === "onClick" ? "${event}" : (`,
      key,
      `)`
    ]) : key;
  };
  var transformOn = (dir, node, context) => {
    return (0, import_compiler_core.transformOn)(dir, node, context, (baseResult) => {
      const {modifiers} = dir;
      if (!modifiers.length)
        return baseResult;
      let {key, value: handlerExp} = baseResult.props[0];
      const {keyModifiers, nonKeyModifiers, eventOptionModifiers} = resolveModifiers(key, modifiers, context, dir.loc);
      if (nonKeyModifiers.includes("right")) {
        key = transformClick(key, `onContextmenu`);
      }
      if (nonKeyModifiers.includes("middle")) {
        key = transformClick(key, `onMouseup`);
      }
      if (nonKeyModifiers.length) {
        handlerExp = (0, import_compiler_core.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [
          handlerExp,
          JSON.stringify(nonKeyModifiers)
        ]);
      }
      if (keyModifiers.length && (!(0, import_compiler_core.isStaticExp)(key) || isKeyboardEvent(key.content))) {
        handlerExp = (0, import_compiler_core.createCallExpression)(context.helper(V_ON_WITH_KEYS), [
          handlerExp,
          JSON.stringify(keyModifiers)
        ]);
      }
      if (eventOptionModifiers.length) {
        const modifierPostfix = eventOptionModifiers.map(import_shared2.capitalize).join("");
        key = (0, import_compiler_core.isStaticExp)(key) ? (0, import_compiler_core.createSimpleExpression)(`${key.content}${modifierPostfix}`, true) : (0, import_compiler_core.createCompoundExpression)([`(`, key, `) + "${modifierPostfix}"`]);
      }
      return {
        props: [(0, import_compiler_core.createObjectProperty)(key, handlerExp)]
      };
    });
  };
  var transformShow = (dir, node, context) => {
    const {exp, loc} = dir;
    if (!exp) {
      context.onError(createDOMCompilerError(57, loc));
    }
    return {
      props: [],
      needRuntime: context.helper(V_SHOW)
    };
  };
  var warnTransitionChildren = (node, context) => {
    if (node.type === 1 && node.tagType === 1) {
      const component = context.isBuiltInComponent(node.tag);
      if (component === TRANSITION) {
        return () => {
          if (node.children.length && hasMultipleChildren(node)) {
            context.onError(createDOMCompilerError(58, {
              start: node.children[0].loc.start,
              end: node.children[node.children.length - 1].loc.end,
              source: ""
            }));
          }
        };
      }
    }
  };
  function hasMultipleChildren(node) {
    const children = node.children = node.children.filter((c) => c.type !== 3);
    const child = children[0];
    return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
  }
  var ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
      context.onError(createDOMCompilerError(59, node.loc));
      context.removeNode();
    }
  };
  var DOMNodeTransforms = [
    transformStyle,
    ...process.env.NODE_ENV !== "production" ? [warnTransitionChildren] : []
  ];
  var DOMDirectiveTransforms = {
    cloak: import_compiler_core.noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
  };
  function compile(template, options = {}) {
    return (0, import_compiler_core.baseCompile)(template, (0, import_shared2.extend)({}, parserOptions, options, {
      nodeTransforms: [
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: (0, import_shared2.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
      transformHoist: null
    }));
  }
  function parse2(template, options = {}) {
    return (0, import_compiler_core.baseParse)(template, (0, import_shared2.extend)({}, parserOptions, options));
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS((exports2) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports2.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports2.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports2) => {
  var base64 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  exports2.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS((exports2) => {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports2.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports2.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports2.urlGenerate = urlGenerate;
  function normalize(aPath) {
    var path4 = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path4 = url.path;
    }
    var isAbsolute = exports2.isAbsolute(path4);
    var parts = path4.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path4 = parts.join("/");
    if (path4 === "") {
      path4 = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path4;
      return urlGenerate(url);
    }
    return path4;
  }
  exports2.normalize = normalize;
  function join3(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports2.join = join3;
  exports2.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports2.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s) {
    return s;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports2.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports2.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByOriginalPositions = compareByOriginalPositions;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports2.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join3(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  }
  exports2.computeSourceURL = computeSourceURL;
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS((exports2) => {
  var util = require_util();
  var has2 = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set2 = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set2.add(aArray[i], aAllowDuplicates);
    }
    return set2;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has2.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has2.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has2.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports2.ArraySet = ArraySet;
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS((exports2) => {
  var util = require_util();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = {generatedLine: -1, generatedColumn: 0};
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports2.MappingList = MappingList;
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports2) => {
  var base64VLQ = require_base64_vlq();
  var util = require_util();
  var ArraySet = require_array_set().ArraySet;
  var MappingList = require_mapping_list().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports2.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS((exports2) => {
  exports2.GREATEST_LOWER_BOUND = 1;
  exports2.LEAST_UPPER_BOUND = 2;
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS((exports2) => {
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  exports2.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS((exports2) => {
  var util = require_util();
  var binarySearch = require_binary_search();
  var ArraySet = require_array_set().ArraySet;
  var base64VLQ = require_base64_vlq();
  var quickSort = require_quick_sort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, "line");
    var needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === void 0) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports2.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util.normalize).map(function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS((exports2) => {
  var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  var util = require_util();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === void 0) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {code: generated.code, map};
  };
  exports2.SourceNode = SourceNode;
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS((exports2) => {
  exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
  exports2.SourceNode = require_source_node().SourceNode;
});

// node_modules/hash-sum/hash-sum.js
var require_hash_sum = __commonJS((exports2, module2) => {
  "use strict";
  function pad(hash, len) {
    while (hash.length < len) {
      hash = "0" + hash;
    }
    return hash;
  }
  function fold(hash, text) {
    var i;
    var chr;
    var len;
    if (text.length === 0) {
      return hash;
    }
    for (i = 0, len = text.length; i < len; i++) {
      chr = text.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return hash < 0 ? hash * -2 : hash;
  }
  function foldObject(hash, o, seen) {
    return Object.keys(o).sort().reduce(foldKey, hash);
    function foldKey(hash2, key) {
      return foldValue(hash2, o[key], key, seen);
    }
  }
  function foldValue(input, value, key, seen) {
    var hash = fold(fold(fold(input, key), toString(value)), typeof value);
    if (value === null) {
      return fold(hash, "null");
    }
    if (value === void 0) {
      return fold(hash, "undefined");
    }
    if (typeof value === "object" || typeof value === "function") {
      if (seen.indexOf(value) !== -1) {
        return fold(hash, "[Circular]" + key);
      }
      seen.push(value);
      var objHash = foldObject(hash, value, seen);
      if (!("valueOf" in value) || typeof value.valueOf !== "function") {
        return objHash;
      }
      try {
        return fold(objHash, String(value.valueOf()));
      } catch (err) {
        return fold(objHash, "[valueOf exception]" + (err.stack || err.message));
      }
    }
    return fold(hash, value.toString());
  }
  function toString(o) {
    return Object.prototype.toString.call(o);
  }
  function sum(o) {
    return pad(foldValue(0, o, "", []).toString(16), 8);
  }
  module2.exports = sum;
});

// node_modules/@vue/compiler-ssr/dist/compiler-ssr.cjs.js
var require_compiler_ssr_cjs = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var compilerDom = require_compiler_dom_esm_bundler();
  var shared4 = require_shared_esm_bundler();
  var SSR_INTERPOLATE = Symbol(`ssrInterpolate`);
  var SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);
  var SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);
  var SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);
  var SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);
  var SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);
  var SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);
  var SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);
  var SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);
  var SSR_RENDER_LIST = Symbol(`ssrRenderList`);
  var SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`);
  var SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);
  var SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);
  var SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`);
  var SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`);
  var SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);
  var SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);
  var ssrHelpers = {
    [SSR_INTERPOLATE]: `ssrInterpolate`,
    [SSR_RENDER_VNODE]: `ssrRenderVNode`,
    [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,
    [SSR_RENDER_SLOT]: `ssrRenderSlot`,
    [SSR_RENDER_CLASS]: `ssrRenderClass`,
    [SSR_RENDER_STYLE]: `ssrRenderStyle`,
    [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,
    [SSR_RENDER_ATTR]: `ssrRenderAttr`,
    [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,
    [SSR_RENDER_LIST]: `ssrRenderList`,
    [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,
    [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,
    [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,
    [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,
    [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,
    [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,
    [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`
  };
  compilerDom.registerRuntimeHelpers(ssrHelpers);
  var ssrTransformIf = compilerDom.createStructuralDirectiveTransform(/^(if|else|else-if)$/, compilerDom.processIf);
  function ssrProcessIf(node, context, disableNestedFragments = false) {
    const [rootBranch] = node.branches;
    const ifStatement = compilerDom.createIfStatement(rootBranch.condition, processIfBranch(rootBranch, context, disableNestedFragments));
    context.pushStatement(ifStatement);
    let currentIf = ifStatement;
    for (let i = 1; i < node.branches.length; i++) {
      const branch = node.branches[i];
      const branchBlockStatement = processIfBranch(branch, context, disableNestedFragments);
      if (branch.condition) {
        currentIf = currentIf.alternate = compilerDom.createIfStatement(branch.condition, branchBlockStatement);
      } else {
        currentIf.alternate = branchBlockStatement;
      }
    }
    if (!currentIf.alternate) {
      currentIf.alternate = compilerDom.createBlockStatement([
        compilerDom.createCallExpression(`_push`, ["`<!---->`"])
      ]);
    }
  }
  function processIfBranch(branch, context, disableNestedFragments = false) {
    const {children} = branch;
    const needFragmentWrapper = !disableNestedFragments && (children.length !== 1 || children[0].type !== 1) && !(children.length === 1 && children[0].type === 11);
    return processChildrenAsStatement(children, context, needFragmentWrapper);
  }
  var ssrTransformFor = compilerDom.createStructuralDirectiveTransform("for", compilerDom.processFor);
  function ssrProcessFor(node, context, disableNestedFragments = false) {
    const needFragmentWrapper = !disableNestedFragments && (node.children.length !== 1 || node.children[0].type !== 1);
    const renderLoop = compilerDom.createFunctionExpression(compilerDom.createForLoopParams(node.parseResult));
    renderLoop.body = processChildrenAsStatement(node.children, context, needFragmentWrapper);
    if (!disableNestedFragments) {
      context.pushStringPart(`<!--[-->`);
    }
    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_LIST), [
      node.source,
      renderLoop
    ]));
    if (!disableNestedFragments) {
      context.pushStringPart(`<!--]-->`);
    }
  }
  var ssrTransformSlotOutlet = (node, context) => {
    if (compilerDom.isSlotOutlet(node)) {
      const {slotName, slotProps} = compilerDom.processSlotOutlet(node, context);
      const args = [
        `_ctx.$slots`,
        slotName,
        slotProps || `{}`,
        `null`,
        `_push`,
        `_parent`
      ];
      if (context.scopeId && context.slotted !== false) {
        args.push(`"${context.scopeId}-s"`);
      }
      node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_SLOT), args);
    }
  };
  function ssrProcessSlotOutlet(node, context) {
    const renderCall = node.ssrCodegenNode;
    if (node.children.length) {
      const fallbackRenderFn = compilerDom.createFunctionExpression([]);
      fallbackRenderFn.body = processChildrenAsStatement(node.children, context);
      renderCall.arguments[3] = fallbackRenderFn;
    }
    if (context.withSlotScopeId) {
      const slotScopeId = renderCall.arguments[6];
      renderCall.arguments[6] = slotScopeId ? `${slotScopeId} + _scopeId` : `_scopeId`;
    }
    context.pushStatement(node.ssrCodegenNode);
  }
  function createSSRCompilerError(code, loc) {
    return compilerDom.createCompilerError(code, loc, SSRErrorMessages);
  }
  var SSRErrorMessages = {
    [60]: `Custom directive is missing corresponding SSR transform and will be ignored.`,
    [61]: `Unsafe attribute name for SSR.`,
    [62]: `Missing the 'to' prop on teleport element.`,
    [63]: `Invalid AST node during SSR transform.`
  };
  function ssrProcessTeleport(node, context) {
    const targetProp = compilerDom.findProp(node, "to");
    if (!targetProp) {
      context.onError(createSSRCompilerError(62, node.loc));
      return;
    }
    let target;
    if (targetProp.type === 6) {
      target = targetProp.value && compilerDom.createSimpleExpression(targetProp.value.content, true);
    } else {
      target = targetProp.exp;
    }
    if (!target) {
      context.onError(createSSRCompilerError(62, targetProp.loc));
      return;
    }
    const disabledProp = compilerDom.findProp(node, "disabled", false, true);
    const disabled = disabledProp ? disabledProp.type === 6 ? `true` : disabledProp.exp || `false` : `false`;
    const contentRenderFn = compilerDom.createFunctionExpression([`_push`], void 0, true, false, node.loc);
    contentRenderFn.body = processChildrenAsStatement(node.children, context);
    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_TELEPORT), [
      `_push`,
      contentRenderFn,
      target,
      disabled,
      `_parent`
    ]));
  }
  var wipMap = new WeakMap();
  function ssrTransformSuspense(node, context) {
    return () => {
      if (node.children.length) {
        const wipEntry = {
          slotsExp: null,
          wipSlots: []
        };
        wipMap.set(node, wipEntry);
        wipEntry.slotsExp = compilerDom.buildSlots(node, context, (_props, children, loc) => {
          const fn = compilerDom.createFunctionExpression([], void 0, true, false, loc);
          wipEntry.wipSlots.push({
            fn,
            children
          });
          return fn;
        }).slots;
      }
    };
  }
  function ssrProcessSuspense(node, context) {
    const wipEntry = wipMap.get(node);
    if (!wipEntry) {
      return;
    }
    const {slotsExp, wipSlots} = wipEntry;
    for (let i = 0; i < wipSlots.length; i++) {
      const {fn, children} = wipSlots[i];
      fn.body = processChildrenAsStatement(children, context);
    }
    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [
      `_push`,
      slotsExp
    ]));
  }
  function ssrProcessTransitionGroup(node, context) {
    const tag = compilerDom.findProp(node, "tag");
    if (tag) {
      if (tag.type === 7) {
        context.pushStringPart(`<`);
        context.pushStringPart(tag.exp);
        context.pushStringPart(`>`);
        processChildren(node.children, context, false, true);
        context.pushStringPart(`</`);
        context.pushStringPart(tag.exp);
        context.pushStringPart(`>`);
      } else {
        context.pushStringPart(`<${tag.value.content}>`);
        processChildren(node.children, context, false, true);
        context.pushStringPart(`</${tag.value.content}>`);
      }
    } else {
      processChildren(node.children, context, true, true);
    }
  }
  var wipMap$1 = new WeakMap();
  var componentTypeMap = new WeakMap();
  var ssrTransformComponent = (node, context) => {
    if (node.type !== 1 || node.tagType !== 1) {
      return;
    }
    const component = compilerDom.resolveComponentType(node, context, true);
    componentTypeMap.set(node, component);
    if (shared4.isSymbol(component)) {
      if (component === compilerDom.SUSPENSE) {
        return ssrTransformSuspense(node, context);
      }
      return;
    }
    const vnodeBranches = [];
    const clonedNode = clone(node);
    return function ssrPostTransformComponent() {
      if (clonedNode.children.length) {
        compilerDom.buildSlots(clonedNode, context, (props2, children) => {
          vnodeBranches.push(createVNodeSlotBranch(props2, children, context));
          return compilerDom.createFunctionExpression(void 0);
        });
      }
      const props = node.props.length > 0 ? compilerDom.buildProps(node, context).props || `null` : `null`;
      const wipEntries = [];
      wipMap$1.set(node, wipEntries);
      const buildSSRSlotFn = (props2, children, loc) => {
        const fn = compilerDom.createFunctionExpression([props2 || `_`, `_push`, `_parent`, `_scopeId`], void 0, true, true, loc);
        wipEntries.push({
          fn,
          children,
          vnodeBranch: vnodeBranches[wipEntries.length]
        });
        return fn;
      };
      const slots = node.children.length ? compilerDom.buildSlots(node, context, buildSSRSlotFn).slots : `null`;
      if (typeof component !== "string") {
        node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_VNODE), [
          `_push`,
          compilerDom.createCallExpression(context.helper(compilerDom.CREATE_VNODE), [
            component,
            props,
            slots
          ]),
          `_parent`
        ]);
      } else {
        node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_COMPONENT), [component, props, slots, `_parent`]);
      }
    };
  };
  function ssrProcessComponent(node, context) {
    const component = componentTypeMap.get(node);
    if (!node.ssrCodegenNode) {
      if (component === compilerDom.TELEPORT) {
        return ssrProcessTeleport(node, context);
      } else if (component === compilerDom.SUSPENSE) {
        return ssrProcessSuspense(node, context);
      } else if (component === compilerDom.TRANSITION_GROUP) {
        return ssrProcessTransitionGroup(node, context);
      } else {
        processChildren(node.children, context);
      }
    } else {
      const wipEntries = wipMap$1.get(node) || [];
      for (let i = 0; i < wipEntries.length; i++) {
        const {fn, children, vnodeBranch} = wipEntries[i];
        fn.body = compilerDom.createIfStatement(compilerDom.createSimpleExpression(`_push`, false), processChildrenAsStatement(children, context, false, true), vnodeBranch);
      }
      if (context.withSlotScopeId) {
        node.ssrCodegenNode.arguments.push(`_scopeId`);
      }
      if (typeof component === "string") {
        context.pushStatement(compilerDom.createCallExpression(`_push`, [node.ssrCodegenNode]));
      } else {
        context.pushStatement(node.ssrCodegenNode);
      }
    }
  }
  var rawOptionsMap = new WeakMap();
  var [baseNodeTransforms, baseDirectiveTransforms] = compilerDom.getBaseTransformPreset(true);
  var vnodeNodeTransforms = [...baseNodeTransforms, ...compilerDom.DOMNodeTransforms];
  var vnodeDirectiveTransforms = Object.assign(Object.assign({}, baseDirectiveTransforms), compilerDom.DOMDirectiveTransforms);
  function createVNodeSlotBranch(props, children, parentContext) {
    const rawOptions = rawOptionsMap.get(parentContext.root);
    const subOptions = Object.assign(Object.assign({}, rawOptions), {
      nodeTransforms: [
        ...vnodeNodeTransforms,
        ...rawOptions.nodeTransforms || []
      ],
      directiveTransforms: Object.assign(Object.assign({}, vnodeDirectiveTransforms), rawOptions.directiveTransforms || {})
    });
    const wrapperNode = {
      type: 1,
      ns: 0,
      tag: "template",
      tagType: 3,
      isSelfClosing: false,
      props: [
        {
          type: 7,
          name: "slot",
          exp: props,
          arg: void 0,
          modifiers: [],
          loc: compilerDom.locStub
        }
      ],
      children,
      loc: compilerDom.locStub,
      codegenNode: void 0
    };
    subTransform(wrapperNode, subOptions, parentContext);
    return compilerDom.createReturnStatement(children);
  }
  function subTransform(node, options, parentContext) {
    const childRoot = compilerDom.createRoot([node]);
    const childContext = compilerDom.createTransformContext(childRoot, options);
    childContext.ssr = false;
    childContext.scopes = Object.assign({}, parentContext.scopes);
    childContext.identifiers = Object.assign({}, parentContext.identifiers);
    childContext.imports = parentContext.imports;
    compilerDom.traverseNode(childRoot, childContext);
    ["helpers", "components", "directives"].forEach((key) => {
      childContext[key].forEach((value, helperKey) => {
        if (key === "helpers") {
          const parentCount = parentContext.helpers.get(helperKey);
          if (parentCount === void 0) {
            parentContext.helpers.set(helperKey, value);
          } else {
            parentContext.helpers.set(helperKey, value + parentCount);
          }
        } else {
          parentContext[key].add(value);
        }
      });
    });
  }
  function clone(v) {
    if (shared4.isArray(v)) {
      return v.map(clone);
    } else if (shared4.isObject(v)) {
      const res = {};
      for (const key in v) {
        res[key] = clone(v[key]);
      }
      return res;
    } else {
      return v;
    }
  }
  var rawChildrenMap = new WeakMap();
  var ssrTransformElement = (node, context) => {
    if (node.type !== 1 || node.tagType !== 0) {
      return;
    }
    return function ssrPostTransformElement() {
      const openTag = [`<${node.tag}`];
      const needTagForRuntime = node.tag === "textarea" || node.tag.indexOf("-") > 0;
      const hasDynamicVBind = compilerDom.hasDynamicKeyVBind(node);
      if (hasDynamicVBind) {
        const {props} = compilerDom.buildProps(node, context, node.props, true);
        if (props) {
          const propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [props]);
          if (node.tag === "textarea") {
            const existingText = node.children[0];
            if (!existingText || existingText.type !== 5) {
              const tempId = `_temp${context.temps++}`;
              propsExp.arguments = [
                compilerDom.createAssignmentExpression(compilerDom.createSimpleExpression(tempId, false), props)
              ];
              rawChildrenMap.set(node, compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [
                compilerDom.createConditionalExpression(compilerDom.createSimpleExpression(`"value" in ${tempId}`, false), compilerDom.createSimpleExpression(`${tempId}.value`, false), compilerDom.createSimpleExpression(existingText ? existingText.content : ``, true), false)
              ]));
            }
          } else if (node.tag === "input") {
            const vModel = findVModel(node);
            if (vModel) {
              const tempId = `_temp${context.temps++}`;
              const tempExp = compilerDom.createSimpleExpression(tempId, false);
              propsExp.arguments = [
                compilerDom.createSequenceExpression([
                  compilerDom.createAssignmentExpression(tempExp, props),
                  compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), [
                    tempExp,
                    compilerDom.createCallExpression(context.helper(SSR_GET_DYNAMIC_MODEL_PROPS), [
                      tempExp,
                      vModel.exp
                    ])
                  ])
                ])
              ];
            }
          }
          if (needTagForRuntime) {
            propsExp.arguments.push(`"${node.tag}"`);
          }
          openTag.push(propsExp);
        }
      }
      let dynamicClassBinding = void 0;
      let staticClassBinding = void 0;
      let dynamicStyleBinding = void 0;
      for (let i = 0; i < node.props.length; i++) {
        const prop = node.props[i];
        if (node.tag === "input" && isTrueFalseValue(prop)) {
          continue;
        }
        if (prop.type === 7) {
          if (prop.name === "html" && prop.exp) {
            rawChildrenMap.set(node, prop.exp);
          } else if (prop.name === "text" && prop.exp) {
            node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];
          } else if (prop.name === "slot") {
            context.onError(compilerDom.createCompilerError(39, prop.loc));
          } else if (isTextareaWithValue(node, prop) && prop.exp) {
            if (!hasDynamicVBind) {
              node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];
            }
          } else {
            const directiveTransform = context.directiveTransforms[prop.name];
            if (!directiveTransform) {
              context.onError(createSSRCompilerError(60, prop.loc));
            } else if (!hasDynamicVBind) {
              const {props, ssrTagParts} = directiveTransform(prop, node, context);
              if (ssrTagParts) {
                openTag.push(...ssrTagParts);
              }
              for (let j = 0; j < props.length; j++) {
                const {key, value} = props[j];
                if (compilerDom.isStaticExp(key)) {
                  let attrName = key.content;
                  if (attrName === "key" || attrName === "ref") {
                    continue;
                  }
                  if (attrName === "class") {
                    openTag.push(` class="`, dynamicClassBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_CLASS), [value]), `"`);
                  } else if (attrName === "style") {
                    if (dynamicStyleBinding) {
                      mergeCall(dynamicStyleBinding, value);
                    } else {
                      openTag.push(` style="`, dynamicStyleBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_STYLE), [value]), `"`);
                    }
                  } else {
                    attrName = node.tag.indexOf("-") > 0 ? attrName : shared4.propsToAttrMap[attrName] || attrName.toLowerCase();
                    if (shared4.isBooleanAttr(attrName)) {
                      openTag.push(compilerDom.createConditionalExpression(compilerDom.createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [value]), compilerDom.createSimpleExpression(" " + attrName, true), compilerDom.createSimpleExpression("", true), false));
                    } else if (shared4.isSSRSafeAttrName(attrName)) {
                      openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTR), [
                        key,
                        value
                      ]));
                    } else {
                      context.onError(createSSRCompilerError(61, key.loc));
                    }
                  }
                } else {
                  const args = [key, value];
                  if (needTagForRuntime) {
                    args.push(`"${node.tag}"`);
                  }
                  openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_ATTR), args));
                }
              }
            }
          }
        } else {
          if (node.tag === "textarea" && prop.name === "value" && prop.value) {
            rawChildrenMap.set(node, shared4.escapeHtml(prop.value.content));
          } else if (!hasDynamicVBind) {
            if (prop.name === "key" || prop.name === "ref") {
              continue;
            }
            if (prop.name === "class" && prop.value) {
              staticClassBinding = JSON.stringify(prop.value.content);
            }
            openTag.push(` ${prop.name}` + (prop.value ? `="${shared4.escapeHtml(prop.value.content)}"` : ``));
          }
        }
      }
      if (dynamicClassBinding && staticClassBinding) {
        mergeCall(dynamicClassBinding, staticClassBinding);
        removeStaticBinding(openTag, "class");
      }
      if (context.scopeId) {
        openTag.push(` ${context.scopeId}`);
      }
      node.ssrCodegenNode = compilerDom.createTemplateLiteral(openTag);
    };
  };
  function isTrueFalseValue(prop) {
    if (prop.type === 7) {
      return prop.name === "bind" && prop.arg && compilerDom.isStaticExp(prop.arg) && (prop.arg.content === "true-value" || prop.arg.content === "false-value");
    } else {
      return prop.name === "true-value" || prop.name === "false-value";
    }
  }
  function isTextareaWithValue(node, prop) {
    return !!(node.tag === "textarea" && prop.name === "bind" && compilerDom.isBindKey(prop.arg, "value"));
  }
  function mergeCall(call, arg) {
    const existing = call.arguments[0];
    if (existing.type === 17) {
      existing.elements.push(arg);
    } else {
      call.arguments[0] = compilerDom.createArrayExpression([existing, arg]);
    }
  }
  function removeStaticBinding(tag, binding) {
    const regExp = new RegExp(`^ ${binding}=".+"$`);
    const i = tag.findIndex((e) => typeof e === "string" && regExp.test(e));
    if (i > -1) {
      tag.splice(i, 1);
    }
  }
  function findVModel(node) {
    return node.props.find((p) => p.type === 7 && p.name === "model" && p.exp);
  }
  function ssrProcessElement(node, context) {
    const isVoidTag = context.options.isVoidTag || shared4.NO;
    const elementsToAdd = node.ssrCodegenNode.elements;
    for (let j = 0; j < elementsToAdd.length; j++) {
      context.pushStringPart(elementsToAdd[j]);
    }
    if (context.withSlotScopeId) {
      context.pushStringPart(compilerDom.createSimpleExpression(`_scopeId`, false));
    }
    context.pushStringPart(`>`);
    const rawChildren = rawChildrenMap.get(node);
    if (rawChildren) {
      context.pushStringPart(rawChildren);
    } else if (node.children.length) {
      processChildren(node.children, context);
    }
    if (!isVoidTag(node.tag)) {
      context.pushStringPart(`</${node.tag}>`);
    }
  }
  function ssrCodegenTransform(ast, options) {
    const context = createSSRTransformContext(ast, options);
    if (options.ssrCssVars) {
      const varsExp = compilerDom.processExpression(compilerDom.createSimpleExpression(options.ssrCssVars, false), compilerDom.createTransformContext(compilerDom.createRoot([]), options));
      context.body.push(compilerDom.createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`]));
    }
    const isFragment = ast.children.length > 1 && ast.children.some((c) => !compilerDom.isText(c));
    processChildren(ast.children, context, isFragment);
    ast.codegenNode = compilerDom.createBlockStatement(context.body);
    ast.ssrHelpers = Array.from(new Set([...ast.helpers.filter((h) => h in ssrHelpers), ...context.helpers]));
    ast.helpers = ast.helpers.filter((h) => !(h in ssrHelpers));
  }
  function createSSRTransformContext(root, options, helpers = new Set(), withSlotScopeId = false) {
    const body = [];
    let currentString = null;
    return {
      root,
      options,
      body,
      helpers,
      withSlotScopeId,
      onError: options.onError || ((e) => {
        throw e;
      }),
      helper(name) {
        helpers.add(name);
        return name;
      },
      pushStringPart(part) {
        if (!currentString) {
          const currentCall = compilerDom.createCallExpression(`_push`);
          body.push(currentCall);
          currentString = compilerDom.createTemplateLiteral([]);
          currentCall.arguments.push(currentString);
        }
        const bufferedElements = currentString.elements;
        const lastItem = bufferedElements[bufferedElements.length - 1];
        if (shared4.isString(part) && shared4.isString(lastItem)) {
          bufferedElements[bufferedElements.length - 1] += part;
        } else {
          bufferedElements.push(part);
        }
      },
      pushStatement(statement) {
        currentString = null;
        body.push(statement);
      }
    };
  }
  function createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {
    return createSSRTransformContext(parent.root, parent.options, parent.helpers, withSlotScopeId);
  }
  function processChildren(children, context, asFragment = false, disableNestedFragments = false) {
    if (asFragment) {
      context.pushStringPart(`<!--[-->`);
    }
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      switch (child.type) {
        case 1:
          switch (child.tagType) {
            case 0:
              ssrProcessElement(child, context);
              break;
            case 1:
              ssrProcessComponent(child, context);
              break;
            case 2:
              ssrProcessSlotOutlet(child, context);
              break;
            case 3:
              break;
            default:
              context.onError(createSSRCompilerError(63, child.loc));
              const exhaustiveCheck2 = child;
              return exhaustiveCheck2;
          }
          break;
        case 2:
          context.pushStringPart(shared4.escapeHtml(child.content));
          break;
        case 3:
          context.pushStringPart(`<!--${child.content}-->`);
          break;
        case 5:
          context.pushStringPart(compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [child.content]));
          break;
        case 9:
          ssrProcessIf(child, context, disableNestedFragments);
          break;
        case 11:
          ssrProcessFor(child, context, disableNestedFragments);
          break;
        case 10:
          break;
        case 12:
        case 8:
          break;
        default:
          context.onError(createSSRCompilerError(63, child.loc));
          const exhaustiveCheck = child;
          return exhaustiveCheck;
      }
    }
    if (asFragment) {
      context.pushStringPart(`<!--]-->`);
    }
  }
  function processChildrenAsStatement(children, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {
    const childContext = createChildContext(parentContext, withSlotScopeId);
    processChildren(children, childContext, asFragment);
    return compilerDom.createBlockStatement(childContext.body);
  }
  var ssrTransformModel = (dir, node, context) => {
    const model = dir.exp;
    function checkDuplicatedValue() {
      const value = compilerDom.findProp(node, "value");
      if (value) {
        context.onError(compilerDom.createDOMCompilerError(56, value.loc));
      }
    }
    if (node.tagType === 0) {
      const res = {props: []};
      const defaultProps = [
        compilerDom.createObjectProperty(`value`, model)
      ];
      if (node.tag === "input") {
        const type = compilerDom.findProp(node, "type");
        if (type) {
          const value = findValueBinding(node);
          if (type.type === 7) {
            res.ssrTagParts = [
              compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [
                type.exp,
                model,
                value
              ])
            ];
          } else if (type.value) {
            switch (type.value.content) {
              case "radio":
                res.props = [
                  compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                    model,
                    value
                  ]))
                ];
                break;
              case "checkbox":
                const trueValueBinding = compilerDom.findProp(node, "true-value");
                if (trueValueBinding) {
                  const trueValue = trueValueBinding.type === 6 ? JSON.stringify(trueValueBinding.value.content) : trueValueBinding.exp;
                  res.props = [
                    compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                      model,
                      trueValue
                    ]))
                  ];
                } else {
                  res.props = [
                    compilerDom.createObjectProperty(`checked`, compilerDom.createConditionalExpression(compilerDom.createCallExpression(`Array.isArray`, [model]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
                      model,
                      value
                    ]), model))
                  ];
                }
                break;
              case "file":
                context.onError(compilerDom.createDOMCompilerError(55, dir.loc));
                break;
              default:
                checkDuplicatedValue();
                res.props = defaultProps;
                break;
            }
          }
        } else if (compilerDom.hasDynamicKeyVBind(node))
          ;
        else {
          checkDuplicatedValue();
          res.props = defaultProps;
        }
      } else if (node.tag === "textarea") {
        checkDuplicatedValue();
        node.children = [compilerDom.createInterpolation(model, model.loc)];
      } else if (node.tag === "select")
        ;
      else {
        context.onError(compilerDom.createDOMCompilerError(53, dir.loc));
      }
      return res;
    } else {
      return compilerDom.transformModel(dir, node, context);
    }
  };
  function findValueBinding(node) {
    const valueBinding = compilerDom.findProp(node, "value");
    return valueBinding ? valueBinding.type === 7 ? valueBinding.exp : compilerDom.createSimpleExpression(valueBinding.value.content, true) : compilerDom.createSimpleExpression(`null`, false);
  }
  var ssrTransformShow = (dir, node, context) => {
    if (!dir.exp) {
      context.onError(compilerDom.createDOMCompilerError(57));
    }
    return {
      props: [
        compilerDom.createObjectProperty(`style`, compilerDom.createConditionalExpression(dir.exp, compilerDom.createSimpleExpression(`null`, false), compilerDom.createObjectExpression([
          compilerDom.createObjectProperty(`display`, compilerDom.createSimpleExpression(`none`, true))
        ]), false))
      ]
    };
  };
  var hasSingleChild = (node) => node.children.filter((n) => n.type !== 3).length === 1;
  var ssrInjectFallthroughAttrs = (node, context) => {
    if (node.type === 0) {
      context.identifiers._attrs = 1;
    }
    if (node.type === 1 && node.tagType === 1 && (compilerDom.isBuiltInType(node.tag, "Transition") || compilerDom.isBuiltInType(node.tag, "KeepAlive"))) {
      if (hasSingleChild(node)) {
        injectFallthroughAttrs(node.children[0]);
      }
      return;
    }
    const parent = context.parent;
    if (!parent || parent.type !== 0) {
      return;
    }
    if (node.type === 10 && hasSingleChild(node)) {
      injectFallthroughAttrs(node.children[0]);
    } else if (hasSingleChild(parent)) {
      injectFallthroughAttrs(node);
    }
  };
  function injectFallthroughAttrs(node) {
    if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, "for")) {
      node.props.push({
        type: 7,
        name: "bind",
        arg: void 0,
        exp: compilerDom.createSimpleExpression(`_attrs`, false),
        modifiers: [],
        loc: compilerDom.locStub
      });
    }
  }
  var ssrInjectCssVars = (node, context) => {
    if (!context.ssrCssVars) {
      return;
    }
    if (node.type === 0) {
      context.identifiers._cssVars = 1;
    }
    const parent = context.parent;
    if (!parent || parent.type !== 0) {
      return;
    }
    if (node.type === 10) {
      for (const child of node.children) {
        injectCssVars(child);
      }
    } else {
      injectCssVars(node);
    }
  };
  function injectCssVars(node) {
    if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !compilerDom.findDir(node, "for")) {
      if (compilerDom.isBuiltInType(node.tag, "Suspense")) {
        for (const child of node.children) {
          if (child.type === 1 && child.tagType === 3) {
            child.children.forEach(injectCssVars);
          } else {
            injectCssVars(child);
          }
        }
      } else {
        node.props.push({
          type: 7,
          name: "bind",
          arg: void 0,
          exp: compilerDom.createSimpleExpression(`_cssVars`, false),
          modifiers: [],
          loc: compilerDom.locStub
        });
      }
    }
  }
  function compile(template, options = {}) {
    options = Object.assign(Object.assign(Object.assign({}, options), compilerDom.parserOptions), {
      ssr: true,
      inSSR: true,
      scopeId: options.mode === "function" ? null : options.scopeId,
      prefixIdentifiers: true,
      cacheHandlers: false,
      hoistStatic: false
    });
    const ast = compilerDom.baseParse(template, options);
    rawOptionsMap.set(ast, options);
    compilerDom.transform(ast, Object.assign(Object.assign({}, options), {hoistStatic: false, nodeTransforms: [
      ssrTransformIf,
      ssrTransformFor,
      compilerDom.trackVForSlotScopes,
      compilerDom.transformExpression,
      ssrTransformSlotOutlet,
      ssrInjectFallthroughAttrs,
      ssrInjectCssVars,
      ssrTransformElement,
      ssrTransformComponent,
      compilerDom.trackSlotScopes,
      compilerDom.transformStyle,
      ...options.nodeTransforms || []
    ], directiveTransforms: Object.assign({
      bind: compilerDom.transformBind,
      model: ssrTransformModel,
      show: ssrTransformShow,
      on: compilerDom.noopDirectiveTransform,
      cloak: compilerDom.noopDirectiveTransform,
      once: compilerDom.noopDirectiveTransform
    }, options.directiveTransforms || {})}));
    ssrCodegenTransform(ast, options);
    return compilerDom.generate(ast, options);
  }
  exports2.compile = compile;
});

// node_modules/colorette/index.js
var require_colorette = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    bgBlack: () => bgBlack,
    bgBlackBright: () => bgBlackBright,
    bgBlue: () => bgBlue,
    bgBlueBright: () => bgBlueBright,
    bgCyan: () => bgCyan,
    bgCyanBright: () => bgCyanBright,
    bgGreen: () => bgGreen,
    bgGreenBright: () => bgGreenBright,
    bgMagenta: () => bgMagenta,
    bgMagentaBright: () => bgMagentaBright,
    bgRed: () => bgRed,
    bgRedBright: () => bgRedBright,
    bgWhite: () => bgWhite,
    bgWhiteBright: () => bgWhiteBright,
    bgYellow: () => bgYellow,
    bgYellowBright: () => bgYellowBright,
    black: () => black,
    blackBright: () => blackBright,
    blue: () => blue,
    blueBright: () => blueBright,
    bold: () => bold,
    cyan: () => cyan,
    cyanBright: () => cyanBright,
    dim: () => dim,
    gray: () => gray,
    green: () => green,
    greenBright: () => greenBright,
    hidden: () => hidden,
    inverse: () => inverse,
    italic: () => italic,
    magenta: () => magenta,
    magentaBright: () => magentaBright,
    options: () => options,
    red: () => red,
    redBright: () => redBright,
    reset: () => reset,
    strikethrough: () => strikethrough,
    underline: () => underline,
    white: () => white,
    whiteBright: () => whiteBright,
    yellow: () => yellow,
    yellowBright: () => yellowBright
  });
  var env = process.env;
  var isDisabled = "NO_COLOR" in env;
  var isForced = "FORCE_COLOR" in env;
  var isWindows = process.platform === "win32";
  var isCompatibleTerminal = process.stdout != null && process.stdout.isTTY && env.TERM && env.TERM !== "dumb";
  var isCI = "CI" in env && ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
  var enabled = !isDisabled && (isForced || isWindows || isCompatibleTerminal || isCI);
  var raw = (open, close, searchRegex, replaceValue) => (s) => enabled ? open + (~(s += "").indexOf(close, 4) ? s.replace(searchRegex, replaceValue) : s) + close : s;
  var init = (open, close) => {
    return raw(`[${open}m`, `[${close}m`, new RegExp(`\\x1b\\[${close}m`, "g"), `[${open}m`);
  };
  var options = Object.defineProperty({}, "enabled", {
    get: () => enabled,
    set: (value) => enabled = value
  });
  var reset = init(0, 0);
  var bold = raw("[1m", "[22m", /\x1b\[22m/g, "[22m[1m");
  var dim = raw("[2m", "[22m", /\x1b\[22m/g, "[22m[2m");
  var italic = init(3, 23);
  var underline = init(4, 24);
  var inverse = init(7, 27);
  var hidden = init(8, 28);
  var strikethrough = init(9, 29);
  var black = init(30, 39);
  var red = init(31, 39);
  var green = init(32, 39);
  var yellow = init(33, 39);
  var blue = init(34, 39);
  var magenta = init(35, 39);
  var cyan = init(36, 39);
  var white = init(37, 39);
  var gray = init(90, 39);
  var bgBlack = init(40, 49);
  var bgRed = init(41, 49);
  var bgGreen = init(42, 49);
  var bgYellow = init(43, 49);
  var bgBlue = init(44, 49);
  var bgMagenta = init(45, 49);
  var bgCyan = init(46, 49);
  var bgWhite = init(47, 49);
  var blackBright = init(90, 39);
  var redBright = init(91, 39);
  var greenBright = init(92, 39);
  var yellowBright = init(93, 39);
  var blueBright = init(94, 39);
  var magentaBright = init(95, 39);
  var cyanBright = init(96, 39);
  var whiteBright = init(97, 39);
  var bgBlackBright = init(100, 49);
  var bgRedBright = init(101, 49);
  var bgGreenBright = init(102, 49);
  var bgYellowBright = init(103, 49);
  var bgBlueBright = init(104, 49);
  var bgMagentaBright = init(105, 49);
  var bgCyanBright = init(106, 49);
  var bgWhiteBright = init(107, 49);
});

// node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS((exports2, module2) => {
  "use strict";
  var SINGLE_QUOTE = "'".charCodeAt(0);
  var DOUBLE_QUOTE = '"'.charCodeAt(0);
  var BACKSLASH = "\\".charCodeAt(0);
  var SLASH = "/".charCodeAt(0);
  var NEWLINE = "\n".charCodeAt(0);
  var SPACE = " ".charCodeAt(0);
  var FEED = "\f".charCodeAt(0);
  var TAB = "	".charCodeAt(0);
  var CR = "\r".charCodeAt(0);
  var OPEN_SQUARE = "[".charCodeAt(0);
  var CLOSE_SQUARE = "]".charCodeAt(0);
  var OPEN_PARENTHESES = "(".charCodeAt(0);
  var CLOSE_PARENTHESES = ")".charCodeAt(0);
  var OPEN_CURLY = "{".charCodeAt(0);
  var CLOSE_CURLY = "}".charCodeAt(0);
  var SEMICOLON = ";".charCodeAt(0);
  var ASTERISK = "*".charCodeAt(0);
  var COLON = ":".charCodeAt(0);
  var AT = "@".charCodeAt(0);
  var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
  var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
  var RE_BAD_BRACKET = /.[\n"'(/\\]/;
  var RE_HEX_ESCAPE = /[\da-f]/i;
  module2.exports = function tokenizer(input, options = {}) {
    let css = input.css.valueOf();
    let ignore = options.ignoreErrors;
    let code, next, quote, content, escape;
    let escaped, escapePos, prev, n, currentToken;
    let length = css.length;
    let pos = 0;
    let buffer = [];
    let returned = [];
    function position() {
      return pos;
    }
    function unclosed(what) {
      throw input.error("Unclosed " + what, pos);
    }
    function endOfFile() {
      return returned.length === 0 && pos >= length;
    }
    function nextToken(opts) {
      if (returned.length)
        return returned.pop();
      if (pos >= length)
        return;
      let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
      code = css.charCodeAt(pos);
      switch (code) {
        case NEWLINE:
        case SPACE:
        case TAB:
        case CR:
        case FEED: {
          next = pos;
          do {
            next += 1;
            code = css.charCodeAt(next);
          } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
          currentToken = ["space", css.slice(pos, next)];
          pos = next - 1;
          break;
        }
        case OPEN_SQUARE:
        case CLOSE_SQUARE:
        case OPEN_CURLY:
        case CLOSE_CURLY:
        case COLON:
        case SEMICOLON:
        case CLOSE_PARENTHESES: {
          let controlChar = String.fromCharCode(code);
          currentToken = [controlChar, controlChar, pos];
          break;
        }
        case OPEN_PARENTHESES: {
          prev = buffer.length ? buffer.pop()[1] : "";
          n = css.charCodeAt(pos + 1);
          if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(")", next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos;
                  break;
                } else {
                  unclosed("bracket");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
            pos = next;
          } else {
            next = css.indexOf(")", pos + 1);
            content = css.slice(pos, next + 1);
            if (next === -1 || RE_BAD_BRACKET.test(content)) {
              currentToken = ["(", "(", pos];
            } else {
              currentToken = ["brackets", content, pos, next];
              pos = next;
            }
          }
          break;
        }
        case SINGLE_QUOTE:
        case DOUBLE_QUOTE: {
          quote = code === SINGLE_QUOTE ? "'" : '"';
          next = pos;
          do {
            escaped = false;
            next = css.indexOf(quote, next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos + 1;
                break;
              } else {
                unclosed("string");
              }
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["string", css.slice(pos, next + 1), pos, next];
          pos = next;
          break;
        }
        case AT: {
          RE_AT_END.lastIndex = pos + 1;
          RE_AT_END.test(css);
          if (RE_AT_END.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_AT_END.lastIndex - 2;
          }
          currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
          pos = next;
          break;
        }
        case BACKSLASH: {
          next = pos;
          escape = true;
          while (css.charCodeAt(next + 1) === BACKSLASH) {
            next += 1;
            escape = !escape;
          }
          code = css.charCodeAt(next + 1);
          if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
            next += 1;
            if (RE_HEX_ESCAPE.test(css.charAt(next))) {
              while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                next += 1;
              }
              if (css.charCodeAt(next + 1) === SPACE) {
                next += 1;
              }
            }
          }
          currentToken = ["word", css.slice(pos, next + 1), pos, next];
          pos = next;
          break;
        }
        default: {
          if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
            next = css.indexOf("*/", pos + 2) + 1;
            if (next === 0) {
              if (ignore || ignoreUnclosed) {
                next = css.length;
              } else {
                unclosed("comment");
              }
            }
            currentToken = ["comment", css.slice(pos, next + 1), pos, next];
            pos = next;
          } else {
            RE_WORD_END.lastIndex = pos + 1;
            RE_WORD_END.test(css);
            if (RE_WORD_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_WORD_END.lastIndex - 2;
            }
            currentToken = ["word", css.slice(pos, next + 1), pos, next];
            buffer.push(currentToken);
            pos = next;
          }
          break;
        }
      }
      pos++;
      return currentToken;
    }
    function back(token) {
      returned.push(token);
    }
    return {
      back,
      nextToken,
      endOfFile,
      position
    };
  };
});

// node_modules/postcss/lib/terminal-highlight.js
var require_terminal_highlight = __commonJS((exports2, module2) => {
  "use strict";
  var {cyan, gray, green, yellow, magenta} = require_colorette();
  var tokenizer = require_tokenize();
  var Input;
  function registerInput(dependant) {
    Input = dependant;
  }
  var HIGHLIGHT_THEME = {
    brackets: cyan,
    "at-word": cyan,
    comment: gray,
    string: green,
    class: yellow,
    hash: magenta,
    call: cyan,
    "(": cyan,
    ")": cyan,
    "{": yellow,
    "}": yellow,
    "[": yellow,
    "]": yellow,
    ":": yellow,
    ";": yellow
  };
  function getTokenType([type, value], processor) {
    if (type === "word") {
      if (value[0] === ".") {
        return "class";
      }
      if (value[0] === "#") {
        return "hash";
      }
    }
    if (!processor.endOfFile()) {
      let next = processor.nextToken();
      processor.back(next);
      if (next[0] === "brackets" || next[0] === "(")
        return "call";
    }
    return type;
  }
  function terminalHighlight(css) {
    let processor = tokenizer(new Input(css), {ignoreErrors: true});
    let result = "";
    while (!processor.endOfFile()) {
      let token = processor.nextToken();
      let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
      if (color) {
        result += token[1].split(/\r?\n/).map((i) => color(i)).join("\n");
      } else {
        result += token[1];
      }
    }
    return result;
  }
  terminalHighlight.registerInput = registerInput;
  module2.exports = terminalHighlight;
});

// node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS((exports2, module2) => {
  "use strict";
  var {red, bold, gray, options: colorette} = require_colorette();
  var terminalHighlight = require_terminal_highlight();
  var CssSyntaxError = class extends Error {
    constructor(message, line, column, source, file, plugin) {
      super(message);
      this.name = "CssSyntaxError";
      this.reason = message;
      if (file) {
        this.file = file;
      }
      if (source) {
        this.source = source;
      }
      if (plugin) {
        this.plugin = plugin;
      }
      if (typeof line !== "undefined" && typeof column !== "undefined") {
        this.line = line;
        this.column = column;
      }
      this.setMessage();
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, CssSyntaxError);
      }
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "";
      this.message += this.file ? this.file : "<css input>";
      if (typeof this.line !== "undefined") {
        this.message += ":" + this.line + ":" + this.column;
      }
      this.message += ": " + this.reason;
    }
    showSourceCode(color) {
      if (!this.source)
        return "";
      let css = this.source;
      if (color == null)
        color = colorette.enabled;
      if (terminalHighlight) {
        if (color)
          css = terminalHighlight(css);
      }
      let lines = css.split(/\r?\n/);
      let start = Math.max(this.line - 3, 0);
      let end = Math.min(this.line + 2, lines.length);
      let maxWidth = String(end).length;
      let mark, aside;
      if (color) {
        mark = (text) => bold(red(text));
        aside = (text) => gray(text);
      } else {
        mark = aside = (str) => str;
      }
      return lines.slice(start, end).map((line, index) => {
        let number = start + 1 + index;
        let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
        if (number === this.line) {
          let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
        }
        return " " + aside(gutter) + line;
      }).join("\n");
    }
    toString() {
      let code = this.showSourceCode();
      if (code) {
        code = "\n\n" + code + "\n";
      }
      return this.name + ": " + this.message + code;
    }
  };
  module2.exports = CssSyntaxError;
  CssSyntaxError.default = CssSyntaxError;
});

// node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports.isClean = Symbol("isClean");
  module2.exports.my = Symbol("my");
});

// node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS((exports2, module2) => {
  "use strict";
  var DEFAULT_RAW = {
    colon: ": ",
    indent: "    ",
    beforeDecl: "\n",
    beforeRule: "\n",
    beforeOpen: " ",
    beforeClose: "\n",
    beforeComment: "\n",
    after: "\n",
    emptyBody: "",
    commentLeft: " ",
    commentRight: " ",
    semicolon: false
  };
  function capitalize2(str) {
    return str[0].toUpperCase() + str.slice(1);
  }
  var Stringifier = class {
    constructor(builder) {
      this.builder = builder;
    }
    stringify(node, semicolon) {
      if (!this[node.type]) {
        throw new Error("Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier.");
      }
      this[node.type](node, semicolon);
    }
    document(node) {
      this.body(node);
    }
    root(node) {
      this.body(node);
      if (node.raws.after)
        this.builder(node.raws.after);
    }
    comment(node) {
      let left = this.raw(node, "left", "commentLeft");
      let right = this.raw(node, "right", "commentRight");
      this.builder("/*" + left + node.text + right + "*/", node);
    }
    decl(node, semicolon) {
      let between = this.raw(node, "between", "colon");
      let string = node.prop + between + this.rawValue(node, "value");
      if (node.important) {
        string += node.raws.important || " !important";
      }
      if (semicolon)
        string += ";";
      this.builder(string, node);
    }
    rule(node) {
      this.block(node, this.rawValue(node, "selector"));
      if (node.raws.ownSemicolon) {
        this.builder(node.raws.ownSemicolon, node, "end");
      }
    }
    atrule(node, semicolon) {
      let name = "@" + node.name;
      let params = node.params ? this.rawValue(node, "params") : "";
      if (typeof node.raws.afterName !== "undefined") {
        name += node.raws.afterName;
      } else if (params) {
        name += " ";
      }
      if (node.nodes) {
        this.block(node, name + params);
      } else {
        let end = (node.raws.between || "") + (semicolon ? ";" : "");
        this.builder(name + params + end, node);
      }
    }
    body(node) {
      let last = node.nodes.length - 1;
      while (last > 0) {
        if (node.nodes[last].type !== "comment")
          break;
        last -= 1;
      }
      let semicolon = this.raw(node, "semicolon");
      for (let i = 0; i < node.nodes.length; i++) {
        let child = node.nodes[i];
        let before = this.raw(child, "before");
        if (before)
          this.builder(before);
        this.stringify(child, last !== i || semicolon);
      }
    }
    block(node, start) {
      let between = this.raw(node, "between", "beforeOpen");
      this.builder(start + between + "{", node, "start");
      let after;
      if (node.nodes && node.nodes.length) {
        this.body(node);
        after = this.raw(node, "after");
      } else {
        after = this.raw(node, "after", "emptyBody");
      }
      if (after)
        this.builder(after);
      this.builder("}", node, "end");
    }
    raw(node, own, detect) {
      let value;
      if (!detect)
        detect = own;
      if (own) {
        value = node.raws[own];
        if (typeof value !== "undefined")
          return value;
      }
      let parent = node.parent;
      if (detect === "before") {
        if (!parent || parent.type === "root" && parent.first === node) {
          return "";
        }
        if (parent && parent.type === "document") {
          return "";
        }
      }
      if (!parent)
        return DEFAULT_RAW[detect];
      let root = node.root();
      if (!root.rawCache)
        root.rawCache = {};
      if (typeof root.rawCache[detect] !== "undefined") {
        return root.rawCache[detect];
      }
      if (detect === "before" || detect === "after") {
        return this.beforeAfter(node, detect);
      } else {
        let method = "raw" + capitalize2(detect);
        if (this[method]) {
          value = this[method](root, node);
        } else {
          root.walk((i) => {
            value = i.raws[own];
            if (typeof value !== "undefined")
              return false;
          });
        }
      }
      if (typeof value === "undefined")
        value = DEFAULT_RAW[detect];
      root.rawCache[detect] = value;
      return value;
    }
    rawSemicolon(root) {
      let value;
      root.walk((i) => {
        if (i.nodes && i.nodes.length && i.last.type === "decl") {
          value = i.raws.semicolon;
          if (typeof value !== "undefined")
            return false;
        }
      });
      return value;
    }
    rawEmptyBody(root) {
      let value;
      root.walk((i) => {
        if (i.nodes && i.nodes.length === 0) {
          value = i.raws.after;
          if (typeof value !== "undefined")
            return false;
        }
      });
      return value;
    }
    rawIndent(root) {
      if (root.raws.indent)
        return root.raws.indent;
      let value;
      root.walk((i) => {
        let p = i.parent;
        if (p && p !== root && p.parent && p.parent === root) {
          if (typeof i.raws.before !== "undefined") {
            let parts = i.raws.before.split("\n");
            value = parts[parts.length - 1];
            value = value.replace(/\S/g, "");
            return false;
          }
        }
      });
      return value;
    }
    rawBeforeComment(root, node) {
      let value;
      root.walkComments((i) => {
        if (typeof i.raws.before !== "undefined") {
          value = i.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      });
      if (typeof value === "undefined") {
        value = this.raw(node, null, "beforeDecl");
      } else if (value) {
        value = value.replace(/\S/g, "");
      }
      return value;
    }
    rawBeforeDecl(root, node) {
      let value;
      root.walkDecls((i) => {
        if (typeof i.raws.before !== "undefined") {
          value = i.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      });
      if (typeof value === "undefined") {
        value = this.raw(node, null, "beforeRule");
      } else if (value) {
        value = value.replace(/\S/g, "");
      }
      return value;
    }
    rawBeforeRule(root) {
      let value;
      root.walk((i) => {
        if (i.nodes && (i.parent !== root || root.first !== i)) {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        }
      });
      if (value)
        value = value.replace(/\S/g, "");
      return value;
    }
    rawBeforeClose(root) {
      let value;
      root.walk((i) => {
        if (i.nodes && i.nodes.length > 0) {
          if (typeof i.raws.after !== "undefined") {
            value = i.raws.after;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        }
      });
      if (value)
        value = value.replace(/\S/g, "");
      return value;
    }
    rawBeforeOpen(root) {
      let value;
      root.walk((i) => {
        if (i.type !== "decl") {
          value = i.raws.between;
          if (typeof value !== "undefined")
            return false;
        }
      });
      return value;
    }
    rawColon(root) {
      let value;
      root.walkDecls((i) => {
        if (typeof i.raws.between !== "undefined") {
          value = i.raws.between.replace(/[^\s:]/g, "");
          return false;
        }
      });
      return value;
    }
    beforeAfter(node, detect) {
      let value;
      if (node.type === "decl") {
        value = this.raw(node, null, "beforeDecl");
      } else if (node.type === "comment") {
        value = this.raw(node, null, "beforeComment");
      } else if (detect === "before") {
        value = this.raw(node, null, "beforeRule");
      } else {
        value = this.raw(node, null, "beforeClose");
      }
      let buf = node.parent;
      let depth = 0;
      while (buf && buf.type !== "root") {
        depth += 1;
        buf = buf.parent;
      }
      if (value.includes("\n")) {
        let indent = this.raw(node, null, "indent");
        if (indent.length) {
          for (let step = 0; step < depth; step++)
            value += indent;
        }
      }
      return value;
    }
    rawValue(node, prop) {
      let value = node[prop];
      let raw = node.raws[prop];
      if (raw && raw.value === value) {
        return raw.raw;
      }
      return value;
    }
  };
  module2.exports = Stringifier;
});

// node_modules/postcss/lib/stringify.js
var require_stringify = __commonJS((exports2, module2) => {
  "use strict";
  var Stringifier = require_stringifier();
  function stringify(node, builder) {
    let str = new Stringifier(builder);
    str.stringify(node);
  }
  module2.exports = stringify;
  stringify.default = stringify;
});

// node_modules/postcss/lib/node.js
var require_node2 = __commonJS((exports2, module2) => {
  "use strict";
  var {isClean, my} = require_symbols();
  var CssSyntaxError = require_css_syntax_error();
  var Stringifier = require_stringifier();
  var stringify = require_stringify();
  function cloneNode(obj, parent) {
    let cloned = new obj.constructor();
    for (let i in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, i)) {
        continue;
      }
      if (i === "proxyCache")
        continue;
      let value = obj[i];
      let type = typeof value;
      if (i === "parent" && type === "object") {
        if (parent)
          cloned[i] = parent;
      } else if (i === "source") {
        cloned[i] = value;
      } else if (Array.isArray(value)) {
        cloned[i] = value.map((j) => cloneNode(j, cloned));
      } else {
        if (type === "object" && value !== null)
          value = cloneNode(value);
        cloned[i] = value;
      }
    }
    return cloned;
  }
  var Node = class {
    constructor(defaults = {}) {
      this.raws = {};
      this[isClean] = false;
      this[my] = true;
      for (let name in defaults) {
        if (name === "nodes") {
          this.nodes = [];
          for (let node of defaults[name]) {
            if (typeof node.clone === "function") {
              this.append(node.clone());
            } else {
              this.append(node);
            }
          }
        } else {
          this[name] = defaults[name];
        }
      }
    }
    error(message, opts = {}) {
      if (this.source) {
        let pos = this.positionBy(opts);
        return this.source.input.error(message, pos.line, pos.column, opts);
      }
      return new CssSyntaxError(message);
    }
    warn(result, text, opts) {
      let data = {node: this};
      for (let i in opts)
        data[i] = opts[i];
      return result.warn(text, data);
    }
    remove() {
      if (this.parent) {
        this.parent.removeChild(this);
      }
      this.parent = void 0;
      return this;
    }
    toString(stringifier = stringify) {
      if (stringifier.stringify)
        stringifier = stringifier.stringify;
      let result = "";
      stringifier(this, (i) => {
        result += i;
      });
      return result;
    }
    assign(overrides = {}) {
      for (let name in overrides) {
        this[name] = overrides[name];
      }
      return this;
    }
    clone(overrides = {}) {
      let cloned = cloneNode(this);
      for (let name in overrides) {
        cloned[name] = overrides[name];
      }
      return cloned;
    }
    cloneBefore(overrides = {}) {
      let cloned = this.clone(overrides);
      this.parent.insertBefore(this, cloned);
      return cloned;
    }
    cloneAfter(overrides = {}) {
      let cloned = this.clone(overrides);
      this.parent.insertAfter(this, cloned);
      return cloned;
    }
    replaceWith(...nodes) {
      if (this.parent) {
        let bookmark = this;
        let foundSelf = false;
        for (let node of nodes) {
          if (node === this) {
            foundSelf = true;
          } else if (foundSelf) {
            this.parent.insertAfter(bookmark, node);
            bookmark = node;
          } else {
            this.parent.insertBefore(bookmark, node);
          }
        }
        if (!foundSelf) {
          this.remove();
        }
      }
      return this;
    }
    next() {
      if (!this.parent)
        return void 0;
      let index = this.parent.index(this);
      return this.parent.nodes[index + 1];
    }
    prev() {
      if (!this.parent)
        return void 0;
      let index = this.parent.index(this);
      return this.parent.nodes[index - 1];
    }
    before(add2) {
      this.parent.insertBefore(this, add2);
      return this;
    }
    after(add2) {
      this.parent.insertAfter(this, add2);
      return this;
    }
    root() {
      let result = this;
      while (result.parent && result.parent.type !== "document") {
        result = result.parent;
      }
      return result;
    }
    raw(prop, defaultType) {
      let str = new Stringifier();
      return str.raw(this, prop, defaultType);
    }
    cleanRaws(keepBetween) {
      delete this.raws.before;
      delete this.raws.after;
      if (!keepBetween)
        delete this.raws.between;
    }
    toJSON(_, inputs) {
      let fixed = {};
      let emitInputs = inputs == null;
      inputs = inputs || new Map();
      let inputsNextIndex = 0;
      for (let name in this) {
        if (!Object.prototype.hasOwnProperty.call(this, name)) {
          continue;
        }
        if (name === "parent" || name === "proxyCache")
          continue;
        let value = this[name];
        if (Array.isArray(value)) {
          fixed[name] = value.map((i) => {
            if (typeof i === "object" && i.toJSON) {
              return i.toJSON(null, inputs);
            } else {
              return i;
            }
          });
        } else if (typeof value === "object" && value.toJSON) {
          fixed[name] = value.toJSON(null, inputs);
        } else if (name === "source") {
          let inputId = inputs.get(value.input);
          if (inputId == null) {
            inputId = inputsNextIndex;
            inputs.set(value.input, inputsNextIndex);
            inputsNextIndex++;
          }
          fixed[name] = {
            inputId,
            start: value.start,
            end: value.end
          };
        } else {
          fixed[name] = value;
        }
      }
      if (emitInputs) {
        fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
      }
      return fixed;
    }
    positionInside(index) {
      let string = this.toString();
      let column = this.source.start.column;
      let line = this.source.start.line;
      for (let i = 0; i < index; i++) {
        if (string[i] === "\n") {
          column = 1;
          line += 1;
        } else {
          column += 1;
        }
      }
      return {line, column};
    }
    positionBy(opts) {
      let pos = this.source.start;
      if (opts.index) {
        pos = this.positionInside(opts.index);
      } else if (opts.word) {
        let index = this.toString().indexOf(opts.word);
        if (index !== -1)
          pos = this.positionInside(index);
      }
      return pos;
    }
    getProxyProcessor() {
      return {
        set(node, prop, value) {
          if (node[prop] === value)
            return true;
          node[prop] = value;
          if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") {
            node.markDirty();
          }
          return true;
        },
        get(node, prop) {
          if (prop === "proxyOf") {
            return node;
          } else if (prop === "root") {
            return () => node.root().toProxy();
          } else {
            return node[prop];
          }
        }
      };
    }
    toProxy() {
      if (!this.proxyCache) {
        this.proxyCache = new Proxy(this, this.getProxyProcessor());
      }
      return this.proxyCache;
    }
    addToError(error) {
      error.postcssNode = this;
      if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
        let s = this.source;
        error.stack = error.stack.replace(/\n\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);
      }
      return error;
    }
    markDirty() {
      if (this[isClean]) {
        this[isClean] = false;
        let next = this;
        while (next = next.parent) {
          next[isClean] = false;
        }
      }
    }
    get proxyOf() {
      return this;
    }
  };
  module2.exports = Node;
  Node.default = Node;
});

// node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS((exports2, module2) => {
  "use strict";
  var Node = require_node2();
  var Declaration = class extends Node {
    constructor(defaults) {
      if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
        defaults = {...defaults, value: String(defaults.value)};
      }
      super(defaults);
      this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  module2.exports = Declaration;
  Declaration.default = Declaration;
});

// node_modules/source-map-js/lib/base64.js
var require_base642 = __commonJS((exports2) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports2.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports2.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq2 = __commonJS((exports2) => {
  var base64 = require_base642();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  exports2.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/source-map-js/lib/util.js
var require_util2 = __commonJS((exports2) => {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports2.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports2.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports2.urlGenerate = urlGenerate;
  var MAX_CACHED_INPUTS = 32;
  function lruMemoize(f) {
    var cache = [];
    return function(input) {
      for (var i = 0; i < cache.length; i++) {
        if (cache[i].input === input) {
          var temp = cache[0];
          cache[0] = cache[i];
          cache[i] = temp;
          return cache[0].result;
        }
      }
      var result = f(input);
      cache.unshift({
        input,
        result
      });
      if (cache.length > MAX_CACHED_INPUTS) {
        cache.pop();
      }
      return result;
    };
  }
  var normalize = lruMemoize(function normalize2(aPath) {
    var path4 = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path4 = url.path;
    }
    var isAbsolute = exports2.isAbsolute(path4);
    var parts = [];
    var start = 0;
    var i = 0;
    while (true) {
      start = i;
      i = path4.indexOf("/", start);
      if (i === -1) {
        parts.push(path4.slice(start));
        break;
      } else {
        parts.push(path4.slice(start, i));
        while (i < path4.length && path4[i] === "/") {
          i++;
        }
      }
    }
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path4 = parts.join("/");
    if (path4 === "") {
      path4 = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path4;
      return urlGenerate(url);
    }
    return path4;
  });
  exports2.normalize = normalize;
  function join3(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports2.join = join3;
  exports2.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports2.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s) {
    return s;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports2.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports2.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByOriginalPositions = compareByOriginalPositions;
  function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports2.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join3(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  }
  exports2.computeSourceURL = computeSourceURL;
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set2 = __commonJS((exports2) => {
  var util = require_util2();
  var has2 = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set2 = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set2.add(aArray[i], aAllowDuplicates);
    }
    return set2;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has2.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has2.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has2.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports2.ArraySet = ArraySet;
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list2 = __commonJS((exports2) => {
  var util = require_util2();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = {generatedLine: -1, generatedColumn: 0};
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports2.MappingList = MappingList;
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator2 = __commonJS((exports2) => {
  var base64VLQ = require_base64_vlq2();
  var util = require_util2();
  var ArraySet = require_array_set2().ArraySet;
  var MappingList = require_mapping_list2().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports2.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/source-map-js/lib/binary-search.js
var require_binary_search2 = __commonJS((exports2) => {
  exports2.GREATEST_LOWER_BOUND = 1;
  exports2.LEAST_UPPER_BOUND = 2;
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort2 = __commonJS((exports2) => {
  function SortTemplate(comparator) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator2, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator2(ary[j], pivot, false) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator2, p, q - 1);
        doQuickSort(ary, comparator2, q + 1, r);
      }
    }
    return doQuickSort;
  }
  function cloneSort(comparator) {
    let template = SortTemplate.toString();
    let templateFn = new Function(`return ${template}`)();
    return templateFn(comparator);
  }
  var sortCache = new WeakMap();
  exports2.quickSort = function(ary, comparator, start = 0) {
    let doQuickSort = sortCache.get(comparator);
    if (doQuickSort === void 0) {
      doQuickSort = cloneSort(comparator);
      sortCache.set(comparator, doQuickSort);
    }
    doQuickSort(ary, comparator, start, ary.length - 1);
  };
});

// node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer2 = __commonJS((exports2) => {
  var util = require_util2();
  var binarySearch = require_binary_search2();
  var ArraySet = require_array_set2().ArraySet;
  var base64VLQ = require_base64_vlq2();
  var quickSort = require_quick_sort2().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, "line");
    var needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === void 0) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports2.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util.normalize).map(function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  var compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
  function sortGenerated(array, start) {
    let l = array.length;
    let n = array.length - start;
    if (n <= 1) {
      return;
    } else if (n == 2) {
      let a = array[start];
      let b = array[start + 1];
      if (compareGenerated(a, b) > 0) {
        array[start] = b;
        array[start + 1] = a;
      }
    } else if (n < 20) {
      for (let i = start; i < l; i++) {
        for (let j = i; j > start; j--) {
          let a = array[j - 1];
          let b = array[j];
          if (compareGenerated(a, b) <= 0) {
            break;
          }
          array[j - 1] = b;
          array[j] = a;
        }
      }
    } else {
      quickSort(array, compareGenerated, start);
    }
  }
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    let subarrayStart = 0;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
        sortGenerated(generatedMappings, subarrayStart);
        subarrayStart = generatedMappings.length;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = [];
        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }
        if (segment.length === 2) {
          throw new Error("Found a source, but no line and column");
        }
        if (segment.length === 3) {
          throw new Error("Found a source and line, but no column");
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          let currentSource = mapping.source;
          while (originalMappings.length <= currentSource) {
            originalMappings.push(null);
          }
          if (originalMappings[currentSource] === null) {
            originalMappings[currentSource] = [];
          }
          originalMappings[currentSource].push(mapping);
        }
      }
    }
    sortGenerated(generatedMappings, subarrayStart);
    this.__generatedMappings = generatedMappings;
    for (var i = 0; i < originalMappings.length; i++) {
      if (originalMappings[i] != null) {
        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
      }
    }
    this.__originalMappings = [].concat(...originalMappings);
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/source-map-js/lib/source-node.js
var require_source_node2 = __commonJS((exports2) => {
  var SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
  var util = require_util2();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === void 0) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {code: generated.code, map};
  };
  exports2.SourceNode = SourceNode;
});

// node_modules/source-map-js/source-map.js
var require_source_map2 = __commonJS((exports2) => {
  exports2.SourceMapGenerator = require_source_map_generator2().SourceMapGenerator;
  exports2.SourceMapConsumer = require_source_map_consumer2().SourceMapConsumer;
  exports2.SourceNode = require_source_node2().SourceNode;
});

// node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS((exports2, module2) => {
  "use strict";
  var {SourceMapConsumer, SourceMapGenerator} = require_source_map2();
  var {dirname, resolve, relative, sep} = require("path");
  var {pathToFileURL} = require("url");
  var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
  var pathAvailable = Boolean(dirname && resolve && relative && sep);
  var MapGenerator = class {
    constructor(stringify, root, opts) {
      this.stringify = stringify;
      this.mapOpts = opts.map || {};
      this.root = root;
      this.opts = opts;
    }
    isMap() {
      if (typeof this.opts.map !== "undefined") {
        return !!this.opts.map;
      }
      return this.previous().length > 0;
    }
    previous() {
      if (!this.previousMaps) {
        this.previousMaps = [];
        this.root.walk((node) => {
          if (node.source && node.source.input.map) {
            let map = node.source.input.map;
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map);
            }
          }
        });
      }
      return this.previousMaps;
    }
    isInline() {
      if (typeof this.mapOpts.inline !== "undefined") {
        return this.mapOpts.inline;
      }
      let annotation = this.mapOpts.annotation;
      if (typeof annotation !== "undefined" && annotation !== true) {
        return false;
      }
      if (this.previous().length) {
        return this.previous().some((i) => i.inline);
      }
      return true;
    }
    isSourcesContent() {
      if (typeof this.mapOpts.sourcesContent !== "undefined") {
        return this.mapOpts.sourcesContent;
      }
      if (this.previous().length) {
        return this.previous().some((i) => i.withContent());
      }
      return true;
    }
    clearAnnotation() {
      if (this.mapOpts.annotation === false)
        return;
      let node;
      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
        node = this.root.nodes[i];
        if (node.type !== "comment")
          continue;
        if (node.text.indexOf("# sourceMappingURL=") === 0) {
          this.root.removeChild(i);
        }
      }
    }
    setSourcesContent() {
      let already = {};
      this.root.walk((node) => {
        if (node.source) {
          let from = node.source.input.from;
          if (from && !already[from]) {
            already[from] = true;
            this.map.setSourceContent(this.toUrl(this.path(from)), node.source.input.css);
          }
        }
      });
    }
    applyPrevMaps() {
      for (let prev of this.previous()) {
        let from = this.toUrl(this.path(prev.file));
        let root = prev.root || dirname(prev.file);
        let map;
        if (this.mapOpts.sourcesContent === false) {
          map = new SourceMapConsumer(prev.text);
          if (map.sourcesContent) {
            map.sourcesContent = map.sourcesContent.map(() => null);
          }
        } else {
          map = prev.consumer();
        }
        this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
      }
    }
    isAnnotation() {
      if (this.isInline()) {
        return true;
      }
      if (typeof this.mapOpts.annotation !== "undefined") {
        return this.mapOpts.annotation;
      }
      if (this.previous().length) {
        return this.previous().some((i) => i.annotation);
      }
      return true;
    }
    toBase64(str) {
      if (Buffer) {
        return Buffer.from(str).toString("base64");
      } else {
        return window.btoa(unescape(encodeURIComponent(str)));
      }
    }
    addAnnotation() {
      let content;
      if (this.isInline()) {
        content = "data:application/json;base64," + this.toBase64(this.map.toString());
      } else if (typeof this.mapOpts.annotation === "string") {
        content = this.mapOpts.annotation;
      } else if (typeof this.mapOpts.annotation === "function") {
        content = this.mapOpts.annotation(this.opts.to, this.root);
      } else {
        content = this.outputFile() + ".map";
      }
      let eol = "\n";
      if (this.css.includes("\r\n"))
        eol = "\r\n";
      this.css += eol + "/*# sourceMappingURL=" + content + " */";
    }
    outputFile() {
      if (this.opts.to) {
        return this.path(this.opts.to);
      }
      if (this.opts.from) {
        return this.path(this.opts.from);
      }
      return "to.css";
    }
    generateMap() {
      this.generateString();
      if (this.isSourcesContent())
        this.setSourcesContent();
      if (this.previous().length > 0)
        this.applyPrevMaps();
      if (this.isAnnotation())
        this.addAnnotation();
      if (this.isInline()) {
        return [this.css];
      }
      return [this.css, this.map];
    }
    path(file) {
      if (file.indexOf("<") === 0)
        return file;
      if (/^\w+:\/\//.test(file))
        return file;
      if (this.mapOpts.absolute)
        return file;
      let from = this.opts.to ? dirname(this.opts.to) : ".";
      if (typeof this.mapOpts.annotation === "string") {
        from = dirname(resolve(from, this.mapOpts.annotation));
      }
      file = relative(from, file);
      return file;
    }
    toUrl(path4) {
      if (sep === "\\") {
        path4 = path4.replace(/\\/g, "/");
      }
      return encodeURI(path4).replace(/[#?]/g, encodeURIComponent);
    }
    sourcePath(node) {
      if (this.mapOpts.from) {
        return this.toUrl(this.mapOpts.from);
      } else if (this.mapOpts.absolute) {
        if (pathToFileURL) {
          return pathToFileURL(node.source.input.from).toString();
        } else {
          throw new Error("`map.absolute` option is not available in this PostCSS build");
        }
      } else {
        return this.toUrl(this.path(node.source.input.from));
      }
    }
    generateString() {
      this.css = "";
      this.map = new SourceMapGenerator({file: this.outputFile()});
      let line = 1;
      let column = 1;
      let noSource = "<no source>";
      let mapping = {
        source: "",
        generated: {line: 0, column: 0},
        original: {line: 0, column: 0}
      };
      let lines, last;
      this.stringify(this.root, (str, node, type) => {
        this.css += str;
        if (node && type !== "end") {
          mapping.generated.line = line;
          mapping.generated.column = column - 1;
          if (node.source && node.source.start) {
            mapping.source = this.sourcePath(node);
            mapping.original.line = node.source.start.line;
            mapping.original.column = node.source.start.column - 1;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            this.map.addMapping(mapping);
          }
        }
        lines = str.match(/\n/g);
        if (lines) {
          line += lines.length;
          last = str.lastIndexOf("\n");
          column = str.length - last;
        } else {
          column += str.length;
        }
        if (node && type !== "start") {
          let p = node.parent || {raws: {}};
          if (node.type !== "decl" || node !== p.last || p.raws.semicolon) {
            if (node.source && node.source.end) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.end.line;
              mapping.original.column = node.source.end.column - 1;
              mapping.generated.line = line;
              mapping.generated.column = column - 2;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              mapping.generated.line = line;
              mapping.generated.column = column - 1;
              this.map.addMapping(mapping);
            }
          }
        }
      });
    }
    generate() {
      this.clearAnnotation();
      if (pathAvailable && sourceMapAvailable && this.isMap()) {
        return this.generateMap();
      }
      let result = "";
      this.stringify(this.root, (i) => {
        result += i;
      });
      return [result];
    }
  };
  module2.exports = MapGenerator;
});

// node_modules/postcss/lib/comment.js
var require_comment = __commonJS((exports2, module2) => {
  "use strict";
  var Node = require_node2();
  var Comment = class extends Node {
    constructor(defaults) {
      super(defaults);
      this.type = "comment";
    }
  };
  module2.exports = Comment;
  Comment.default = Comment;
});

// node_modules/postcss/lib/container.js
var require_container = __commonJS((exports2, module2) => {
  "use strict";
  var {isClean, my} = require_symbols();
  var Declaration = require_declaration();
  var Comment = require_comment();
  var Node = require_node2();
  var parse2;
  var Rule;
  var AtRule;
  function cleanSource(nodes) {
    return nodes.map((i) => {
      if (i.nodes)
        i.nodes = cleanSource(i.nodes);
      delete i.source;
      return i;
    });
  }
  function markDirtyUp(node) {
    node[isClean] = false;
    if (node.proxyOf.nodes) {
      for (let i of node.proxyOf.nodes) {
        markDirtyUp(i);
      }
    }
  }
  var Container = class extends Node {
    push(child) {
      child.parent = this;
      this.proxyOf.nodes.push(child);
      return this;
    }
    each(callback) {
      if (!this.proxyOf.nodes)
        return void 0;
      let iterator = this.getIterator();
      let index, result;
      while (this.indexes[iterator] < this.proxyOf.nodes.length) {
        index = this.indexes[iterator];
        result = callback(this.proxyOf.nodes[index], index);
        if (result === false)
          break;
        this.indexes[iterator] += 1;
      }
      delete this.indexes[iterator];
      return result;
    }
    walk(callback) {
      return this.each((child, i) => {
        let result;
        try {
          result = callback(child, i);
        } catch (e) {
          throw child.addToError(e);
        }
        if (result !== false && child.walk) {
          result = child.walk(callback);
        }
        return result;
      });
    }
    walkDecls(prop, callback) {
      if (!callback) {
        callback = prop;
        return this.walk((child, i) => {
          if (child.type === "decl") {
            return callback(child, i);
          }
        });
      }
      if (prop instanceof RegExp) {
        return this.walk((child, i) => {
          if (child.type === "decl" && prop.test(child.prop)) {
            return callback(child, i);
          }
        });
      }
      return this.walk((child, i) => {
        if (child.type === "decl" && child.prop === prop) {
          return callback(child, i);
        }
      });
    }
    walkRules(selector, callback) {
      if (!callback) {
        callback = selector;
        return this.walk((child, i) => {
          if (child.type === "rule") {
            return callback(child, i);
          }
        });
      }
      if (selector instanceof RegExp) {
        return this.walk((child, i) => {
          if (child.type === "rule" && selector.test(child.selector)) {
            return callback(child, i);
          }
        });
      }
      return this.walk((child, i) => {
        if (child.type === "rule" && child.selector === selector) {
          return callback(child, i);
        }
      });
    }
    walkAtRules(name, callback) {
      if (!callback) {
        callback = name;
        return this.walk((child, i) => {
          if (child.type === "atrule") {
            return callback(child, i);
          }
        });
      }
      if (name instanceof RegExp) {
        return this.walk((child, i) => {
          if (child.type === "atrule" && name.test(child.name)) {
            return callback(child, i);
          }
        });
      }
      return this.walk((child, i) => {
        if (child.type === "atrule" && child.name === name) {
          return callback(child, i);
        }
      });
    }
    walkComments(callback) {
      return this.walk((child, i) => {
        if (child.type === "comment") {
          return callback(child, i);
        }
      });
    }
    append(...children) {
      for (let child of children) {
        let nodes = this.normalize(child, this.last);
        for (let node of nodes)
          this.proxyOf.nodes.push(node);
      }
      this.markDirty();
      return this;
    }
    prepend(...children) {
      children = children.reverse();
      for (let child of children) {
        let nodes = this.normalize(child, this.first, "prepend").reverse();
        for (let node of nodes)
          this.proxyOf.nodes.unshift(node);
        for (let id in this.indexes) {
          this.indexes[id] = this.indexes[id] + nodes.length;
        }
      }
      this.markDirty();
      return this;
    }
    cleanRaws(keepBetween) {
      super.cleanRaws(keepBetween);
      if (this.nodes) {
        for (let node of this.nodes)
          node.cleanRaws(keepBetween);
      }
    }
    insertBefore(exist, add2) {
      exist = this.index(exist);
      let type = exist === 0 ? "prepend" : false;
      let nodes = this.normalize(add2, this.proxyOf.nodes[exist], type).reverse();
      for (let node of nodes)
        this.proxyOf.nodes.splice(exist, 0, node);
      let index;
      for (let id in this.indexes) {
        index = this.indexes[id];
        if (exist <= index) {
          this.indexes[id] = index + nodes.length;
        }
      }
      this.markDirty();
      return this;
    }
    insertAfter(exist, add2) {
      exist = this.index(exist);
      let nodes = this.normalize(add2, this.proxyOf.nodes[exist]).reverse();
      for (let node of nodes)
        this.proxyOf.nodes.splice(exist + 1, 0, node);
      let index;
      for (let id in this.indexes) {
        index = this.indexes[id];
        if (exist < index) {
          this.indexes[id] = index + nodes.length;
        }
      }
      this.markDirty();
      return this;
    }
    removeChild(child) {
      child = this.index(child);
      this.proxyOf.nodes[child].parent = void 0;
      this.proxyOf.nodes.splice(child, 1);
      let index;
      for (let id in this.indexes) {
        index = this.indexes[id];
        if (index >= child) {
          this.indexes[id] = index - 1;
        }
      }
      this.markDirty();
      return this;
    }
    removeAll() {
      for (let node of this.proxyOf.nodes)
        node.parent = void 0;
      this.proxyOf.nodes = [];
      this.markDirty();
      return this;
    }
    replaceValues(pattern, opts, callback) {
      if (!callback) {
        callback = opts;
        opts = {};
      }
      this.walkDecls((decl) => {
        if (opts.props && !opts.props.includes(decl.prop))
          return;
        if (opts.fast && !decl.value.includes(opts.fast))
          return;
        decl.value = decl.value.replace(pattern, callback);
      });
      this.markDirty();
      return this;
    }
    every(condition) {
      return this.nodes.every(condition);
    }
    some(condition) {
      return this.nodes.some(condition);
    }
    index(child) {
      if (typeof child === "number")
        return child;
      if (child.proxyOf)
        child = child.proxyOf;
      return this.proxyOf.nodes.indexOf(child);
    }
    get first() {
      if (!this.proxyOf.nodes)
        return void 0;
      return this.proxyOf.nodes[0];
    }
    get last() {
      if (!this.proxyOf.nodes)
        return void 0;
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    normalize(nodes, sample) {
      if (typeof nodes === "string") {
        nodes = cleanSource(parse2(nodes).nodes);
      } else if (Array.isArray(nodes)) {
        nodes = nodes.slice(0);
        for (let i of nodes) {
          if (i.parent)
            i.parent.removeChild(i, "ignore");
        }
      } else if (nodes.type === "root" && this.type !== "document") {
        nodes = nodes.nodes.slice(0);
        for (let i of nodes) {
          if (i.parent)
            i.parent.removeChild(i, "ignore");
        }
      } else if (nodes.type) {
        nodes = [nodes];
      } else if (nodes.prop) {
        if (typeof nodes.value === "undefined") {
          throw new Error("Value field is missed in node creation");
        } else if (typeof nodes.value !== "string") {
          nodes.value = String(nodes.value);
        }
        nodes = [new Declaration(nodes)];
      } else if (nodes.selector) {
        nodes = [new Rule(nodes)];
      } else if (nodes.name) {
        nodes = [new AtRule(nodes)];
      } else if (nodes.text) {
        nodes = [new Comment(nodes)];
      } else {
        throw new Error("Unknown node type in node creation");
      }
      let processed = nodes.map((i) => {
        if (!i[my])
          Container.rebuild(i);
        i = i.proxyOf;
        if (i.parent)
          i.parent.removeChild(i);
        if (i[isClean])
          markDirtyUp(i);
        if (typeof i.raws.before === "undefined") {
          if (sample && typeof sample.raws.before !== "undefined") {
            i.raws.before = sample.raws.before.replace(/\S/g, "");
          }
        }
        i.parent = this;
        return i;
      });
      return processed;
    }
    getProxyProcessor() {
      return {
        set(node, prop, value) {
          if (node[prop] === value)
            return true;
          node[prop] = value;
          if (prop === "name" || prop === "params" || prop === "selector") {
            node.markDirty();
          }
          return true;
        },
        get(node, prop) {
          if (prop === "proxyOf") {
            return node;
          } else if (!node[prop]) {
            return node[prop];
          } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
            return (...args) => {
              return node[prop](...args.map((i) => {
                if (typeof i === "function") {
                  return (child, index) => i(child.toProxy(), index);
                } else {
                  return i;
                }
              }));
            };
          } else if (prop === "every" || prop === "some") {
            return (cb) => {
              return node[prop]((child, ...other) => cb(child.toProxy(), ...other));
            };
          } else if (prop === "root") {
            return () => node.root().toProxy();
          } else if (prop === "nodes") {
            return node.nodes.map((i) => i.toProxy());
          } else if (prop === "first" || prop === "last") {
            return node[prop].toProxy();
          } else {
            return node[prop];
          }
        }
      };
    }
    getIterator() {
      if (!this.lastEach)
        this.lastEach = 0;
      if (!this.indexes)
        this.indexes = {};
      this.lastEach += 1;
      let iterator = this.lastEach;
      this.indexes[iterator] = 0;
      return iterator;
    }
  };
  Container.registerParse = (dependant) => {
    parse2 = dependant;
  };
  Container.registerRule = (dependant) => {
    Rule = dependant;
  };
  Container.registerAtRule = (dependant) => {
    AtRule = dependant;
  };
  module2.exports = Container;
  Container.default = Container;
  Container.rebuild = (node) => {
    if (node.type === "atrule") {
      Object.setPrototypeOf(node, AtRule.prototype);
    } else if (node.type === "rule") {
      Object.setPrototypeOf(node, Rule.prototype);
    } else if (node.type === "decl") {
      Object.setPrototypeOf(node, Declaration.prototype);
    } else if (node.type === "comment") {
      Object.setPrototypeOf(node, Comment.prototype);
    }
    node[my] = true;
    if (node.nodes) {
      node.nodes.forEach((child) => {
        Container.rebuild(child);
      });
    }
  };
});

// node_modules/postcss/lib/document.js
var require_document = __commonJS((exports2, module2) => {
  "use strict";
  var Container = require_container();
  var LazyResult;
  var Processor;
  var Document = class extends Container {
    constructor(defaults) {
      super({type: "document", ...defaults});
      if (!this.nodes) {
        this.nodes = [];
      }
    }
    toResult(opts = {}) {
      let lazy = new LazyResult(new Processor(), this, opts);
      return lazy.stringify();
    }
  };
  Document.registerLazyResult = (dependant) => {
    LazyResult = dependant;
  };
  Document.registerProcessor = (dependant) => {
    Processor = dependant;
  };
  module2.exports = Document;
  Document.default = Document;
});

// node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS((exports2, module2) => {
  "use strict";
  var printed = {};
  module2.exports = function warnOnce(message) {
    if (printed[message])
      return;
    printed[message] = true;
    if (typeof console !== "undefined" && console.warn) {
      console.warn(message);
    }
  };
});

// node_modules/postcss/lib/warning.js
var require_warning = __commonJS((exports2, module2) => {
  "use strict";
  var Warning = class {
    constructor(text, opts = {}) {
      this.type = "warning";
      this.text = text;
      if (opts.node && opts.node.source) {
        let pos = opts.node.positionBy(opts);
        this.line = pos.line;
        this.column = pos.column;
      }
      for (let opt in opts)
        this[opt] = opts[opt];
    }
    toString() {
      if (this.node) {
        return this.node.error(this.text, {
          plugin: this.plugin,
          index: this.index,
          word: this.word
        }).message;
      }
      if (this.plugin) {
        return this.plugin + ": " + this.text;
      }
      return this.text;
    }
  };
  module2.exports = Warning;
  Warning.default = Warning;
});

// node_modules/postcss/lib/result.js
var require_result = __commonJS((exports2, module2) => {
  "use strict";
  var Warning = require_warning();
  var Result = class {
    constructor(processor, root, opts) {
      this.processor = processor;
      this.messages = [];
      this.root = root;
      this.opts = opts;
      this.css = void 0;
      this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(text, opts = {}) {
      if (!opts.plugin) {
        if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
          opts.plugin = this.lastPlugin.postcssPlugin;
        }
      }
      let warning = new Warning(text, opts);
      this.messages.push(warning);
      return warning;
    }
    warnings() {
      return this.messages.filter((i) => i.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  module2.exports = Result;
  Result.default = Result;
});

// node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS((exports2, module2) => {
  "use strict";
  var Container = require_container();
  var AtRule = class extends Container {
    constructor(defaults) {
      super(defaults);
      this.type = "atrule";
    }
    append(...children) {
      if (!this.proxyOf.nodes)
        this.nodes = [];
      return super.append(...children);
    }
    prepend(...children) {
      if (!this.proxyOf.nodes)
        this.nodes = [];
      return super.prepend(...children);
    }
  };
  module2.exports = AtRule;
  AtRule.default = AtRule;
  Container.registerAtRule(AtRule);
});

// node_modules/postcss/lib/root.js
var require_root = __commonJS((exports2, module2) => {
  "use strict";
  var Container = require_container();
  var LazyResult;
  var Processor;
  var Root = class extends Container {
    constructor(defaults) {
      super(defaults);
      this.type = "root";
      if (!this.nodes)
        this.nodes = [];
    }
    removeChild(child, ignore) {
      let index = this.index(child);
      if (!ignore && index === 0 && this.nodes.length > 1) {
        this.nodes[1].raws.before = this.nodes[index].raws.before;
      }
      return super.removeChild(child);
    }
    normalize(child, sample, type) {
      let nodes = super.normalize(child);
      if (sample) {
        if (type === "prepend") {
          if (this.nodes.length > 1) {
            sample.raws.before = this.nodes[1].raws.before;
          } else {
            delete sample.raws.before;
          }
        } else if (this.first !== sample) {
          for (let node of nodes) {
            node.raws.before = sample.raws.before;
          }
        }
      }
      return nodes;
    }
    toResult(opts = {}) {
      let lazy = new LazyResult(new Processor(), this, opts);
      return lazy.stringify();
    }
  };
  Root.registerLazyResult = (dependant) => {
    LazyResult = dependant;
  };
  Root.registerProcessor = (dependant) => {
    Processor = dependant;
  };
  module2.exports = Root;
  Root.default = Root;
});

// node_modules/postcss/lib/list.js
var require_list = __commonJS((exports2, module2) => {
  "use strict";
  var list = {
    split(string, separators, last) {
      let array = [];
      let current = "";
      let split = false;
      let func = 0;
      let quote = false;
      let escape = false;
      for (let letter of string) {
        if (escape) {
          escape = false;
        } else if (letter === "\\") {
          escape = true;
        } else if (quote) {
          if (letter === quote) {
            quote = false;
          }
        } else if (letter === '"' || letter === "'") {
          quote = letter;
        } else if (letter === "(") {
          func += 1;
        } else if (letter === ")") {
          if (func > 0)
            func -= 1;
        } else if (func === 0) {
          if (separators.includes(letter))
            split = true;
        }
        if (split) {
          if (current !== "")
            array.push(current.trim());
          current = "";
          split = false;
        } else {
          current += letter;
        }
      }
      if (last || current !== "")
        array.push(current.trim());
      return array;
    },
    space(string) {
      let spaces = [" ", "\n", "	"];
      return list.split(string, spaces);
    },
    comma(string) {
      return list.split(string, [","], true);
    }
  };
  module2.exports = list;
  list.default = list;
});

// node_modules/postcss/lib/rule.js
var require_rule = __commonJS((exports2, module2) => {
  "use strict";
  var Container = require_container();
  var list = require_list();
  var Rule = class extends Container {
    constructor(defaults) {
      super(defaults);
      this.type = "rule";
      if (!this.nodes)
        this.nodes = [];
    }
    get selectors() {
      return list.comma(this.selector);
    }
    set selectors(values) {
      let match = this.selector ? this.selector.match(/,\s*/) : null;
      let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
      this.selector = values.join(sep);
    }
  };
  module2.exports = Rule;
  Rule.default = Rule;
  Container.registerRule(Rule);
});

// node_modules/postcss/lib/parser.js
var require_parser = __commonJS((exports2, module2) => {
  "use strict";
  var Declaration = require_declaration();
  var tokenizer = require_tokenize();
  var Comment = require_comment();
  var AtRule = require_at_rule();
  var Root = require_root();
  var Rule = require_rule();
  var Parser = class {
    constructor(input) {
      this.input = input;
      this.root = new Root();
      this.current = this.root;
      this.spaces = "";
      this.semicolon = false;
      this.customProperty = false;
      this.createTokenizer();
      this.root.source = {input, start: {offset: 0, line: 1, column: 1}};
    }
    createTokenizer() {
      this.tokenizer = tokenizer(this.input);
    }
    parse() {
      let token;
      while (!this.tokenizer.endOfFile()) {
        token = this.tokenizer.nextToken();
        switch (token[0]) {
          case "space":
            this.spaces += token[1];
            break;
          case ";":
            this.freeSemicolon(token);
            break;
          case "}":
            this.end(token);
            break;
          case "comment":
            this.comment(token);
            break;
          case "at-word":
            this.atrule(token);
            break;
          case "{":
            this.emptyRule(token);
            break;
          default:
            this.other(token);
            break;
        }
      }
      this.endFile();
    }
    comment(token) {
      let node = new Comment();
      this.init(node, token[2]);
      node.source.end = this.getPosition(token[3] || token[2]);
      let text = token[1].slice(2, -2);
      if (/^\s*$/.test(text)) {
        node.text = "";
        node.raws.left = text;
        node.raws.right = "";
      } else {
        let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
        node.text = match[2];
        node.raws.left = match[1];
        node.raws.right = match[3];
      }
    }
    emptyRule(token) {
      let node = new Rule();
      this.init(node, token[2]);
      node.selector = "";
      node.raws.between = "";
      this.current = node;
    }
    other(start) {
      let end = false;
      let type = null;
      let colon = false;
      let bracket = null;
      let brackets = [];
      let customProperty = start[1].startsWith("--");
      let tokens = [];
      let token = start;
      while (token) {
        type = token[0];
        tokens.push(token);
        if (type === "(" || type === "[") {
          if (!bracket)
            bracket = token;
          brackets.push(type === "(" ? ")" : "]");
        } else if (customProperty && colon && type === "{") {
          if (!bracket)
            bracket = token;
          brackets.push("}");
        } else if (brackets.length === 0) {
          if (type === ";") {
            if (colon) {
              this.decl(tokens, customProperty);
              return;
            } else {
              break;
            }
          } else if (type === "{") {
            this.rule(tokens);
            return;
          } else if (type === "}") {
            this.tokenizer.back(tokens.pop());
            end = true;
            break;
          } else if (type === ":") {
            colon = true;
          }
        } else if (type === brackets[brackets.length - 1]) {
          brackets.pop();
          if (brackets.length === 0)
            bracket = null;
        }
        token = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile())
        end = true;
      if (brackets.length > 0)
        this.unclosedBracket(bracket);
      if (end && colon) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0];
          if (token !== "space" && token !== "comment")
            break;
          this.tokenizer.back(tokens.pop());
        }
        this.decl(tokens, customProperty);
      } else {
        this.unknownWord(tokens);
      }
    }
    rule(tokens) {
      tokens.pop();
      let node = new Rule();
      this.init(node, tokens[0][2]);
      node.raws.between = this.spacesAndCommentsFromEnd(tokens);
      this.raw(node, "selector", tokens);
      this.current = node;
    }
    decl(tokens, customProperty) {
      let node = new Declaration();
      this.init(node, tokens[0][2]);
      let last = tokens[tokens.length - 1];
      if (last[0] === ";") {
        this.semicolon = true;
        tokens.pop();
      }
      node.source.end = this.getPosition(last[3] || last[2]);
      while (tokens[0][0] !== "word") {
        if (tokens.length === 1)
          this.unknownWord(tokens);
        node.raws.before += tokens.shift()[1];
      }
      node.source.start = this.getPosition(tokens[0][2]);
      node.prop = "";
      while (tokens.length) {
        let type = tokens[0][0];
        if (type === ":" || type === "space" || type === "comment") {
          break;
        }
        node.prop += tokens.shift()[1];
      }
      node.raws.between = "";
      let token;
      while (tokens.length) {
        token = tokens.shift();
        if (token[0] === ":") {
          node.raws.between += token[1];
          break;
        } else {
          if (token[0] === "word" && /\w/.test(token[1])) {
            this.unknownWord([token]);
          }
          node.raws.between += token[1];
        }
      }
      if (node.prop[0] === "_" || node.prop[0] === "*") {
        node.raws.before += node.prop[0];
        node.prop = node.prop.slice(1);
      }
      let firstSpaces = this.spacesAndCommentsFromStart(tokens);
      this.precheckMissedSemicolon(tokens);
      for (let i = tokens.length - 1; i >= 0; i--) {
        token = tokens[i];
        if (token[1].toLowerCase() === "!important") {
          node.important = true;
          let string = this.stringFrom(tokens, i);
          string = this.spacesFromEnd(tokens) + string;
          if (string !== " !important")
            node.raws.important = string;
          break;
        } else if (token[1].toLowerCase() === "important") {
          let cache = tokens.slice(0);
          let str = "";
          for (let j = i; j > 0; j--) {
            let type = cache[j][0];
            if (str.trim().indexOf("!") === 0 && type !== "space") {
              break;
            }
            str = cache.pop()[1] + str;
          }
          if (str.trim().indexOf("!") === 0) {
            node.important = true;
            node.raws.important = str;
            tokens = cache;
          }
        }
        if (token[0] !== "space" && token[0] !== "comment") {
          break;
        }
      }
      let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
      this.raw(node, "value", tokens);
      if (hasWord) {
        node.raws.between += firstSpaces;
      } else {
        node.value = firstSpaces + node.value;
      }
      if (node.value.includes(":") && !customProperty) {
        this.checkMissedSemicolon(tokens);
      }
    }
    atrule(token) {
      let node = new AtRule();
      node.name = token[1].slice(1);
      if (node.name === "") {
        this.unnamedAtrule(node, token);
      }
      this.init(node, token[2]);
      let type;
      let prev;
      let shift;
      let last = false;
      let open = false;
      let params = [];
      let brackets = [];
      while (!this.tokenizer.endOfFile()) {
        token = this.tokenizer.nextToken();
        type = token[0];
        if (type === "(" || type === "[") {
          brackets.push(type === "(" ? ")" : "]");
        } else if (type === "{" && brackets.length > 0) {
          brackets.push("}");
        } else if (type === brackets[brackets.length - 1]) {
          brackets.pop();
        }
        if (brackets.length === 0) {
          if (type === ";") {
            node.source.end = this.getPosition(token[2]);
            this.semicolon = true;
            break;
          } else if (type === "{") {
            open = true;
            break;
          } else if (type === "}") {
            if (params.length > 0) {
              shift = params.length - 1;
              prev = params[shift];
              while (prev && prev[0] === "space") {
                prev = params[--shift];
              }
              if (prev) {
                node.source.end = this.getPosition(prev[3] || prev[2]);
              }
            }
            this.end(token);
            break;
          } else {
            params.push(token);
          }
        } else {
          params.push(token);
        }
        if (this.tokenizer.endOfFile()) {
          last = true;
          break;
        }
      }
      node.raws.between = this.spacesAndCommentsFromEnd(params);
      if (params.length) {
        node.raws.afterName = this.spacesAndCommentsFromStart(params);
        this.raw(node, "params", params);
        if (last) {
          token = params[params.length - 1];
          node.source.end = this.getPosition(token[3] || token[2]);
          this.spaces = node.raws.between;
          node.raws.between = "";
        }
      } else {
        node.raws.afterName = "";
        node.params = "";
      }
      if (open) {
        node.nodes = [];
        this.current = node;
      }
    }
    end(token) {
      if (this.current.nodes && this.current.nodes.length) {
        this.current.raws.semicolon = this.semicolon;
      }
      this.semicolon = false;
      this.current.raws.after = (this.current.raws.after || "") + this.spaces;
      this.spaces = "";
      if (this.current.parent) {
        this.current.source.end = this.getPosition(token[2]);
        this.current = this.current.parent;
      } else {
        this.unexpectedClose(token);
      }
    }
    endFile() {
      if (this.current.parent)
        this.unclosedBlock();
      if (this.current.nodes && this.current.nodes.length) {
        this.current.raws.semicolon = this.semicolon;
      }
      this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    }
    freeSemicolon(token) {
      this.spaces += token[1];
      if (this.current.nodes) {
        let prev = this.current.nodes[this.current.nodes.length - 1];
        if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
          prev.raws.ownSemicolon = this.spaces;
          this.spaces = "";
        }
      }
    }
    getPosition(offset) {
      let pos = this.input.fromOffset(offset);
      return {
        offset,
        line: pos.line,
        column: pos.col
      };
    }
    init(node, offset) {
      this.current.push(node);
      node.source = {
        start: this.getPosition(offset),
        input: this.input
      };
      node.raws.before = this.spaces;
      this.spaces = "";
      if (node.type !== "comment")
        this.semicolon = false;
    }
    raw(node, prop, tokens) {
      let token, type;
      let length = tokens.length;
      let value = "";
      let clean = true;
      let next, prev;
      let pattern = /^([#.|])?(\w)+/i;
      for (let i = 0; i < length; i += 1) {
        token = tokens[i];
        type = token[0];
        if (type === "comment" && node.type === "rule") {
          prev = tokens[i - 1];
          next = tokens[i + 1];
          if (prev[0] !== "space" && next[0] !== "space" && pattern.test(prev[1]) && pattern.test(next[1])) {
            value += token[1];
          } else {
            clean = false;
          }
          continue;
        }
        if (type === "comment" || type === "space" && i === length - 1) {
          clean = false;
        } else {
          value += token[1];
        }
      }
      if (!clean) {
        let raw = tokens.reduce((all, i) => all + i[1], "");
        node.raws[prop] = {value, raw};
      }
      node[prop] = value;
    }
    spacesAndCommentsFromEnd(tokens) {
      let lastTokenType;
      let spaces = "";
      while (tokens.length) {
        lastTokenType = tokens[tokens.length - 1][0];
        if (lastTokenType !== "space" && lastTokenType !== "comment")
          break;
        spaces = tokens.pop()[1] + spaces;
      }
      return spaces;
    }
    spacesAndCommentsFromStart(tokens) {
      let next;
      let spaces = "";
      while (tokens.length) {
        next = tokens[0][0];
        if (next !== "space" && next !== "comment")
          break;
        spaces += tokens.shift()[1];
      }
      return spaces;
    }
    spacesFromEnd(tokens) {
      let lastTokenType;
      let spaces = "";
      while (tokens.length) {
        lastTokenType = tokens[tokens.length - 1][0];
        if (lastTokenType !== "space")
          break;
        spaces = tokens.pop()[1] + spaces;
      }
      return spaces;
    }
    stringFrom(tokens, from) {
      let result = "";
      for (let i = from; i < tokens.length; i++) {
        result += tokens[i][1];
      }
      tokens.splice(from, tokens.length - from);
      return result;
    }
    colon(tokens) {
      let brackets = 0;
      let token, type, prev;
      for (let [i, element] of tokens.entries()) {
        token = element;
        type = token[0];
        if (type === "(") {
          brackets += 1;
        }
        if (type === ")") {
          brackets -= 1;
        }
        if (brackets === 0 && type === ":") {
          if (!prev) {
            this.doubleColon(token);
          } else if (prev[0] === "word" && prev[1] === "progid") {
            continue;
          } else {
            return i;
          }
        }
        prev = token;
      }
      return false;
    }
    unclosedBracket(bracket) {
      throw this.input.error("Unclosed bracket", bracket[2]);
    }
    unknownWord(tokens) {
      throw this.input.error("Unknown word", tokens[0][2]);
    }
    unexpectedClose(token) {
      throw this.input.error("Unexpected }", token[2]);
    }
    unclosedBlock() {
      let pos = this.current.source.start;
      throw this.input.error("Unclosed block", pos.line, pos.column);
    }
    doubleColon(token) {
      throw this.input.error("Double colon", token[2]);
    }
    unnamedAtrule(node, token) {
      throw this.input.error("At-rule without name", token[2]);
    }
    precheckMissedSemicolon() {
    }
    checkMissedSemicolon(tokens) {
      let colon = this.colon(tokens);
      if (colon === false)
        return;
      let founded = 0;
      let token;
      for (let j = colon - 1; j >= 0; j--) {
        token = tokens[j];
        if (token[0] !== "space") {
          founded += 1;
          if (founded === 2)
            break;
        }
      }
      throw this.input.error("Missed semicolon", token[0] === "word" ? token[3] + 1 : token[2]);
    }
  };
  module2.exports = Parser;
});

// node_modules/nanoid/non-secure/index.js
var require_non_secure = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    customAlphabet: () => customAlphabet,
    nanoid: () => nanoid
  });
  var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
  var customAlphabet = (alphabet, size2) => {
    return () => {
      let id = "";
      let i = size2;
      while (i--) {
        id += alphabet[Math.random() * alphabet.length | 0];
      }
      return id;
    };
  };
  var nanoid = (size2 = 21) => {
    let id = "";
    let i = size2;
    while (i--) {
      id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
  };
});

// node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS((exports2, module2) => {
  "use strict";
  var {SourceMapConsumer, SourceMapGenerator} = require_source_map2();
  var {existsSync: existsSync3, readFileSync: readFileSync3} = require("fs");
  var {dirname, join: join3} = require("path");
  function fromBase64(str) {
    if (Buffer) {
      return Buffer.from(str, "base64").toString();
    } else {
      return window.atob(str);
    }
  }
  var PreviousMap = class {
    constructor(css, opts) {
      if (opts.map === false)
        return;
      this.loadAnnotation(css);
      this.inline = this.startWith(this.annotation, "data:");
      let prev = opts.map ? opts.map.prev : void 0;
      let text = this.loadMap(opts.from, prev);
      if (!this.mapFile && opts.from) {
        this.mapFile = opts.from;
      }
      if (this.mapFile)
        this.root = dirname(this.mapFile);
      if (text)
        this.text = text;
    }
    consumer() {
      if (!this.consumerCache) {
        this.consumerCache = new SourceMapConsumer(this.text);
      }
      return this.consumerCache;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
    startWith(string, start) {
      if (!string)
        return false;
      return string.substr(0, start.length) === start;
    }
    getAnnotationURL(sourceMapString) {
      return sourceMapString.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
    }
    loadAnnotation(css) {
      let annotations = css.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);
      if (annotations && annotations.length > 0) {
        let lastAnnotation = annotations[annotations.length - 1];
        if (lastAnnotation) {
          this.annotation = this.getAnnotationURL(lastAnnotation);
        }
      }
    }
    decodeInline(text) {
      let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
      let baseUri = /^data:application\/json;base64,/;
      let charsetUri = /^data:application\/json;charset=utf-?8,/;
      let uri = /^data:application\/json,/;
      if (charsetUri.test(text) || uri.test(text)) {
        return decodeURIComponent(text.substr(RegExp.lastMatch.length));
      }
      if (baseCharsetUri.test(text) || baseUri.test(text)) {
        return fromBase64(text.substr(RegExp.lastMatch.length));
      }
      let encoding = text.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + encoding);
    }
    loadFile(path4) {
      this.root = dirname(path4);
      if (existsSync3(path4)) {
        this.mapFile = path4;
        return readFileSync3(path4, "utf-8").toString().trim();
      }
    }
    loadMap(file, prev) {
      if (prev === false)
        return false;
      if (prev) {
        if (typeof prev === "string") {
          return prev;
        } else if (typeof prev === "function") {
          let prevPath = prev(file);
          if (prevPath) {
            let map = this.loadFile(prevPath);
            if (!map) {
              throw new Error("Unable to load previous source map: " + prevPath.toString());
            }
            return map;
          }
        } else if (prev instanceof SourceMapConsumer) {
          return SourceMapGenerator.fromSourceMap(prev).toString();
        } else if (prev instanceof SourceMapGenerator) {
          return prev.toString();
        } else if (this.isMap(prev)) {
          return JSON.stringify(prev);
        } else {
          throw new Error("Unsupported previous source map format: " + prev.toString());
        }
      } else if (this.inline) {
        return this.decodeInline(this.annotation);
      } else if (this.annotation) {
        let map = this.annotation;
        if (file)
          map = join3(dirname(file), map);
        return this.loadFile(map);
      }
    }
    isMap(map) {
      if (typeof map !== "object")
        return false;
      return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
    }
  };
  module2.exports = PreviousMap;
  PreviousMap.default = PreviousMap;
});

// node_modules/postcss/lib/input.js
var require_input = __commonJS((exports2, module2) => {
  "use strict";
  var {SourceMapConsumer, SourceMapGenerator} = require_source_map2();
  var {fileURLToPath, pathToFileURL} = require("url");
  var {resolve, isAbsolute} = require("path");
  var {nanoid} = require_non_secure();
  var terminalHighlight = require_terminal_highlight();
  var CssSyntaxError = require_css_syntax_error();
  var PreviousMap = require_previous_map();
  var fromOffsetCache = Symbol("fromOffsetCache");
  var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
  var pathAvailable = Boolean(resolve && isAbsolute);
  var Input = class {
    constructor(css, opts = {}) {
      if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
        throw new Error(`PostCSS received ${css} instead of CSS string`);
      }
      this.css = css.toString();
      if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
        this.hasBOM = true;
        this.css = this.css.slice(1);
      } else {
        this.hasBOM = false;
      }
      if (opts.from) {
        if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
          this.file = opts.from;
        } else {
          this.file = resolve(opts.from);
        }
      }
      if (pathAvailable && sourceMapAvailable) {
        let map = new PreviousMap(this.css, opts);
        if (map.text) {
          this.map = map;
          let file = map.consumer().file;
          if (!this.file && file)
            this.file = this.mapResolve(file);
        }
      }
      if (!this.file) {
        this.id = "<input css " + nanoid(6) + ">";
      }
      if (this.map)
        this.map.file = this.from;
    }
    fromOffset(offset) {
      let lastLine, lineToIndex;
      if (!this[fromOffsetCache]) {
        let lines = this.css.split("\n");
        lineToIndex = new Array(lines.length);
        let prevIndex = 0;
        for (let i = 0, l = lines.length; i < l; i++) {
          lineToIndex[i] = prevIndex;
          prevIndex += lines[i].length + 1;
        }
        this[fromOffsetCache] = lineToIndex;
      } else {
        lineToIndex = this[fromOffsetCache];
      }
      lastLine = lineToIndex[lineToIndex.length - 1];
      let min = 0;
      if (offset >= lastLine) {
        min = lineToIndex.length - 1;
      } else {
        let max = lineToIndex.length - 2;
        let mid;
        while (min < max) {
          mid = min + (max - min >> 1);
          if (offset < lineToIndex[mid]) {
            max = mid - 1;
          } else if (offset >= lineToIndex[mid + 1]) {
            min = mid + 1;
          } else {
            min = mid;
            break;
          }
        }
      }
      return {
        line: min + 1,
        col: offset - lineToIndex[min] + 1
      };
    }
    error(message, line, column, opts = {}) {
      let result;
      if (!column) {
        let pos = this.fromOffset(line);
        line = pos.line;
        column = pos.col;
      }
      let origin = this.origin(line, column);
      if (origin) {
        result = new CssSyntaxError(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
      } else {
        result = new CssSyntaxError(message, line, column, this.css, this.file, opts.plugin);
      }
      result.input = {line, column, source: this.css};
      if (this.file) {
        if (pathToFileURL) {
          result.input.url = pathToFileURL(this.file).toString();
        }
        result.input.file = this.file;
      }
      return result;
    }
    origin(line, column) {
      if (!this.map)
        return false;
      let consumer = this.map.consumer();
      let from = consumer.originalPositionFor({line, column});
      if (!from.source)
        return false;
      let fromUrl;
      if (isAbsolute(from.source)) {
        fromUrl = pathToFileURL(from.source);
      } else {
        fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));
      }
      let result = {
        url: fromUrl.toString(),
        line: from.line,
        column: from.column
      };
      if (fromUrl.protocol === "file:") {
        if (fileURLToPath) {
          result.file = fileURLToPath(fromUrl);
        } else {
          throw new Error(`file: protocol is not available in this PostCSS build`);
        }
      }
      let source = consumer.sourceContentFor(from.source);
      if (source)
        result.source = source;
      return result;
    }
    mapResolve(file) {
      if (/^\w+:\/\//.test(file)) {
        return file;
      }
      return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
    }
    get from() {
      return this.file || this.id;
    }
    toJSON() {
      let json = {};
      for (let name of ["hasBOM", "css", "file", "id"]) {
        if (this[name] != null) {
          json[name] = this[name];
        }
      }
      if (this.map) {
        json.map = {...this.map};
        if (json.map.consumerCache) {
          json.map.consumerCache = void 0;
        }
      }
      return json;
    }
  };
  module2.exports = Input;
  Input.default = Input;
  if (terminalHighlight && terminalHighlight.registerInput) {
    terminalHighlight.registerInput(Input);
  }
});

// node_modules/postcss/lib/parse.js
var require_parse = __commonJS((exports2, module2) => {
  "use strict";
  var Container = require_container();
  var Parser = require_parser();
  var Input = require_input();
  function parse2(css, opts) {
    let input = new Input(css, opts);
    let parser = new Parser(input);
    try {
      parser.parse();
    } catch (e) {
      if (process.env.NODE_ENV !== "production") {
        if (e.name === "CssSyntaxError" && opts && opts.from) {
          if (/\.scss$/i.test(opts.from)) {
            e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
          } else if (/\.sass/i.test(opts.from)) {
            e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
          } else if (/\.less$/i.test(opts.from)) {
            e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
          }
        }
      }
      throw e;
    }
    return parser.root;
  }
  module2.exports = parse2;
  parse2.default = parse2;
  Container.registerParse(parse2);
});

// node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS((exports2, module2) => {
  "use strict";
  var {isClean, my} = require_symbols();
  var MapGenerator = require_map_generator();
  var stringify = require_stringify();
  var Container = require_container();
  var Document = require_document();
  var warnOnce = require_warn_once();
  var Result = require_result();
  var parse2 = require_parse();
  var Root = require_root();
  var TYPE_TO_CLASS_NAME = {
    document: "Document",
    root: "Root",
    atrule: "AtRule",
    rule: "Rule",
    decl: "Declaration",
    comment: "Comment"
  };
  var PLUGIN_PROPS = {
    postcssPlugin: true,
    prepare: true,
    Once: true,
    Document: true,
    Root: true,
    Declaration: true,
    Rule: true,
    AtRule: true,
    Comment: true,
    DeclarationExit: true,
    RuleExit: true,
    AtRuleExit: true,
    CommentExit: true,
    RootExit: true,
    DocumentExit: true,
    OnceExit: true
  };
  var NOT_VISITORS = {
    postcssPlugin: true,
    prepare: true,
    Once: true
  };
  var CHILDREN = 0;
  function isPromise(obj) {
    return typeof obj === "object" && typeof obj.then === "function";
  }
  function getEvents(node) {
    let key = false;
    let type = TYPE_TO_CLASS_NAME[node.type];
    if (node.type === "decl") {
      key = node.prop.toLowerCase();
    } else if (node.type === "atrule") {
      key = node.name.toLowerCase();
    }
    if (key && node.append) {
      return [
        type,
        type + "-" + key,
        CHILDREN,
        type + "Exit",
        type + "Exit-" + key
      ];
    } else if (key) {
      return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
    } else if (node.append) {
      return [type, CHILDREN, type + "Exit"];
    } else {
      return [type, type + "Exit"];
    }
  }
  function toStack(node) {
    let events;
    if (node.type === "document") {
      events = ["Document", CHILDREN, "DocumentExit"];
    } else if (node.type === "root") {
      events = ["Root", CHILDREN, "RootExit"];
    } else {
      events = getEvents(node);
    }
    return {
      node,
      events,
      eventIndex: 0,
      visitors: [],
      visitorIndex: 0,
      iterator: 0
    };
  }
  function cleanMarks(node) {
    node[isClean] = false;
    if (node.nodes)
      node.nodes.forEach((i) => cleanMarks(i));
    return node;
  }
  var postcss = {};
  var LazyResult = class {
    constructor(processor, css, opts) {
      this.stringified = false;
      this.processed = false;
      let root;
      if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
        root = cleanMarks(css);
      } else if (css instanceof LazyResult || css instanceof Result) {
        root = cleanMarks(css.root);
        if (css.map) {
          if (typeof opts.map === "undefined")
            opts.map = {};
          if (!opts.map.inline)
            opts.map.inline = false;
          opts.map.prev = css.map;
        }
      } else {
        let parser = parse2;
        if (opts.syntax)
          parser = opts.syntax.parse;
        if (opts.parser)
          parser = opts.parser;
        if (parser.parse)
          parser = parser.parse;
        try {
          root = parser(css, opts);
        } catch (error) {
          this.processed = true;
          this.error = error;
        }
        if (root && !root[my]) {
          Container.rebuild(root);
        }
      }
      this.result = new Result(processor, root, opts);
      this.helpers = {...postcss, result: this.result, postcss};
      this.plugins = this.processor.plugins.map((plugin) => {
        if (typeof plugin === "object" && plugin.prepare) {
          return {...plugin, ...plugin.prepare(this.result)};
        } else {
          return plugin;
        }
      });
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    get processor() {
      return this.result.processor;
    }
    get opts() {
      return this.result.opts;
    }
    get css() {
      return this.stringify().css;
    }
    get content() {
      return this.stringify().content;
    }
    get map() {
      return this.stringify().map;
    }
    get root() {
      return this.sync().root;
    }
    get messages() {
      return this.sync().messages;
    }
    warnings() {
      return this.sync().warnings();
    }
    toString() {
      return this.css;
    }
    then(onFulfilled, onRejected) {
      if (process.env.NODE_ENV !== "production") {
        if (!("from" in this.opts)) {
          warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
        }
      }
      return this.async().then(onFulfilled, onRejected);
    }
    catch(onRejected) {
      return this.async().catch(onRejected);
    }
    finally(onFinally) {
      return this.async().then(onFinally, onFinally);
    }
    async() {
      if (this.error)
        return Promise.reject(this.error);
      if (this.processed)
        return Promise.resolve(this.result);
      if (!this.processing) {
        this.processing = this.runAsync();
      }
      return this.processing;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      this.processed = true;
      if (this.processing) {
        throw this.getAsyncError();
      }
      for (let plugin of this.plugins) {
        let promise = this.runOnRoot(plugin);
        if (isPromise(promise)) {
          throw this.getAsyncError();
        }
      }
      this.prepareVisitors();
      if (this.hasListener) {
        let root = this.result.root;
        while (!root[isClean]) {
          root[isClean] = true;
          this.walkSync(root);
        }
        if (this.listeners.OnceExit) {
          if (root.type === "document") {
            for (let subRoot of root.nodes) {
              this.visitSync(this.listeners.OnceExit, subRoot);
            }
          } else {
            this.visitSync(this.listeners.OnceExit, root);
          }
        }
      }
      return this.result;
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = true;
      this.sync();
      let opts = this.result.opts;
      let str = stringify;
      if (opts.syntax)
        str = opts.syntax.stringify;
      if (opts.stringifier)
        str = opts.stringifier;
      if (str.stringify)
        str = str.stringify;
      let map = new MapGenerator(str, this.result.root, this.result.opts);
      let data = map.generate();
      this.result.css = data[0];
      this.result.map = data[1];
      return this.result;
    }
    walkSync(node) {
      node[isClean] = true;
      let events = getEvents(node);
      for (let event of events) {
        if (event === CHILDREN) {
          if (node.nodes) {
            node.each((child) => {
              if (!child[isClean])
                this.walkSync(child);
            });
          }
        } else {
          let visitors = this.listeners[event];
          if (visitors) {
            if (this.visitSync(visitors, node.toProxy()))
              return;
          }
        }
      }
    }
    visitSync(visitors, node) {
      for (let [plugin, visitor] of visitors) {
        this.result.lastPlugin = plugin;
        let promise;
        try {
          promise = visitor(node, this.helpers);
        } catch (e) {
          throw this.handleError(e, node.proxyOf);
        }
        if (node.type !== "root" && node.type !== "document" && !node.parent) {
          return true;
        }
        if (isPromise(promise)) {
          throw this.getAsyncError();
        }
      }
    }
    runOnRoot(plugin) {
      this.result.lastPlugin = plugin;
      try {
        if (typeof plugin === "object" && plugin.Once) {
          if (this.result.root.type === "document") {
            let roots = this.result.root.nodes.map((root) => plugin.Once(root, this.helpers));
            if (isPromise(roots[0])) {
              return Promise.all(roots);
            }
            return roots;
          }
          return plugin.Once(this.result.root, this.helpers);
        } else if (typeof plugin === "function") {
          return plugin(this.result.root, this.result);
        }
      } catch (error) {
        throw this.handleError(error);
      }
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(error, node) {
      let plugin = this.result.lastPlugin;
      try {
        if (node)
          node.addToError(error);
        this.error = error;
        if (error.name === "CssSyntaxError" && !error.plugin) {
          error.plugin = plugin.postcssPlugin;
          error.setMessage();
        } else if (plugin.postcssVersion) {
          if (process.env.NODE_ENV !== "production") {
            let pluginName = plugin.postcssPlugin;
            let pluginVer = plugin.postcssVersion;
            let runtimeVer = this.result.processor.version;
            let a = pluginVer.split(".");
            let b = runtimeVer.split(".");
            if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
              console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
            }
          }
        }
      } catch (err) {
        if (console && console.error)
          console.error(err);
      }
      return error;
    }
    async runAsync() {
      this.plugin = 0;
      for (let i = 0; i < this.plugins.length; i++) {
        let plugin = this.plugins[i];
        let promise = this.runOnRoot(plugin);
        if (isPromise(promise)) {
          try {
            await promise;
          } catch (error) {
            throw this.handleError(error);
          }
        }
      }
      this.prepareVisitors();
      if (this.hasListener) {
        let root = this.result.root;
        while (!root[isClean]) {
          root[isClean] = true;
          let stack = [toStack(root)];
          while (stack.length > 0) {
            let promise = this.visitTick(stack);
            if (isPromise(promise)) {
              try {
                await promise;
              } catch (e) {
                let node = stack[stack.length - 1].node;
                throw this.handleError(e, node);
              }
            }
          }
        }
        if (this.listeners.OnceExit) {
          for (let [plugin, visitor] of this.listeners.OnceExit) {
            this.result.lastPlugin = plugin;
            try {
              if (root.type === "document") {
                let roots = root.nodes.map((subRoot) => visitor(subRoot, this.helpers));
                await Promise.all(roots);
              } else {
                await visitor(root, this.helpers);
              }
            } catch (e) {
              throw this.handleError(e);
            }
          }
        }
      }
      this.processed = true;
      return this.stringify();
    }
    prepareVisitors() {
      this.listeners = {};
      let add2 = (plugin, type, cb) => {
        if (!this.listeners[type])
          this.listeners[type] = [];
        this.listeners[type].push([plugin, cb]);
      };
      for (let plugin of this.plugins) {
        if (typeof plugin === "object") {
          for (let event in plugin) {
            if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
              throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            }
            if (!NOT_VISITORS[event]) {
              if (typeof plugin[event] === "object") {
                for (let filter in plugin[event]) {
                  if (filter === "*") {
                    add2(plugin, event, plugin[event][filter]);
                  } else {
                    add2(plugin, event + "-" + filter.toLowerCase(), plugin[event][filter]);
                  }
                }
              } else if (typeof plugin[event] === "function") {
                add2(plugin, event, plugin[event]);
              }
            }
          }
        }
      }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    visitTick(stack) {
      let visit = stack[stack.length - 1];
      let {node, visitors} = visit;
      if (node.type !== "root" && node.type !== "document" && !node.parent) {
        stack.pop();
        return;
      }
      if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
        let [plugin, visitor] = visitors[visit.visitorIndex];
        visit.visitorIndex += 1;
        if (visit.visitorIndex === visitors.length) {
          visit.visitors = [];
          visit.visitorIndex = 0;
        }
        this.result.lastPlugin = plugin;
        try {
          return visitor(node.toProxy(), this.helpers);
        } catch (e) {
          throw this.handleError(e, node);
        }
      }
      if (visit.iterator !== 0) {
        let iterator = visit.iterator;
        let child;
        while (child = node.nodes[node.indexes[iterator]]) {
          node.indexes[iterator] += 1;
          if (!child[isClean]) {
            child[isClean] = true;
            stack.push(toStack(child));
            return;
          }
        }
        visit.iterator = 0;
        delete node.indexes[iterator];
      }
      let events = visit.events;
      while (visit.eventIndex < events.length) {
        let event = events[visit.eventIndex];
        visit.eventIndex += 1;
        if (event === CHILDREN) {
          if (node.nodes && node.nodes.length) {
            node[isClean] = true;
            visit.iterator = node.getIterator();
          }
          return;
        } else if (this.listeners[event]) {
          visit.visitors = this.listeners[event];
          return;
        }
      }
      stack.pop();
    }
  };
  LazyResult.registerPostcss = (dependant) => {
    postcss = dependant;
  };
  module2.exports = LazyResult;
  LazyResult.default = LazyResult;
  Root.registerLazyResult(LazyResult);
  Document.registerLazyResult(LazyResult);
});

// node_modules/postcss/lib/processor.js
var require_processor = __commonJS((exports2, module2) => {
  "use strict";
  var LazyResult = require_lazy_result();
  var Document = require_document();
  var Root = require_root();
  var Processor = class {
    constructor(plugins = []) {
      this.version = "8.3.6";
      this.plugins = this.normalize(plugins);
    }
    use(plugin) {
      this.plugins = this.plugins.concat(this.normalize([plugin]));
      return this;
    }
    process(css, opts = {}) {
      if (this.plugins.length === 0 && typeof opts.parser === "undefined" && typeof opts.stringifier === "undefined" && typeof opts.syntax === "undefined" && !opts.hideNothingWarning) {
        if (process.env.NODE_ENV !== "production") {
          if (typeof console !== "undefined" && console.warn) {
            console.warn("You did not set any plugins, parser, or stringifier. Right now, PostCSS does nothing. Pick plugins for your case on https://www.postcss.parts/ and use them in postcss.config.js.");
          }
        }
      }
      return new LazyResult(this, css, opts);
    }
    normalize(plugins) {
      let normalized = [];
      for (let i of plugins) {
        if (i.postcss === true) {
          i = i();
        } else if (i.postcss) {
          i = i.postcss;
        }
        if (typeof i === "object" && Array.isArray(i.plugins)) {
          normalized = normalized.concat(i.plugins);
        } else if (typeof i === "object" && i.postcssPlugin) {
          normalized.push(i);
        } else if (typeof i === "function") {
          normalized.push(i);
        } else if (typeof i === "object" && (i.parse || i.stringify)) {
          if (process.env.NODE_ENV !== "production") {
            throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
          }
        } else {
          throw new Error(i + " is not a PostCSS plugin");
        }
      }
      return normalized;
    }
  };
  module2.exports = Processor;
  Processor.default = Processor;
  Root.registerProcessor(Processor);
  Document.registerProcessor(Processor);
});

// node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS((exports2, module2) => {
  "use strict";
  var Declaration = require_declaration();
  var PreviousMap = require_previous_map();
  var Comment = require_comment();
  var AtRule = require_at_rule();
  var Input = require_input();
  var Root = require_root();
  var Rule = require_rule();
  function fromJSON(json, inputs) {
    if (Array.isArray(json))
      return json.map((n) => fromJSON(n));
    let {inputs: ownInputs, ...defaults} = json;
    if (ownInputs) {
      inputs = [];
      for (let input of ownInputs) {
        let inputHydrated = {...input, __proto__: Input.prototype};
        if (inputHydrated.map) {
          inputHydrated.map = {
            ...inputHydrated.map,
            __proto__: PreviousMap.prototype
          };
        }
        inputs.push(inputHydrated);
      }
    }
    if (defaults.nodes) {
      defaults.nodes = json.nodes.map((n) => fromJSON(n, inputs));
    }
    if (defaults.source) {
      let {inputId, ...source} = defaults.source;
      defaults.source = source;
      if (inputId != null) {
        defaults.source.input = inputs[inputId];
      }
    }
    if (defaults.type === "root") {
      return new Root(defaults);
    } else if (defaults.type === "decl") {
      return new Declaration(defaults);
    } else if (defaults.type === "rule") {
      return new Rule(defaults);
    } else if (defaults.type === "comment") {
      return new Comment(defaults);
    } else if (defaults.type === "atrule") {
      return new AtRule(defaults);
    } else {
      throw new Error("Unknown node type: " + json.type);
    }
  }
  module2.exports = fromJSON;
  fromJSON.default = fromJSON;
});

// node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS((exports2, module2) => {
  "use strict";
  var CssSyntaxError = require_css_syntax_error();
  var Declaration = require_declaration();
  var LazyResult = require_lazy_result();
  var Container = require_container();
  var Processor = require_processor();
  var stringify = require_stringify();
  var fromJSON = require_fromJSON();
  var Document = require_document();
  var Warning = require_warning();
  var Comment = require_comment();
  var AtRule = require_at_rule();
  var Result = require_result();
  var Input = require_input();
  var parse2 = require_parse();
  var list = require_list();
  var Rule = require_rule();
  var Root = require_root();
  var Node = require_node2();
  function postcss(...plugins) {
    if (plugins.length === 1 && Array.isArray(plugins[0])) {
      plugins = plugins[0];
    }
    return new Processor(plugins);
  }
  postcss.plugin = function plugin(name, initializer) {
    if (console && console.warn) {
      console.warn(name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration");
      if (process.env.LANG && process.env.LANG.startsWith("cn")) {
        console.warn(name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226");
      }
    }
    function creator(...args) {
      let transformer = initializer(...args);
      transformer.postcssPlugin = name;
      transformer.postcssVersion = new Processor().version;
      return transformer;
    }
    let cache;
    Object.defineProperty(creator, "postcss", {
      get() {
        if (!cache)
          cache = creator();
        return cache;
      }
    });
    creator.process = function(css, processOpts, pluginOpts) {
      return postcss([creator(pluginOpts)]).process(css, processOpts);
    };
    return creator;
  };
  postcss.stringify = stringify;
  postcss.parse = parse2;
  postcss.fromJSON = fromJSON;
  postcss.list = list;
  postcss.comment = (defaults) => new Comment(defaults);
  postcss.atRule = (defaults) => new AtRule(defaults);
  postcss.decl = (defaults) => new Declaration(defaults);
  postcss.rule = (defaults) => new Rule(defaults);
  postcss.root = (defaults) => new Root(defaults);
  postcss.document = (defaults) => new Document(defaults);
  postcss.CssSyntaxError = CssSyntaxError;
  postcss.Declaration = Declaration;
  postcss.Container = Container;
  postcss.Document = Document;
  postcss.Comment = Comment;
  postcss.Warning = Warning;
  postcss.AtRule = AtRule;
  postcss.Result = Result;
  postcss.Input = Input;
  postcss.Rule = Rule;
  postcss.Root = Root;
  postcss.Node = Node;
  LazyResult.registerPostcss(postcss);
  module2.exports = postcss;
  postcss.default = postcss;
});

// node_modules/postcss-selector-parser/dist/util/unesc.js
var require_unesc = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = unesc;
  function gobbleHex(str) {
    var lower = str.toLowerCase();
    var hex = "";
    var spaceTerminated = false;
    for (var i = 0; i < 6 && lower[i] !== void 0; i++) {
      var code = lower.charCodeAt(i);
      var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
      spaceTerminated = code === 32;
      if (!valid) {
        break;
      }
      hex += lower[i];
    }
    if (hex.length === 0) {
      return void 0;
    }
    var codePoint = parseInt(hex, 16);
    var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
    if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
      return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
    }
    return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
  }
  var CONTAINS_ESCAPE = /\\/;
  function unesc(str) {
    var needToProcess = CONTAINS_ESCAPE.test(str);
    if (!needToProcess) {
      return str;
    }
    var ret = "";
    for (var i = 0; i < str.length; i++) {
      if (str[i] === "\\") {
        var gobbled = gobbleHex(str.slice(i + 1, i + 7));
        if (gobbled !== void 0) {
          ret += gobbled[0];
          i += gobbled[1];
          continue;
        }
        if (str[i + 1] === "\\") {
          ret += "\\";
          i++;
          continue;
        }
        if (str.length === i + 1) {
          ret += str[i];
        }
        continue;
      }
      ret += str[i];
    }
    return ret;
  }
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/util/getProp.js
var require_getProp = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = getProp;
  function getProp(obj) {
    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      props[_key - 1] = arguments[_key];
    }
    while (props.length > 0) {
      var prop = props.shift();
      if (!obj[prop]) {
        return void 0;
      }
      obj = obj[prop];
    }
    return obj;
  }
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/util/ensureObject.js
var require_ensureObject = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = ensureObject;
  function ensureObject(obj) {
    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      props[_key - 1] = arguments[_key];
    }
    while (props.length > 0) {
      var prop = props.shift();
      if (!obj[prop]) {
        obj[prop] = {};
      }
      obj = obj[prop];
    }
  }
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/util/stripComments.js
var require_stripComments = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = stripComments;
  function stripComments(str) {
    var s = "";
    var commentStart = str.indexOf("/*");
    var lastEnd = 0;
    while (commentStart >= 0) {
      s = s + str.slice(lastEnd, commentStart);
      var commentEnd = str.indexOf("*/", commentStart + 2);
      if (commentEnd < 0) {
        return s;
      }
      lastEnd = commentEnd + 2;
      commentStart = str.indexOf("/*", lastEnd);
    }
    s = s + str.slice(lastEnd);
    return s;
  }
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/util/index.js
var require_util3 = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.stripComments = exports2.ensureObject = exports2.getProp = exports2.unesc = void 0;
  var _unesc = _interopRequireDefault(require_unesc());
  exports2.unesc = _unesc["default"];
  var _getProp = _interopRequireDefault(require_getProp());
  exports2.getProp = _getProp["default"];
  var _ensureObject = _interopRequireDefault(require_ensureObject());
  exports2.ensureObject = _ensureObject["default"];
  var _stripComments = _interopRequireDefault(require_stripComments());
  exports2.stripComments = _stripComments["default"];
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
});

// node_modules/postcss-selector-parser/dist/selectors/node.js
var require_node3 = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _util = require_util3();
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var cloneNode = function cloneNode2(obj, parent) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var cloned = new obj.constructor();
    for (var i in obj) {
      if (!obj.hasOwnProperty(i)) {
        continue;
      }
      var value = obj[i];
      var type = typeof value;
      if (i === "parent" && type === "object") {
        if (parent) {
          cloned[i] = parent;
        }
      } else if (value instanceof Array) {
        cloned[i] = value.map(function(j) {
          return cloneNode2(j, cloned);
        });
      } else {
        cloned[i] = cloneNode2(value, cloned);
      }
    }
    return cloned;
  };
  var Node = /* @__PURE__ */ function() {
    function Node2(opts) {
      if (opts === void 0) {
        opts = {};
      }
      Object.assign(this, opts);
      this.spaces = this.spaces || {};
      this.spaces.before = this.spaces.before || "";
      this.spaces.after = this.spaces.after || "";
    }
    var _proto = Node2.prototype;
    _proto.remove = function remove() {
      if (this.parent) {
        this.parent.removeChild(this);
      }
      this.parent = void 0;
      return this;
    };
    _proto.replaceWith = function replaceWith() {
      if (this.parent) {
        for (var index in arguments) {
          this.parent.insertBefore(this, arguments[index]);
        }
        this.remove();
      }
      return this;
    };
    _proto.next = function next() {
      return this.parent.at(this.parent.index(this) + 1);
    };
    _proto.prev = function prev() {
      return this.parent.at(this.parent.index(this) - 1);
    };
    _proto.clone = function clone(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }
      var cloned = cloneNode(this);
      for (var name in overrides) {
        cloned[name] = overrides[name];
      }
      return cloned;
    };
    _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
      if (!this.raws) {
        this.raws = {};
      }
      var originalValue = this[name];
      var originalEscaped = this.raws[name];
      this[name] = originalValue + value;
      if (originalEscaped || valueEscaped !== value) {
        this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
      } else {
        delete this.raws[name];
      }
    };
    _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
      if (!this.raws) {
        this.raws = {};
      }
      this[name] = value;
      this.raws[name] = valueEscaped;
    };
    _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
      this[name] = value;
      if (this.raws) {
        delete this.raws[name];
      }
    };
    _proto.isAtPosition = function isAtPosition(line, column) {
      if (this.source && this.source.start && this.source.end) {
        if (this.source.start.line > line) {
          return false;
        }
        if (this.source.end.line < line) {
          return false;
        }
        if (this.source.start.line === line && this.source.start.column > column) {
          return false;
        }
        if (this.source.end.line === line && this.source.end.column < column) {
          return false;
        }
        return true;
      }
      return void 0;
    };
    _proto.stringifyProperty = function stringifyProperty(name) {
      return this.raws && this.raws[name] || this[name];
    };
    _proto.valueToString = function valueToString() {
      return String(this.stringifyProperty("value"));
    };
    _proto.toString = function toString() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    };
    _createClass(Node2, [{
      key: "rawSpaceBefore",
      get: function get2() {
        var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
        if (rawSpace === void 0) {
          rawSpace = this.spaces && this.spaces.before;
        }
        return rawSpace || "";
      },
      set: function set2(raw) {
        (0, _util.ensureObject)(this, "raws", "spaces");
        this.raws.spaces.before = raw;
      }
    }, {
      key: "rawSpaceAfter",
      get: function get2() {
        var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
        if (rawSpace === void 0) {
          rawSpace = this.spaces.after;
        }
        return rawSpace || "";
      },
      set: function set2(raw) {
        (0, _util.ensureObject)(this, "raws", "spaces");
        this.raws.spaces.after = raw;
      }
    }]);
    return Node2;
  }();
  exports2["default"] = Node;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/types.js
var require_types2 = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.UNIVERSAL = exports2.ATTRIBUTE = exports2.CLASS = exports2.COMBINATOR = exports2.COMMENT = exports2.ID = exports2.NESTING = exports2.PSEUDO = exports2.ROOT = exports2.SELECTOR = exports2.STRING = exports2.TAG = void 0;
  var TAG = "tag";
  exports2.TAG = TAG;
  var STRING = "string";
  exports2.STRING = STRING;
  var SELECTOR = "selector";
  exports2.SELECTOR = SELECTOR;
  var ROOT = "root";
  exports2.ROOT = ROOT;
  var PSEUDO = "pseudo";
  exports2.PSEUDO = PSEUDO;
  var NESTING = "nesting";
  exports2.NESTING = NESTING;
  var ID = "id";
  exports2.ID = ID;
  var COMMENT = "comment";
  exports2.COMMENT = COMMENT;
  var COMBINATOR = "combinator";
  exports2.COMBINATOR = COMBINATOR;
  var CLASS = "class";
  exports2.CLASS = CLASS;
  var ATTRIBUTE = "attribute";
  exports2.ATTRIBUTE = ATTRIBUTE;
  var UNIVERSAL = "universal";
  exports2.UNIVERSAL = UNIVERSAL;
});

// node_modules/postcss-selector-parser/dist/selectors/container.js
var require_container2 = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _node = _interopRequireDefault(require_node3());
  var types = _interopRequireWildcard(require_types2());
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function _getRequireWildcardCache2() {
      return cache;
    };
    return cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {default: obj};
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {done: true};
          return {done: false, value: o[i++]};
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Container = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Container2, _Node);
    function Container2(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      if (!_this.nodes) {
        _this.nodes = [];
      }
      return _this;
    }
    var _proto = Container2.prototype;
    _proto.append = function append(selector) {
      selector.parent = this;
      this.nodes.push(selector);
      return this;
    };
    _proto.prepend = function prepend(selector) {
      selector.parent = this;
      this.nodes.unshift(selector);
      return this;
    };
    _proto.at = function at(index) {
      return this.nodes[index];
    };
    _proto.index = function index(child) {
      if (typeof child === "number") {
        return child;
      }
      return this.nodes.indexOf(child);
    };
    _proto.removeChild = function removeChild(child) {
      child = this.index(child);
      this.at(child).parent = void 0;
      this.nodes.splice(child, 1);
      var index;
      for (var id in this.indexes) {
        index = this.indexes[id];
        if (index >= child) {
          this.indexes[id] = index - 1;
        }
      }
      return this;
    };
    _proto.removeAll = function removeAll() {
      for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
        var node = _step.value;
        node.parent = void 0;
      }
      this.nodes = [];
      return this;
    };
    _proto.empty = function empty() {
      return this.removeAll();
    };
    _proto.insertAfter = function insertAfter(oldNode, newNode) {
      newNode.parent = this;
      var oldIndex = this.index(oldNode);
      this.nodes.splice(oldIndex + 1, 0, newNode);
      newNode.parent = this;
      var index;
      for (var id in this.indexes) {
        index = this.indexes[id];
        if (oldIndex <= index) {
          this.indexes[id] = index + 1;
        }
      }
      return this;
    };
    _proto.insertBefore = function insertBefore(oldNode, newNode) {
      newNode.parent = this;
      var oldIndex = this.index(oldNode);
      this.nodes.splice(oldIndex, 0, newNode);
      newNode.parent = this;
      var index;
      for (var id in this.indexes) {
        index = this.indexes[id];
        if (index <= oldIndex) {
          this.indexes[id] = index + 1;
        }
      }
      return this;
    };
    _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
      var found = void 0;
      this.each(function(node) {
        if (node.atPosition) {
          var foundChild = node.atPosition(line, col);
          if (foundChild) {
            found = foundChild;
            return false;
          }
        } else if (node.isAtPosition(line, col)) {
          found = node;
          return false;
        }
      });
      return found;
    };
    _proto.atPosition = function atPosition(line, col) {
      if (this.isAtPosition(line, col)) {
        return this._findChildAtPosition(line, col) || this;
      } else {
        return void 0;
      }
    };
    _proto._inferEndPosition = function _inferEndPosition() {
      if (this.last && this.last.source && this.last.source.end) {
        this.source = this.source || {};
        this.source.end = this.source.end || {};
        Object.assign(this.source.end, this.last.source.end);
      }
    };
    _proto.each = function each(callback) {
      if (!this.lastEach) {
        this.lastEach = 0;
      }
      if (!this.indexes) {
        this.indexes = {};
      }
      this.lastEach++;
      var id = this.lastEach;
      this.indexes[id] = 0;
      if (!this.length) {
        return void 0;
      }
      var index, result;
      while (this.indexes[id] < this.length) {
        index = this.indexes[id];
        result = callback(this.at(index), index);
        if (result === false) {
          break;
        }
        this.indexes[id] += 1;
      }
      delete this.indexes[id];
      if (result === false) {
        return false;
      }
    };
    _proto.walk = function walk(callback) {
      return this.each(function(node, i) {
        var result = callback(node, i);
        if (result !== false && node.length) {
          result = node.walk(callback);
        }
        if (result === false) {
          return false;
        }
      });
    };
    _proto.walkAttributes = function walkAttributes(callback) {
      var _this2 = this;
      return this.walk(function(selector) {
        if (selector.type === types.ATTRIBUTE) {
          return callback.call(_this2, selector);
        }
      });
    };
    _proto.walkClasses = function walkClasses(callback) {
      var _this3 = this;
      return this.walk(function(selector) {
        if (selector.type === types.CLASS) {
          return callback.call(_this3, selector);
        }
      });
    };
    _proto.walkCombinators = function walkCombinators(callback) {
      var _this4 = this;
      return this.walk(function(selector) {
        if (selector.type === types.COMBINATOR) {
          return callback.call(_this4, selector);
        }
      });
    };
    _proto.walkComments = function walkComments(callback) {
      var _this5 = this;
      return this.walk(function(selector) {
        if (selector.type === types.COMMENT) {
          return callback.call(_this5, selector);
        }
      });
    };
    _proto.walkIds = function walkIds(callback) {
      var _this6 = this;
      return this.walk(function(selector) {
        if (selector.type === types.ID) {
          return callback.call(_this6, selector);
        }
      });
    };
    _proto.walkNesting = function walkNesting(callback) {
      var _this7 = this;
      return this.walk(function(selector) {
        if (selector.type === types.NESTING) {
          return callback.call(_this7, selector);
        }
      });
    };
    _proto.walkPseudos = function walkPseudos(callback) {
      var _this8 = this;
      return this.walk(function(selector) {
        if (selector.type === types.PSEUDO) {
          return callback.call(_this8, selector);
        }
      });
    };
    _proto.walkTags = function walkTags(callback) {
      var _this9 = this;
      return this.walk(function(selector) {
        if (selector.type === types.TAG) {
          return callback.call(_this9, selector);
        }
      });
    };
    _proto.walkUniversals = function walkUniversals(callback) {
      var _this10 = this;
      return this.walk(function(selector) {
        if (selector.type === types.UNIVERSAL) {
          return callback.call(_this10, selector);
        }
      });
    };
    _proto.split = function split(callback) {
      var _this11 = this;
      var current = [];
      return this.reduce(function(memo, node, index) {
        var split2 = callback.call(_this11, node);
        current.push(node);
        if (split2) {
          memo.push(current);
          current = [];
        } else if (index === _this11.length - 1) {
          memo.push(current);
        }
        return memo;
      }, []);
    };
    _proto.map = function map(callback) {
      return this.nodes.map(callback);
    };
    _proto.reduce = function reduce(callback, memo) {
      return this.nodes.reduce(callback, memo);
    };
    _proto.every = function every(callback) {
      return this.nodes.every(callback);
    };
    _proto.some = function some(callback) {
      return this.nodes.some(callback);
    };
    _proto.filter = function filter(callback) {
      return this.nodes.filter(callback);
    };
    _proto.sort = function sort(callback) {
      return this.nodes.sort(callback);
    };
    _proto.toString = function toString() {
      return this.map(String).join("");
    };
    _createClass(Container2, [{
      key: "first",
      get: function get2() {
        return this.at(0);
      }
    }, {
      key: "last",
      get: function get2() {
        return this.at(this.length - 1);
      }
    }, {
      key: "length",
      get: function get2() {
        return this.nodes.length;
      }
    }]);
    return Container2;
  }(_node["default"]);
  exports2["default"] = Container;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/root.js
var require_root2 = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _container = _interopRequireDefault(require_container2());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Root = /* @__PURE__ */ function(_Container) {
    _inheritsLoose(Root2, _Container);
    function Root2(opts) {
      var _this;
      _this = _Container.call(this, opts) || this;
      _this.type = _types.ROOT;
      return _this;
    }
    var _proto = Root2.prototype;
    _proto.toString = function toString() {
      var str = this.reduce(function(memo, selector) {
        memo.push(String(selector));
        return memo;
      }, []).join(",");
      return this.trailingComma ? str + "," : str;
    };
    _proto.error = function error(message, options) {
      if (this._error) {
        return this._error(message, options);
      } else {
        return new Error(message);
      }
    };
    _createClass(Root2, [{
      key: "errorGenerator",
      set: function set2(handler) {
        this._error = handler;
      }
    }]);
    return Root2;
  }(_container["default"]);
  exports2["default"] = Root;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/selector.js
var require_selector = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _container = _interopRequireDefault(require_container2());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Selector = /* @__PURE__ */ function(_Container) {
    _inheritsLoose(Selector2, _Container);
    function Selector2(opts) {
      var _this;
      _this = _Container.call(this, opts) || this;
      _this.type = _types.SELECTOR;
      return _this;
    }
    return Selector2;
  }(_container["default"]);
  exports2["default"] = Selector;
  module2.exports = exports2.default;
});

// node_modules/cssesc/cssesc.js
var require_cssesc = __commonJS((exports2, module2) => {
  /*! https://mths.be/cssesc v3.0.0 by @mathias */
  "use strict";
  var object = {};
  var hasOwnProperty = object.hasOwnProperty;
  var merge = function merge2(options, defaults) {
    if (!options) {
      return defaults;
    }
    var result = {};
    for (var key in defaults) {
      result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
    }
    return result;
  };
  var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
  var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
  var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
  var cssesc = function cssesc2(string, options) {
    options = merge(options, cssesc2.options);
    if (options.quotes != "single" && options.quotes != "double") {
      options.quotes = "single";
    }
    var quote = options.quotes == "double" ? '"' : "'";
    var isIdentifier = options.isIdentifier;
    var firstChar = string.charAt(0);
    var output = "";
    var counter = 0;
    var length = string.length;
    while (counter < length) {
      var character = string.charAt(counter++);
      var codePoint = character.charCodeAt();
      var value = void 0;
      if (codePoint < 32 || codePoint > 126) {
        if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
          } else {
            counter--;
          }
        }
        value = "\\" + codePoint.toString(16).toUpperCase() + " ";
      } else {
        if (options.escapeEverything) {
          if (regexAnySingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          }
        } else if (/[\t\n\f\r\x0B]/.test(character)) {
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
          value = "\\" + character;
        } else {
          value = character;
        }
      }
      output += value;
    }
    if (isIdentifier) {
      if (/^-[-\d]/.test(output)) {
        output = "\\-" + output.slice(1);
      } else if (/\d/.test(firstChar)) {
        output = "\\3" + firstChar + " " + output.slice(1);
      }
    }
    output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
      if ($1 && $1.length % 2) {
        return $0;
      }
      return ($1 || "") + $2;
    });
    if (!isIdentifier && options.wrap) {
      return quote + output + quote;
    }
    return output;
  };
  cssesc.options = {
    escapeEverything: false,
    isIdentifier: false,
    quotes: "single",
    wrap: false
  };
  cssesc.version = "3.0.0";
  module2.exports = cssesc;
});

// node_modules/postcss-selector-parser/dist/selectors/className.js
var require_className = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _cssesc = _interopRequireDefault(require_cssesc());
  var _util = require_util3();
  var _node = _interopRequireDefault(require_node3());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var ClassName = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(ClassName2, _Node);
    function ClassName2(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.CLASS;
      _this._constructed = true;
      return _this;
    }
    var _proto = ClassName2.prototype;
    _proto.valueToString = function valueToString() {
      return "." + _Node.prototype.valueToString.call(this);
    };
    _createClass(ClassName2, [{
      key: "value",
      get: function get2() {
        return this._value;
      },
      set: function set2(v) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(v, {
            isIdentifier: true
          });
          if (escaped !== v) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.value = escaped;
          } else if (this.raws) {
            delete this.raws.value;
          }
        }
        this._value = v;
      }
    }]);
    return ClassName2;
  }(_node["default"]);
  exports2["default"] = ClassName;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/comment.js
var require_comment2 = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _node = _interopRequireDefault(require_node3());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Comment = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Comment2, _Node);
    function Comment2(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.COMMENT;
      return _this;
    }
    return Comment2;
  }(_node["default"]);
  exports2["default"] = Comment;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/id.js
var require_id = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _node = _interopRequireDefault(require_node3());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var ID = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(ID2, _Node);
    function ID2(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.ID;
      return _this;
    }
    var _proto = ID2.prototype;
    _proto.valueToString = function valueToString() {
      return "#" + _Node.prototype.valueToString.call(this);
    };
    return ID2;
  }(_node["default"]);
  exports2["default"] = ID;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/namespace.js
var require_namespace = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _cssesc = _interopRequireDefault(require_cssesc());
  var _util = require_util3();
  var _node = _interopRequireDefault(require_node3());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Namespace = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Namespace2, _Node);
    function Namespace2() {
      return _Node.apply(this, arguments) || this;
    }
    var _proto = Namespace2.prototype;
    _proto.qualifiedName = function qualifiedName(value) {
      if (this.namespace) {
        return this.namespaceString + "|" + value;
      } else {
        return value;
      }
    };
    _proto.valueToString = function valueToString() {
      return this.qualifiedName(_Node.prototype.valueToString.call(this));
    };
    _createClass(Namespace2, [{
      key: "namespace",
      get: function get2() {
        return this._namespace;
      },
      set: function set2(namespace) {
        if (namespace === true || namespace === "*" || namespace === "&") {
          this._namespace = namespace;
          if (this.raws) {
            delete this.raws.namespace;
          }
          return;
        }
        var escaped = (0, _cssesc["default"])(namespace, {
          isIdentifier: true
        });
        this._namespace = namespace;
        if (escaped !== namespace) {
          (0, _util.ensureObject)(this, "raws");
          this.raws.namespace = escaped;
        } else if (this.raws) {
          delete this.raws.namespace;
        }
      }
    }, {
      key: "ns",
      get: function get2() {
        return this._namespace;
      },
      set: function set2(namespace) {
        this.namespace = namespace;
      }
    }, {
      key: "namespaceString",
      get: function get2() {
        if (this.namespace) {
          var ns = this.stringifyProperty("namespace");
          if (ns === true) {
            return "";
          } else {
            return ns;
          }
        } else {
          return "";
        }
      }
    }]);
    return Namespace2;
  }(_node["default"]);
  exports2["default"] = Namespace;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/tag.js
var require_tag = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _namespace = _interopRequireDefault(require_namespace());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Tag = /* @__PURE__ */ function(_Namespace) {
    _inheritsLoose(Tag2, _Namespace);
    function Tag2(opts) {
      var _this;
      _this = _Namespace.call(this, opts) || this;
      _this.type = _types.TAG;
      return _this;
    }
    return Tag2;
  }(_namespace["default"]);
  exports2["default"] = Tag;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/string.js
var require_string = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _node = _interopRequireDefault(require_node3());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var String2 = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(String3, _Node);
    function String3(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.STRING;
      return _this;
    }
    return String3;
  }(_node["default"]);
  exports2["default"] = String2;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/pseudo.js
var require_pseudo = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _container = _interopRequireDefault(require_container2());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Pseudo = /* @__PURE__ */ function(_Container) {
    _inheritsLoose(Pseudo2, _Container);
    function Pseudo2(opts) {
      var _this;
      _this = _Container.call(this, opts) || this;
      _this.type = _types.PSEUDO;
      return _this;
    }
    var _proto = Pseudo2.prototype;
    _proto.toString = function toString() {
      var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
    };
    return Pseudo2;
  }(_container["default"]);
  exports2["default"] = Pseudo;
  module2.exports = exports2.default;
});

// node_modules/util-deprecate/node.js
var require_node4 = __commonJS((exports2, module2) => {
  module2.exports = require("util").deprecate;
});

// node_modules/postcss-selector-parser/dist/selectors/attribute.js
var require_attribute = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.unescapeValue = unescapeValue;
  exports2["default"] = void 0;
  var _cssesc = _interopRequireDefault(require_cssesc());
  var _unesc = _interopRequireDefault(require_unesc());
  var _namespace = _interopRequireDefault(require_namespace());
  var _types = require_types2();
  var _CSSESC_QUOTE_OPTIONS;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var deprecate = require_node4();
  var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
  var warnOfDeprecatedValueAssignment = deprecate(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
  var warnOfDeprecatedQuotedAssignment = deprecate(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
  var warnOfDeprecatedConstructor = deprecate(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function unescapeValue(value) {
    var deprecatedUsage = false;
    var quoteMark = null;
    var unescaped = value;
    var m = unescaped.match(WRAPPED_IN_QUOTES);
    if (m) {
      quoteMark = m[1];
      unescaped = m[2];
    }
    unescaped = (0, _unesc["default"])(unescaped);
    if (unescaped !== value) {
      deprecatedUsage = true;
    }
    return {
      deprecatedUsage,
      unescaped,
      quoteMark
    };
  }
  function handleDeprecatedContructorOpts(opts) {
    if (opts.quoteMark !== void 0) {
      return opts;
    }
    if (opts.value === void 0) {
      return opts;
    }
    warnOfDeprecatedConstructor();
    var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
    if (!opts.raws) {
      opts.raws = {};
    }
    if (opts.raws.value === void 0) {
      opts.raws.value = opts.value;
    }
    opts.value = unescaped;
    opts.quoteMark = quoteMark;
    return opts;
  }
  var Attribute = /* @__PURE__ */ function(_Namespace) {
    _inheritsLoose(Attribute2, _Namespace);
    function Attribute2(opts) {
      var _this;
      if (opts === void 0) {
        opts = {};
      }
      _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
      _this.type = _types.ATTRIBUTE;
      _this.raws = _this.raws || {};
      Object.defineProperty(_this.raws, "unquoted", {
        get: deprecate(function() {
          return _this.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
        set: deprecate(function() {
          return _this.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
      });
      _this._constructed = true;
      return _this;
    }
    var _proto = Attribute2.prototype;
    _proto.getQuotedValue = function getQuotedValue(options) {
      if (options === void 0) {
        options = {};
      }
      var quoteMark = this._determineQuoteMark(options);
      var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
      var escaped = (0, _cssesc["default"])(this._value, cssescopts);
      return escaped;
    };
    _proto._determineQuoteMark = function _determineQuoteMark(options) {
      return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
    };
    _proto.setValue = function setValue(value, options) {
      if (options === void 0) {
        options = {};
      }
      this._value = value;
      this._quoteMark = this._determineQuoteMark(options);
      this._syncRawValue();
    };
    _proto.smartQuoteMark = function smartQuoteMark(options) {
      var v = this.value;
      var numSingleQuotes = v.replace(/[^']/g, "").length;
      var numDoubleQuotes = v.replace(/[^"]/g, "").length;
      if (numSingleQuotes + numDoubleQuotes === 0) {
        var escaped = (0, _cssesc["default"])(v, {
          isIdentifier: true
        });
        if (escaped === v) {
          return Attribute2.NO_QUOTE;
        } else {
          var pref = this.preferredQuoteMark(options);
          if (pref === Attribute2.NO_QUOTE) {
            var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
            var opts = CSSESC_QUOTE_OPTIONS[quote];
            var quoteValue = (0, _cssesc["default"])(v, opts);
            if (quoteValue.length < escaped.length) {
              return quote;
            }
          }
          return pref;
        }
      } else if (numDoubleQuotes === numSingleQuotes) {
        return this.preferredQuoteMark(options);
      } else if (numDoubleQuotes < numSingleQuotes) {
        return Attribute2.DOUBLE_QUOTE;
      } else {
        return Attribute2.SINGLE_QUOTE;
      }
    };
    _proto.preferredQuoteMark = function preferredQuoteMark(options) {
      var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
      if (quoteMark === void 0) {
        quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
      }
      if (quoteMark === void 0) {
        quoteMark = Attribute2.DOUBLE_QUOTE;
      }
      return quoteMark;
    };
    _proto._syncRawValue = function _syncRawValue() {
      var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
      if (rawValue === this._value) {
        if (this.raws) {
          delete this.raws.value;
        }
      } else {
        this.raws.value = rawValue;
      }
    };
    _proto._handleEscapes = function _handleEscapes(prop, value) {
      if (this._constructed) {
        var escaped = (0, _cssesc["default"])(value, {
          isIdentifier: true
        });
        if (escaped !== value) {
          this.raws[prop] = escaped;
        } else {
          delete this.raws[prop];
        }
      }
    };
    _proto._spacesFor = function _spacesFor(name) {
      var attrSpaces = {
        before: "",
        after: ""
      };
      var spaces = this.spaces[name] || {};
      var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
      return Object.assign(attrSpaces, spaces, rawSpaces);
    };
    _proto._stringFor = function _stringFor(name, spaceName, concat) {
      if (spaceName === void 0) {
        spaceName = name;
      }
      if (concat === void 0) {
        concat = defaultAttrConcat;
      }
      var attrSpaces = this._spacesFor(spaceName);
      return concat(this.stringifyProperty(name), attrSpaces);
    };
    _proto.offsetOf = function offsetOf(name) {
      var count = 1;
      var attributeSpaces = this._spacesFor("attribute");
      count += attributeSpaces.before.length;
      if (name === "namespace" || name === "ns") {
        return this.namespace ? count : -1;
      }
      if (name === "attributeNS") {
        return count;
      }
      count += this.namespaceString.length;
      if (this.namespace) {
        count += 1;
      }
      if (name === "attribute") {
        return count;
      }
      count += this.stringifyProperty("attribute").length;
      count += attributeSpaces.after.length;
      var operatorSpaces = this._spacesFor("operator");
      count += operatorSpaces.before.length;
      var operator = this.stringifyProperty("operator");
      if (name === "operator") {
        return operator ? count : -1;
      }
      count += operator.length;
      count += operatorSpaces.after.length;
      var valueSpaces = this._spacesFor("value");
      count += valueSpaces.before.length;
      var value = this.stringifyProperty("value");
      if (name === "value") {
        return value ? count : -1;
      }
      count += value.length;
      count += valueSpaces.after.length;
      var insensitiveSpaces = this._spacesFor("insensitive");
      count += insensitiveSpaces.before.length;
      if (name === "insensitive") {
        return this.insensitive ? count : -1;
      }
      return -1;
    };
    _proto.toString = function toString() {
      var _this2 = this;
      var selector = [this.rawSpaceBefore, "["];
      selector.push(this._stringFor("qualifiedAttribute", "attribute"));
      if (this.operator && (this.value || this.value === "")) {
        selector.push(this._stringFor("operator"));
        selector.push(this._stringFor("value"));
        selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
          if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
            attrSpaces.before = " ";
          }
          return defaultAttrConcat(attrValue, attrSpaces);
        }));
      }
      selector.push("]");
      selector.push(this.rawSpaceAfter);
      return selector.join("");
    };
    _createClass(Attribute2, [{
      key: "quoted",
      get: function get2() {
        var qm = this.quoteMark;
        return qm === "'" || qm === '"';
      },
      set: function set2(value) {
        warnOfDeprecatedQuotedAssignment();
      }
    }, {
      key: "quoteMark",
      get: function get2() {
        return this._quoteMark;
      },
      set: function set2(quoteMark) {
        if (!this._constructed) {
          this._quoteMark = quoteMark;
          return;
        }
        if (this._quoteMark !== quoteMark) {
          this._quoteMark = quoteMark;
          this._syncRawValue();
        }
      }
    }, {
      key: "qualifiedAttribute",
      get: function get2() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      }
    }, {
      key: "insensitiveFlag",
      get: function get2() {
        return this.insensitive ? "i" : "";
      }
    }, {
      key: "value",
      get: function get2() {
        return this._value;
      },
      set: function set2(v) {
        if (this._constructed) {
          var _unescapeValue2 = unescapeValue(v), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
          if (deprecatedUsage) {
            warnOfDeprecatedValueAssignment();
          }
          if (unescaped === this._value && quoteMark === this._quoteMark) {
            return;
          }
          this._value = unescaped;
          this._quoteMark = quoteMark;
          this._syncRawValue();
        } else {
          this._value = v;
        }
      }
    }, {
      key: "attribute",
      get: function get2() {
        return this._attribute;
      },
      set: function set2(name) {
        this._handleEscapes("attribute", name);
        this._attribute = name;
      }
    }]);
    return Attribute2;
  }(_namespace["default"]);
  exports2["default"] = Attribute;
  Attribute.NO_QUOTE = null;
  Attribute.SINGLE_QUOTE = "'";
  Attribute.DOUBLE_QUOTE = '"';
  var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
    "'": {
      quotes: "single",
      wrap: true
    },
    '"': {
      quotes: "double",
      wrap: true
    }
  }, _CSSESC_QUOTE_OPTIONS[null] = {
    isIdentifier: true
  }, _CSSESC_QUOTE_OPTIONS);
  function defaultAttrConcat(attrValue, attrSpaces) {
    return "" + attrSpaces.before + attrValue + attrSpaces.after;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/universal.js
var require_universal = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _namespace = _interopRequireDefault(require_namespace());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Universal = /* @__PURE__ */ function(_Namespace) {
    _inheritsLoose(Universal2, _Namespace);
    function Universal2(opts) {
      var _this;
      _this = _Namespace.call(this, opts) || this;
      _this.type = _types.UNIVERSAL;
      _this.value = "*";
      return _this;
    }
    return Universal2;
  }(_namespace["default"]);
  exports2["default"] = Universal;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/combinator.js
var require_combinator = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _node = _interopRequireDefault(require_node3());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Combinator = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Combinator2, _Node);
    function Combinator2(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.COMBINATOR;
      return _this;
    }
    return Combinator2;
  }(_node["default"]);
  exports2["default"] = Combinator;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/nesting.js
var require_nesting = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _node = _interopRequireDefault(require_node3());
  var _types = require_types2();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var Nesting = /* @__PURE__ */ function(_Node) {
    _inheritsLoose(Nesting2, _Node);
    function Nesting2(opts) {
      var _this;
      _this = _Node.call(this, opts) || this;
      _this.type = _types.NESTING;
      _this.value = "&";
      return _this;
    }
    return Nesting2;
  }(_node["default"]);
  exports2["default"] = Nesting;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/sortAscending.js
var require_sortAscending = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = sortAscending;
  function sortAscending(list) {
    return list.sort(function(a, b) {
      return a - b;
    });
  }
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/tokenTypes.js
var require_tokenTypes = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.combinator = exports2.word = exports2.comment = exports2.str = exports2.tab = exports2.newline = exports2.feed = exports2.cr = exports2.backslash = exports2.bang = exports2.slash = exports2.doubleQuote = exports2.singleQuote = exports2.space = exports2.greaterThan = exports2.pipe = exports2.equals = exports2.plus = exports2.caret = exports2.tilde = exports2.dollar = exports2.closeSquare = exports2.openSquare = exports2.closeParenthesis = exports2.openParenthesis = exports2.semicolon = exports2.colon = exports2.comma = exports2.at = exports2.asterisk = exports2.ampersand = void 0;
  var ampersand = 38;
  exports2.ampersand = ampersand;
  var asterisk = 42;
  exports2.asterisk = asterisk;
  var at = 64;
  exports2.at = at;
  var comma = 44;
  exports2.comma = comma;
  var colon = 58;
  exports2.colon = colon;
  var semicolon = 59;
  exports2.semicolon = semicolon;
  var openParenthesis = 40;
  exports2.openParenthesis = openParenthesis;
  var closeParenthesis = 41;
  exports2.closeParenthesis = closeParenthesis;
  var openSquare = 91;
  exports2.openSquare = openSquare;
  var closeSquare = 93;
  exports2.closeSquare = closeSquare;
  var dollar = 36;
  exports2.dollar = dollar;
  var tilde = 126;
  exports2.tilde = tilde;
  var caret = 94;
  exports2.caret = caret;
  var plus = 43;
  exports2.plus = plus;
  var equals = 61;
  exports2.equals = equals;
  var pipe = 124;
  exports2.pipe = pipe;
  var greaterThan = 62;
  exports2.greaterThan = greaterThan;
  var space = 32;
  exports2.space = space;
  var singleQuote = 39;
  exports2.singleQuote = singleQuote;
  var doubleQuote = 34;
  exports2.doubleQuote = doubleQuote;
  var slash = 47;
  exports2.slash = slash;
  var bang = 33;
  exports2.bang = bang;
  var backslash = 92;
  exports2.backslash = backslash;
  var cr = 13;
  exports2.cr = cr;
  var feed = 12;
  exports2.feed = feed;
  var newline = 10;
  exports2.newline = newline;
  var tab = 9;
  exports2.tab = tab;
  var str = singleQuote;
  exports2.str = str;
  var comment = -1;
  exports2.comment = comment;
  var word = -2;
  exports2.word = word;
  var combinator = -3;
  exports2.combinator = combinator;
});

// node_modules/postcss-selector-parser/dist/tokenize.js
var require_tokenize2 = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = tokenize;
  exports2.FIELDS = void 0;
  var t = _interopRequireWildcard(require_tokenTypes());
  var _unescapable;
  var _wordDelimiters;
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function _getRequireWildcardCache2() {
      return cache;
    };
    return cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {default: obj};
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
  var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
  var hex = {};
  var hexChars = "0123456789abcdefABCDEF";
  for (var i = 0; i < hexChars.length; i++) {
    hex[hexChars.charCodeAt(i)] = true;
  }
  function consumeWord(css, start) {
    var next = start;
    var code;
    do {
      code = css.charCodeAt(next);
      if (wordDelimiters[code]) {
        return next - 1;
      } else if (code === t.backslash) {
        next = consumeEscape(css, next) + 1;
      } else {
        next++;
      }
    } while (next < css.length);
    return next - 1;
  }
  function consumeEscape(css, start) {
    var next = start;
    var code = css.charCodeAt(next + 1);
    if (unescapable[code]) {
    } else if (hex[code]) {
      var hexDigits = 0;
      do {
        next++;
        hexDigits++;
        code = css.charCodeAt(next + 1);
      } while (hex[code] && hexDigits < 6);
      if (hexDigits < 6 && code === t.space) {
        next++;
      }
    } else {
      next++;
    }
    return next;
  }
  var FIELDS = {
    TYPE: 0,
    START_LINE: 1,
    START_COL: 2,
    END_LINE: 3,
    END_COL: 4,
    START_POS: 5,
    END_POS: 6
  };
  exports2.FIELDS = FIELDS;
  function tokenize(input) {
    var tokens = [];
    var css = input.css.valueOf();
    var _css = css, length = _css.length;
    var offset = -1;
    var line = 1;
    var start = 0;
    var end = 0;
    var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
    function unclosed(what, fix) {
      if (input.safe) {
        css += fix;
        next = css.length - 1;
      } else {
        throw input.error("Unclosed " + what, line, start - offset, start);
      }
    }
    while (start < length) {
      code = css.charCodeAt(start);
      if (code === t.newline) {
        offset = start;
        line += 1;
      }
      switch (code) {
        case t.space:
        case t.tab:
        case t.newline:
        case t.cr:
        case t.feed:
          next = start;
          do {
            next += 1;
            code = css.charCodeAt(next);
            if (code === t.newline) {
              offset = next;
              line += 1;
            }
          } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
          tokenType = t.space;
          endLine = line;
          endColumn = next - offset - 1;
          end = next;
          break;
        case t.plus:
        case t.greaterThan:
        case t.tilde:
        case t.pipe:
          next = start;
          do {
            next += 1;
            code = css.charCodeAt(next);
          } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
          tokenType = t.combinator;
          endLine = line;
          endColumn = start - offset;
          end = next;
          break;
        case t.asterisk:
        case t.ampersand:
        case t.bang:
        case t.comma:
        case t.equals:
        case t.dollar:
        case t.caret:
        case t.openSquare:
        case t.closeSquare:
        case t.colon:
        case t.semicolon:
        case t.openParenthesis:
        case t.closeParenthesis:
          next = start;
          tokenType = code;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
          break;
        case t.singleQuote:
        case t.doubleQuote:
          quote = code === t.singleQuote ? "'" : '"';
          next = start;
          do {
            escaped = false;
            next = css.indexOf(quote, next + 1);
            if (next === -1) {
              unclosed("quote", quote);
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === t.backslash) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          tokenType = t.str;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
          break;
        default:
          if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
            next = css.indexOf("*/", start + 2) + 1;
            if (next === 0) {
              unclosed("comment", "*/");
            }
            content = css.slice(start, next + 1);
            lines = content.split("\n");
            last = lines.length - 1;
            if (last > 0) {
              nextLine = line + last;
              nextOffset = next - lines[last].length;
            } else {
              nextLine = line;
              nextOffset = offset;
            }
            tokenType = t.comment;
            line = nextLine;
            endLine = nextLine;
            endColumn = next - nextOffset;
          } else if (code === t.slash) {
            next = start;
            tokenType = code;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
          } else {
            next = consumeWord(css, start);
            tokenType = t.word;
            endLine = line;
            endColumn = next - offset;
          }
          end = next + 1;
          break;
      }
      tokens.push([
        tokenType,
        line,
        start - offset,
        endLine,
        endColumn,
        start,
        end
      ]);
      if (nextOffset) {
        offset = nextOffset;
        nextOffset = null;
      }
      start = end;
    }
    return tokens;
  }
});

// node_modules/postcss-selector-parser/dist/parser.js
var require_parser2 = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _root = _interopRequireDefault(require_root2());
  var _selector = _interopRequireDefault(require_selector());
  var _className = _interopRequireDefault(require_className());
  var _comment = _interopRequireDefault(require_comment2());
  var _id = _interopRequireDefault(require_id());
  var _tag = _interopRequireDefault(require_tag());
  var _string = _interopRequireDefault(require_string());
  var _pseudo = _interopRequireDefault(require_pseudo());
  var _attribute = _interopRequireWildcard(require_attribute());
  var _universal = _interopRequireDefault(require_universal());
  var _combinator = _interopRequireDefault(require_combinator());
  var _nesting = _interopRequireDefault(require_nesting());
  var _sortAscending = _interopRequireDefault(require_sortAscending());
  var _tokenize = _interopRequireWildcard(require_tokenize2());
  var tokens = _interopRequireWildcard(require_tokenTypes());
  var types = _interopRequireWildcard(require_types2());
  var _util = require_util3();
  var _WHITESPACE_TOKENS;
  var _Object$assign;
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function _getRequireWildcardCache2() {
      return cache;
    };
    return cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {default: obj};
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
  var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
  function tokenStart(token) {
    return {
      line: token[_tokenize.FIELDS.START_LINE],
      column: token[_tokenize.FIELDS.START_COL]
    };
  }
  function tokenEnd(token) {
    return {
      line: token[_tokenize.FIELDS.END_LINE],
      column: token[_tokenize.FIELDS.END_COL]
    };
  }
  function getSource(startLine, startColumn, endLine, endColumn) {
    return {
      start: {
        line: startLine,
        column: startColumn
      },
      end: {
        line: endLine,
        column: endColumn
      }
    };
  }
  function getTokenSource(token) {
    return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
  }
  function getTokenSourceSpan(startToken, endToken) {
    if (!startToken) {
      return void 0;
    }
    return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
  }
  function unescapeProp(node, prop) {
    var value = node[prop];
    if (typeof value !== "string") {
      return;
    }
    if (value.indexOf("\\") !== -1) {
      (0, _util.ensureObject)(node, "raws");
      node[prop] = (0, _util.unesc)(value);
      if (node.raws[prop] === void 0) {
        node.raws[prop] = value;
      }
    }
    return node;
  }
  function indexesOf(array, item) {
    var i = -1;
    var indexes = [];
    while ((i = array.indexOf(item, i + 1)) !== -1) {
      indexes.push(i);
    }
    return indexes;
  }
  function uniqs() {
    var list = Array.prototype.concat.apply([], arguments);
    return list.filter(function(item, i) {
      return i === list.indexOf(item);
    });
  }
  var Parser = /* @__PURE__ */ function() {
    function Parser2(rule, options) {
      if (options === void 0) {
        options = {};
      }
      this.rule = rule;
      this.options = Object.assign({
        lossy: false,
        safe: false
      }, options);
      this.position = 0;
      this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
      this.tokens = (0, _tokenize["default"])({
        css: this.css,
        error: this._errorGenerator(),
        safe: this.options.safe
      });
      var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new _root["default"]({
        source: rootSource
      });
      this.root.errorGenerator = this._errorGenerator();
      var selector = new _selector["default"]({
        source: {
          start: {
            line: 1,
            column: 1
          }
        }
      });
      this.root.append(selector);
      this.current = selector;
      this.loop();
    }
    var _proto = Parser2.prototype;
    _proto._errorGenerator = function _errorGenerator() {
      var _this = this;
      return function(message, errorOptions) {
        if (typeof _this.rule === "string") {
          return new Error(message);
        }
        return _this.rule.error(message, errorOptions);
      };
    };
    _proto.attribute = function attribute() {
      var attr = [];
      var startingToken = this.currToken;
      this.position++;
      while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
        attr.push(this.currToken);
        this.position++;
      }
      if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
        return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
      }
      var len = attr.length;
      var node = {
        source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
        sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
      };
      if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
        return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
      }
      var pos = 0;
      var spaceBefore = "";
      var commentBefore = "";
      var lastAdded = null;
      var spaceAfterMeaningfulToken = false;
      while (pos < len) {
        var token = attr[pos];
        var content = this.content(token);
        var next = attr[pos + 1];
        switch (token[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            spaceAfterMeaningfulToken = true;
            if (this.options.lossy) {
              break;
            }
            if (lastAdded) {
              (0, _util.ensureObject)(node, "spaces", lastAdded);
              var prevContent = node.spaces[lastAdded].after || "";
              node.spaces[lastAdded].after = prevContent + content;
              var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
              if (existingComment) {
                node.raws.spaces[lastAdded].after = existingComment + content;
              }
            } else {
              spaceBefore = spaceBefore + content;
              commentBefore = commentBefore + content;
            }
            break;
          case tokens.asterisk:
            if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node.operator = content;
              lastAdded = "operator";
            } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
              if (spaceBefore) {
                (0, _util.ensureObject)(node, "spaces", "attribute");
                node.spaces.attribute.before = spaceBefore;
                spaceBefore = "";
              }
              if (commentBefore) {
                (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                node.raws.spaces.attribute.before = spaceBefore;
                commentBefore = "";
              }
              node.namespace = (node.namespace || "") + content;
              var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
              if (rawValue) {
                node.raws.namespace += content;
              }
              lastAdded = "namespace";
            }
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.dollar:
            if (lastAdded === "value") {
              var oldRawValue = (0, _util.getProp)(node, "raws", "value");
              node.value += "$";
              if (oldRawValue) {
                node.raws.value = oldRawValue + "$";
              }
              break;
            }
          case tokens.caret:
            if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node.operator = content;
              lastAdded = "operator";
            }
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.combinator:
            if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node.operator = content;
              lastAdded = "operator";
            }
            if (content !== "|") {
              spaceAfterMeaningfulToken = false;
              break;
            }
            if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
              node.operator = content;
              lastAdded = "operator";
            } else if (!node.namespace && !node.attribute) {
              node.namespace = true;
            }
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.word:
            if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && !node.operator && !node.namespace) {
              node.namespace = content;
              lastAdded = "namespace";
            } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
              if (spaceBefore) {
                (0, _util.ensureObject)(node, "spaces", "attribute");
                node.spaces.attribute.before = spaceBefore;
                spaceBefore = "";
              }
              if (commentBefore) {
                (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                node.raws.spaces.attribute.before = commentBefore;
                commentBefore = "";
              }
              node.attribute = (node.attribute || "") + content;
              var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
              if (_rawValue) {
                node.raws.attribute += content;
              }
              lastAdded = "attribute";
            } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
              var _unescaped = (0, _util.unesc)(content);
              var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
              var oldValue = node.value || "";
              node.value = oldValue + _unescaped;
              node.quoteMark = null;
              if (_unescaped !== content || _oldRawValue) {
                (0, _util.ensureObject)(node, "raws");
                node.raws.value = (_oldRawValue || oldValue) + content;
              }
              lastAdded = "value";
            } else {
              var insensitive = content === "i" || content === "I";
              if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                node.insensitive = insensitive;
                if (!insensitive || content === "I") {
                  (0, _util.ensureObject)(node, "raws");
                  node.raws.insensitiveFlag = content;
                }
                lastAdded = "insensitive";
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "insensitive");
                  node.spaces.insensitive.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                  node.raws.spaces.insensitive.before = commentBefore;
                  commentBefore = "";
                }
              } else if (node.value || node.value === "") {
                lastAdded = "value";
                node.value += content;
                if (node.raws.value) {
                  node.raws.value += content;
                }
              }
            }
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.str:
            if (!node.attribute || !node.operator) {
              return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: token[_tokenize.FIELDS.START_POS]
              });
            }
            var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
            node.value = unescaped;
            node.quoteMark = quoteMark;
            lastAdded = "value";
            (0, _util.ensureObject)(node, "raws");
            node.raws.value = content;
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.equals:
            if (!node.attribute) {
              return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
            }
            if (node.value) {
              return this.error('Unexpected "=" found; an operator was already defined.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
            }
            node.operator = node.operator ? node.operator + content : content;
            lastAdded = "operator";
            spaceAfterMeaningfulToken = false;
            break;
          case tokens.comment:
            if (lastAdded) {
              if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                node.raws.spaces[lastAdded].after = rawLastComment + content;
              } else {
                var lastValue = node[lastAdded] || "";
                var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                (0, _util.ensureObject)(node, "raws");
                node.raws[lastAdded] = rawLastValue + content;
              }
            } else {
              commentBefore = commentBefore + content;
            }
            break;
          default:
            return this.error('Unexpected "' + content + '" found.', {
              index: token[_tokenize.FIELDS.START_POS]
            });
        }
        pos++;
      }
      unescapeProp(node, "attribute");
      unescapeProp(node, "namespace");
      this.newNode(new _attribute["default"](node));
      this.position++;
    };
    _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
      if (stopPosition < 0) {
        stopPosition = this.tokens.length;
      }
      var startPosition = this.position;
      var nodes = [];
      var space = "";
      var lastComment = void 0;
      do {
        if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
          if (!this.options.lossy) {
            space += this.content();
          }
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
          var spaces = {};
          if (space) {
            spaces.before = space;
            space = "";
          }
          lastComment = new _comment["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            spaces
          });
          nodes.push(lastComment);
        }
      } while (++this.position < stopPosition);
      if (space) {
        if (lastComment) {
          lastComment.spaces.after = space;
        } else if (!this.options.lossy) {
          var firstToken = this.tokens[startPosition];
          var lastToken = this.tokens[this.position - 1];
          nodes.push(new _string["default"]({
            value: "",
            source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces: {
              before: space,
              after: ""
            }
          }));
        }
      }
      return nodes;
    };
    _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
      var _this2 = this;
      if (requiredSpace === void 0) {
        requiredSpace = false;
      }
      var space = "";
      var rawSpace = "";
      nodes.forEach(function(n) {
        var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
        var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
        space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
        rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
      });
      if (rawSpace === space) {
        rawSpace = void 0;
      }
      var result = {
        space,
        rawSpace
      };
      return result;
    };
    _proto.isNamedCombinator = function isNamedCombinator(position) {
      if (position === void 0) {
        position = this.position;
      }
      return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
    };
    _proto.namedCombinator = function namedCombinator() {
      if (this.isNamedCombinator()) {
        var nameRaw = this.content(this.tokens[this.position + 1]);
        var name = (0, _util.unesc)(nameRaw).toLowerCase();
        var raws = {};
        if (name !== nameRaw) {
          raws.value = "/" + nameRaw + "/";
        }
        var node = new _combinator["default"]({
          value: "/" + name + "/",
          source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          raws
        });
        this.position = this.position + 3;
        return node;
      } else {
        this.unexpected();
      }
    };
    _proto.combinator = function combinator() {
      var _this3 = this;
      if (this.content() === "|") {
        return this.namespace();
      }
      var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
      if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
        var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        if (nodes.length > 0) {
          var last = this.current.last;
          if (last) {
            var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
            if (rawSpace !== void 0) {
              last.rawSpaceAfter += rawSpace;
            }
            last.spaces.after += space;
          } else {
            nodes.forEach(function(n) {
              return _this3.newNode(n);
            });
          }
        }
        return;
      }
      var firstToken = this.currToken;
      var spaceOrDescendantSelectorNodes = void 0;
      if (nextSigTokenPos > this.position) {
        spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
      }
      var node;
      if (this.isNamedCombinator()) {
        node = this.namedCombinator();
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
        node = new _combinator["default"]({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
        });
        this.position++;
      } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
      } else if (!spaceOrDescendantSelectorNodes) {
        this.unexpected();
      }
      if (node) {
        if (spaceOrDescendantSelectorNodes) {
          var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
          node.spaces.before = _space;
          node.rawSpaceBefore = _rawSpace;
        }
      } else {
        var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
        if (!_rawSpace2) {
          _rawSpace2 = _space2;
        }
        var spaces = {};
        var raws = {
          spaces: {}
        };
        if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
          spaces.before = _space2.slice(0, _space2.length - 1);
          raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
        } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
          spaces.after = _space2.slice(1);
          raws.spaces.after = _rawSpace2.slice(1);
        } else {
          raws.value = _rawSpace2;
        }
        node = new _combinator["default"]({
          value: " ",
          source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces,
          raws
        });
      }
      if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
        node.spaces.after = this.optionalSpace(this.content());
        this.position++;
      }
      return this.newNode(node);
    };
    _proto.comma = function comma() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true;
        this.position++;
        return;
      }
      this.current._inferEndPosition();
      var selector = new _selector["default"]({
        source: {
          start: tokenStart(this.tokens[this.position + 1])
        }
      });
      this.current.parent.append(selector);
      this.current = selector;
      this.position++;
    };
    _proto.comment = function comment() {
      var current = this.currToken;
      this.newNode(new _comment["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }));
      this.position++;
    };
    _proto.error = function error(message, opts) {
      throw this.root.error(message, opts);
    };
    _proto.missingBackslash = function missingBackslash() {
      return this.error("Expected a backslash preceding the semicolon.", {
        index: this.currToken[_tokenize.FIELDS.START_POS]
      });
    };
    _proto.missingParenthesis = function missingParenthesis() {
      return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
    };
    _proto.missingSquareBracket = function missingSquareBracket() {
      return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
    };
    _proto.unexpected = function unexpected() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
    };
    _proto.namespace = function namespace() {
      var before = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
        this.position++;
        return this.word(before);
      } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
        this.position++;
        return this.universal(before);
      }
    };
    _proto.nesting = function nesting() {
      if (this.nextToken) {
        var nextContent = this.content(this.nextToken);
        if (nextContent === "|") {
          this.position++;
          return;
        }
      }
      var current = this.currToken;
      this.newNode(new _nesting["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }));
      this.position++;
    };
    _proto.parentheses = function parentheses() {
      var last = this.current.last;
      var unbalanced = 1;
      this.position++;
      if (last && last.type === types.PSEUDO) {
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position - 1])
          }
        });
        var cache = this.current;
        last.append(selector);
        this.current = selector;
        while (this.position < this.tokens.length && unbalanced) {
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            unbalanced++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            unbalanced--;
          }
          if (unbalanced) {
            this.parse();
          } else {
            this.current.source.end = tokenEnd(this.currToken);
            this.current.parent.source.end = tokenEnd(this.currToken);
            this.position++;
          }
        }
        this.current = cache;
      } else {
        var parenStart = this.currToken;
        var parenValue = "(";
        var parenEnd;
        while (this.position < this.tokens.length && unbalanced) {
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            unbalanced++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            unbalanced--;
          }
          parenEnd = this.currToken;
          parenValue += this.parseParenthesisToken(this.currToken);
          this.position++;
        }
        if (last) {
          last.appendToPropertyAndEscape("value", parenValue, parenValue);
        } else {
          this.newNode(new _string["default"]({
            value: parenValue,
            source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
            sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
          }));
        }
      }
      if (unbalanced) {
        return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
      }
    };
    _proto.pseudo = function pseudo() {
      var _this4 = this;
      var pseudoStr = "";
      var startingToken = this.currToken;
      while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
        pseudoStr += this.content();
        this.position++;
      }
      if (!this.currToken) {
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      }
      if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
        this.splitWord(false, function(first, length) {
          pseudoStr += first;
          _this4.newNode(new _pseudo["default"]({
            value: pseudoStr,
            source: getTokenSourceSpan(startingToken, _this4.currToken),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          }));
          if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
            _this4.error("Misplaced parenthesis.", {
              index: _this4.nextToken[_tokenize.FIELDS.START_POS]
            });
          }
        });
      } else {
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
      }
    };
    _proto.space = function space() {
      var content = this.content();
      if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
        return node.type === "comment";
      })) {
        this.spaces = this.optionalSpace(content);
        this.position++;
      } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
        this.current.last.spaces.after = this.optionalSpace(content);
        this.position++;
      } else {
        this.combinator();
      }
    };
    _proto.string = function string() {
      var current = this.currToken;
      this.newNode(new _string["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }));
      this.position++;
    };
    _proto.universal = function universal(namespace) {
      var nextToken = this.nextToken;
      if (nextToken && this.content(nextToken) === "|") {
        this.position++;
        return this.namespace();
      }
      var current = this.currToken;
      this.newNode(new _universal["default"]({
        value: this.content(),
        source: getTokenSource(current),
        sourceIndex: current[_tokenize.FIELDS.START_POS]
      }), namespace);
      this.position++;
    };
    _proto.splitWord = function splitWord(namespace, firstCallback) {
      var _this5 = this;
      var nextToken = this.nextToken;
      var word = this.content();
      while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
        this.position++;
        var current = this.content();
        word += current;
        if (current.lastIndexOf("\\") === current.length - 1) {
          var next = this.nextToken;
          if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
            word += this.requiredSpace(this.content(next));
            this.position++;
          }
        }
        nextToken = this.nextToken;
      }
      var hasClass = indexesOf(word, ".").filter(function(i) {
        return word[i - 1] !== "\\";
      });
      var hasId = indexesOf(word, "#").filter(function(i) {
        return word[i - 1] !== "\\";
      });
      var interpolations = indexesOf(word, "#{");
      if (interpolations.length) {
        hasId = hasId.filter(function(hashIndex) {
          return !~interpolations.indexOf(hashIndex);
        });
      }
      var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
      indices.forEach(function(ind, i) {
        var index = indices[i + 1] || word.length;
        var value = word.slice(ind, index);
        if (i === 0 && firstCallback) {
          return firstCallback.call(_this5, value, indices.length);
        }
        var node;
        var current2 = _this5.currToken;
        var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i];
        var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index - 1));
        if (~hasClass.indexOf(ind)) {
          var classNameOpts = {
            value: value.slice(1),
            source,
            sourceIndex
          };
          node = new _className["default"](unescapeProp(classNameOpts, "value"));
        } else if (~hasId.indexOf(ind)) {
          var idOpts = {
            value: value.slice(1),
            source,
            sourceIndex
          };
          node = new _id["default"](unescapeProp(idOpts, "value"));
        } else {
          var tagOpts = {
            value,
            source,
            sourceIndex
          };
          unescapeProp(tagOpts, "value");
          node = new _tag["default"](tagOpts);
        }
        _this5.newNode(node, namespace);
        namespace = null;
      });
      this.position++;
    };
    _proto.word = function word(namespace) {
      var nextToken = this.nextToken;
      if (nextToken && this.content(nextToken) === "|") {
        this.position++;
        return this.namespace();
      }
      return this.splitWord(namespace);
    };
    _proto.loop = function loop() {
      while (this.position < this.tokens.length) {
        this.parse(true);
      }
      this.current._inferEndPosition();
      return this.root;
    };
    _proto.parse = function parse2(throwOnParenthesis) {
      switch (this.currToken[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          this.space();
          break;
        case tokens.comment:
          this.comment();
          break;
        case tokens.openParenthesis:
          this.parentheses();
          break;
        case tokens.closeParenthesis:
          if (throwOnParenthesis) {
            this.missingParenthesis();
          }
          break;
        case tokens.openSquare:
          this.attribute();
          break;
        case tokens.dollar:
        case tokens.caret:
        case tokens.equals:
        case tokens.word:
          this.word();
          break;
        case tokens.colon:
          this.pseudo();
          break;
        case tokens.comma:
          this.comma();
          break;
        case tokens.asterisk:
          this.universal();
          break;
        case tokens.ampersand:
          this.nesting();
          break;
        case tokens.slash:
        case tokens.combinator:
          this.combinator();
          break;
        case tokens.str:
          this.string();
          break;
        case tokens.closeSquare:
          this.missingSquareBracket();
        case tokens.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    };
    _proto.expected = function expected(description, index, found) {
      if (Array.isArray(description)) {
        var last = description.pop();
        description = description.join(", ") + " or " + last;
      }
      var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
      if (!found) {
        return this.error("Expected " + an + " " + description + ".", {
          index
        });
      }
      return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
        index
      });
    };
    _proto.requiredSpace = function requiredSpace(space) {
      return this.options.lossy ? " " : space;
    };
    _proto.optionalSpace = function optionalSpace(space) {
      return this.options.lossy ? "" : space;
    };
    _proto.lossySpace = function lossySpace(space, required) {
      if (this.options.lossy) {
        return required ? " " : "";
      } else {
        return space;
      }
    };
    _proto.parseParenthesisToken = function parseParenthesisToken(token) {
      var content = this.content(token);
      if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
        return this.requiredSpace(content);
      } else {
        return content;
      }
    };
    _proto.newNode = function newNode(node, namespace) {
      if (namespace) {
        if (/^ +$/.test(namespace)) {
          if (!this.options.lossy) {
            this.spaces = (this.spaces || "") + namespace;
          }
          namespace = true;
        }
        node.namespace = namespace;
        unescapeProp(node, "namespace");
      }
      if (this.spaces) {
        node.spaces.before = this.spaces;
        this.spaces = "";
      }
      return this.current.append(node);
    };
    _proto.content = function content(token) {
      if (token === void 0) {
        token = this.currToken;
      }
      return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
    };
    _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
      if (startPosition === void 0) {
        startPosition = this.position + 1;
      }
      var searchPosition = startPosition;
      while (searchPosition < this.tokens.length) {
        if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
          searchPosition++;
          continue;
        } else {
          return searchPosition;
        }
      }
      return -1;
    };
    _createClass(Parser2, [{
      key: "currToken",
      get: function get2() {
        return this.tokens[this.position];
      }
    }, {
      key: "nextToken",
      get: function get2() {
        return this.tokens[this.position + 1];
      }
    }, {
      key: "prevToken",
      get: function get2() {
        return this.tokens[this.position - 1];
      }
    }]);
    return Parser2;
  }();
  exports2["default"] = Parser;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/processor.js
var require_processor2 = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _parser = _interopRequireDefault(require_parser2());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var Processor = /* @__PURE__ */ function() {
    function Processor2(func, options) {
      this.func = func || function noop() {
      };
      this.funcRes = null;
      this.options = options;
    }
    var _proto = Processor2.prototype;
    _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
      if (options === void 0) {
        options = {};
      }
      var merged = Object.assign({}, this.options, options);
      if (merged.updateSelector === false) {
        return false;
      } else {
        return typeof rule !== "string";
      }
    };
    _proto._isLossy = function _isLossy(options) {
      if (options === void 0) {
        options = {};
      }
      var merged = Object.assign({}, this.options, options);
      if (merged.lossless === false) {
        return true;
      } else {
        return false;
      }
    };
    _proto._root = function _root(rule, options) {
      if (options === void 0) {
        options = {};
      }
      var parser = new _parser["default"](rule, this._parseOptions(options));
      return parser.root;
    };
    _proto._parseOptions = function _parseOptions(options) {
      return {
        lossy: this._isLossy(options)
      };
    };
    _proto._run = function _run(rule, options) {
      var _this = this;
      if (options === void 0) {
        options = {};
      }
      return new Promise(function(resolve, reject) {
        try {
          var root = _this._root(rule, options);
          Promise.resolve(_this.func(root)).then(function(transform) {
            var string = void 0;
            if (_this._shouldUpdateSelector(rule, options)) {
              string = root.toString();
              rule.selector = string;
            }
            return {
              transform,
              root,
              string
            };
          }).then(resolve, reject);
        } catch (e) {
          reject(e);
          return;
        }
      });
    };
    _proto._runSync = function _runSync(rule, options) {
      if (options === void 0) {
        options = {};
      }
      var root = this._root(rule, options);
      var transform = this.func(root);
      if (transform && typeof transform.then === "function") {
        throw new Error("Selector processor returned a promise to a synchronous call.");
      }
      var string = void 0;
      if (options.updateSelector && typeof rule !== "string") {
        string = root.toString();
        rule.selector = string;
      }
      return {
        transform,
        root,
        string
      };
    };
    _proto.ast = function ast(rule, options) {
      return this._run(rule, options).then(function(result) {
        return result.root;
      });
    };
    _proto.astSync = function astSync(rule, options) {
      return this._runSync(rule, options).root;
    };
    _proto.transform = function transform(rule, options) {
      return this._run(rule, options).then(function(result) {
        return result.transform;
      });
    };
    _proto.transformSync = function transformSync(rule, options) {
      return this._runSync(rule, options).transform;
    };
    _proto.process = function process2(rule, options) {
      return this._run(rule, options).then(function(result) {
        return result.string || result.root.toString();
      });
    };
    _proto.processSync = function processSync(rule, options) {
      var result = this._runSync(rule, options);
      return result.string || result.root.toString();
    };
    return Processor2;
  }();
  exports2["default"] = Processor;
  module2.exports = exports2.default;
});

// node_modules/postcss-selector-parser/dist/selectors/constructors.js
var require_constructors = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.universal = exports2.tag = exports2.string = exports2.selector = exports2.root = exports2.pseudo = exports2.nesting = exports2.id = exports2.comment = exports2.combinator = exports2.className = exports2.attribute = void 0;
  var _attribute = _interopRequireDefault(require_attribute());
  var _className = _interopRequireDefault(require_className());
  var _combinator = _interopRequireDefault(require_combinator());
  var _comment = _interopRequireDefault(require_comment2());
  var _id = _interopRequireDefault(require_id());
  var _nesting = _interopRequireDefault(require_nesting());
  var _pseudo = _interopRequireDefault(require_pseudo());
  var _root = _interopRequireDefault(require_root2());
  var _selector = _interopRequireDefault(require_selector());
  var _string = _interopRequireDefault(require_string());
  var _tag = _interopRequireDefault(require_tag());
  var _universal = _interopRequireDefault(require_universal());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var attribute = function attribute2(opts) {
    return new _attribute["default"](opts);
  };
  exports2.attribute = attribute;
  var className = function className2(opts) {
    return new _className["default"](opts);
  };
  exports2.className = className;
  var combinator = function combinator2(opts) {
    return new _combinator["default"](opts);
  };
  exports2.combinator = combinator;
  var comment = function comment2(opts) {
    return new _comment["default"](opts);
  };
  exports2.comment = comment;
  var id = function id2(opts) {
    return new _id["default"](opts);
  };
  exports2.id = id;
  var nesting = function nesting2(opts) {
    return new _nesting["default"](opts);
  };
  exports2.nesting = nesting;
  var pseudo = function pseudo2(opts) {
    return new _pseudo["default"](opts);
  };
  exports2.pseudo = pseudo;
  var root = function root2(opts) {
    return new _root["default"](opts);
  };
  exports2.root = root;
  var selector = function selector2(opts) {
    return new _selector["default"](opts);
  };
  exports2.selector = selector;
  var string = function string2(opts) {
    return new _string["default"](opts);
  };
  exports2.string = string;
  var tag = function tag2(opts) {
    return new _tag["default"](opts);
  };
  exports2.tag = tag;
  var universal = function universal2(opts) {
    return new _universal["default"](opts);
  };
  exports2.universal = universal;
});

// node_modules/postcss-selector-parser/dist/selectors/guards.js
var require_guards = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  exports2.isNode = isNode;
  exports2.isPseudoElement = isPseudoElement;
  exports2.isPseudoClass = isPseudoClass;
  exports2.isContainer = isContainer;
  exports2.isNamespace = isNamespace;
  exports2.isUniversal = exports2.isTag = exports2.isString = exports2.isSelector = exports2.isRoot = exports2.isPseudo = exports2.isNesting = exports2.isIdentifier = exports2.isComment = exports2.isCombinator = exports2.isClassName = exports2.isAttribute = void 0;
  var _types = require_types2();
  var _IS_TYPE;
  var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
  function isNode(node) {
    return typeof node === "object" && IS_TYPE[node.type];
  }
  function isNodeType(type, node) {
    return isNode(node) && node.type === type;
  }
  var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
  exports2.isAttribute = isAttribute;
  var isClassName = isNodeType.bind(null, _types.CLASS);
  exports2.isClassName = isClassName;
  var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
  exports2.isCombinator = isCombinator;
  var isComment = isNodeType.bind(null, _types.COMMENT);
  exports2.isComment = isComment;
  var isIdentifier = isNodeType.bind(null, _types.ID);
  exports2.isIdentifier = isIdentifier;
  var isNesting = isNodeType.bind(null, _types.NESTING);
  exports2.isNesting = isNesting;
  var isPseudo = isNodeType.bind(null, _types.PSEUDO);
  exports2.isPseudo = isPseudo;
  var isRoot = isNodeType.bind(null, _types.ROOT);
  exports2.isRoot = isRoot;
  var isSelector = isNodeType.bind(null, _types.SELECTOR);
  exports2.isSelector = isSelector;
  var isString = isNodeType.bind(null, _types.STRING);
  exports2.isString = isString;
  var isTag = isNodeType.bind(null, _types.TAG);
  exports2.isTag = isTag;
  var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
  exports2.isUniversal = isUniversal;
  function isPseudoElement(node) {
    return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after");
  }
  function isPseudoClass(node) {
    return isPseudo(node) && !isPseudoElement(node);
  }
  function isContainer(node) {
    return !!(isNode(node) && node.walk);
  }
  function isNamespace(node) {
    return isAttribute(node) || isTag(node);
  }
});

// node_modules/postcss-selector-parser/dist/selectors/index.js
var require_selectors = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  var _types = require_types2();
  Object.keys(_types).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports2 && exports2[key] === _types[key])
      return;
    exports2[key] = _types[key];
  });
  var _constructors = require_constructors();
  Object.keys(_constructors).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports2 && exports2[key] === _constructors[key])
      return;
    exports2[key] = _constructors[key];
  });
  var _guards = require_guards();
  Object.keys(_guards).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports2 && exports2[key] === _guards[key])
      return;
    exports2[key] = _guards[key];
  });
});

// node_modules/postcss-selector-parser/dist/index.js
var require_dist = __commonJS((exports2, module2) => {
  "use strict";
  exports2.__esModule = true;
  exports2["default"] = void 0;
  var _processor = _interopRequireDefault(require_processor2());
  var selectors = _interopRequireWildcard(require_selectors());
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap();
    _getRequireWildcardCache = function _getRequireWildcardCache2() {
      return cache;
    };
    return cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {default: obj};
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var parser = function parser2(processor) {
    return new _processor["default"](processor);
  };
  Object.assign(parser, selectors);
  delete parser.__esModule;
  var _default = parser;
  exports2["default"] = _default;
  module2.exports = exports2.default;
});

// node_modules/merge-source-map/index.js
var require_merge_source_map = __commonJS((exports2, module2) => {
  var sourceMap = require_source_map();
  var SourceMapConsumer = sourceMap.SourceMapConsumer;
  var SourceMapGenerator = sourceMap.SourceMapGenerator;
  module2.exports = merge;
  function merge(oldMap, newMap) {
    if (!oldMap)
      return newMap;
    if (!newMap)
      return oldMap;
    var oldMapConsumer = new SourceMapConsumer(oldMap);
    var newMapConsumer = new SourceMapConsumer(newMap);
    var mergedMapGenerator = new SourceMapGenerator();
    newMapConsumer.eachMapping(function(m) {
      if (m.originalLine == null)
        return;
      var origPosInOldMap = oldMapConsumer.originalPositionFor({
        line: m.originalLine,
        column: m.originalColumn
      });
      if (origPosInOldMap.source == null)
        return;
      mergedMapGenerator.addMapping({
        original: {
          line: origPosInOldMap.line,
          column: origPosInOldMap.column
        },
        generated: {
          line: m.generatedLine,
          column: m.generatedColumn
        },
        source: origPosInOldMap.source,
        name: origPosInOldMap.name
      });
    });
    var consumers = [oldMapConsumer, newMapConsumer];
    consumers.forEach(function(consumer) {
      consumer.sources.forEach(function(sourceFile) {
        mergedMapGenerator._sources.add(sourceFile);
        var sourceContent = consumer.sourceContentFor(sourceFile);
        if (sourceContent != null) {
          mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
        }
      });
    });
    mergedMapGenerator._sourceRoot = oldMap.sourceRoot;
    mergedMapGenerator._file = oldMap.file;
    return JSON.parse(mergedMapGenerator.toString());
  }
});

// node_modules/magic-string/dist/magic-string.es.js
var require_magic_string_es = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    Bundle: () => Bundle,
    SourceMap: () => SourceMap,
    default: () => magic_string_es_default
  });
  var BitSet = function BitSet2(arg) {
    this.bits = arg instanceof BitSet2 ? arg.bits.slice() : [];
  };
  BitSet.prototype.add = function add2(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  };
  BitSet.prototype.has = function has2(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  };
  var Chunk = function Chunk2(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    Object.defineProperties(this, {
      previous: {writable: true, value: null},
      next: {writable: true, value: null}
    });
  };
  Chunk.prototype.appendLeft = function appendLeft(content) {
    this.outro += content;
  };
  Chunk.prototype.appendRight = function appendRight(content) {
    this.intro = this.intro + content;
  };
  Chunk.prototype.clone = function clone() {
    var chunk = new Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  };
  Chunk.prototype.contains = function contains(index) {
    return this.start < index && index < this.end;
  };
  Chunk.prototype.eachNext = function eachNext(fn) {
    var chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  };
  Chunk.prototype.eachPrevious = function eachPrevious(fn) {
    var chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  };
  Chunk.prototype.edit = function edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  };
  Chunk.prototype.prependLeft = function prependLeft(content) {
    this.outro = content + this.outro;
  };
  Chunk.prototype.prependRight = function prependRight(content) {
    this.intro = content + this.intro;
  };
  Chunk.prototype.split = function split(index) {
    var sliceIndex = index - this.start;
    var originalBefore = this.original.slice(0, sliceIndex);
    var originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    var newChunk = new Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next) {
      newChunk.next.previous = newChunk;
    }
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  };
  Chunk.prototype.toString = function toString2() {
    return this.intro + this.content + this.outro;
  };
  Chunk.prototype.trimEnd = function trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) {
      return true;
    }
    var trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
    }
  };
  Chunk.prototype.trimStart = function trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) {
      return true;
    }
    var trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.end - trimmed.length);
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
    }
  };
  var btoa = function() {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    btoa = function(str) {
      return window.btoa(unescape(encodeURIComponent(str)));
    };
  } else if (typeof Buffer === "function") {
    btoa = function(str) {
      return Buffer.from(str, "utf-8").toString("base64");
    };
  }
  var SourceMap = function SourceMap2(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode(properties.mappings);
  };
  SourceMap.prototype.toString = function toString2() {
    return JSON.stringify(this);
  };
  SourceMap.prototype.toUrl = function toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
  };
  function guessIndent(code) {
    var lines = code.split("\n");
    var tabbed = lines.filter(function(line) {
      return /^\t+/.test(line);
    });
    var spaced = lines.filter(function(line) {
      return /^ {2,}/.test(line);
    });
    if (tabbed.length === 0 && spaced.length === 0) {
      return null;
    }
    if (tabbed.length >= spaced.length) {
      return "	";
    }
    var min = spaced.reduce(function(previous, current) {
      var numSpaces = /^ +/.exec(current)[0].length;
      return Math.min(numSpaces, previous);
    }, Infinity);
    return new Array(min + 1).join(" ");
  }
  function getRelativePath(from, to) {
    var fromParts = from.split(/[/\\]/);
    var toParts = to.split(/[/\\]/);
    fromParts.pop();
    while (fromParts[0] === toParts[0]) {
      fromParts.shift();
      toParts.shift();
    }
    if (fromParts.length) {
      var i = fromParts.length;
      while (i--) {
        fromParts[i] = "..";
      }
    }
    return fromParts.concat(toParts).join("/");
  }
  var toString = Object.prototype.toString;
  function isObject2(thing) {
    return toString.call(thing) === "[object Object]";
  }
  function getLocator(source) {
    var originalLines = source.split("\n");
    var lineOffsets = [];
    for (var i = 0, pos = 0; i < originalLines.length; i++) {
      lineOffsets.push(pos);
      pos += originalLines[i].length + 1;
    }
    return function locate(index) {
      var i2 = 0;
      var j = lineOffsets.length;
      while (i2 < j) {
        var m = i2 + j >> 1;
        if (index < lineOffsets[m]) {
          j = m;
        } else {
          i2 = m + 1;
        }
      }
      var line = i2 - 1;
      var column = index - lineOffsets[line];
      return {line, column};
    };
  }
  var Mappings = function Mappings2(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  };
  Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
    }
    this.advance(content);
    this.pending = null;
  };
  Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    var originalCharIndex = chunk.start;
    var first = true;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
        this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
      }
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  };
  Mappings.prototype.advance = function advance(str) {
    if (!str) {
      return;
    }
    var lines = str.split("\n");
    if (lines.length > 1) {
      for (var i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  };
  var n = "\n";
  var warned = {
    insertLeft: false,
    insertRight: false,
    storeName: false
  };
  var MagicString = function MagicString2(string, options) {
    if (options === void 0)
      options = {};
    var chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: {writable: true, value: string},
      outro: {writable: true, value: ""},
      intro: {writable: true, value: ""},
      firstChunk: {writable: true, value: chunk},
      lastChunk: {writable: true, value: chunk},
      lastSearchedChunk: {writable: true, value: chunk},
      byStart: {writable: true, value: {}},
      byEnd: {writable: true, value: {}},
      filename: {writable: true, value: options.filename},
      indentExclusionRanges: {writable: true, value: options.indentExclusionRanges},
      sourcemapLocations: {writable: true, value: new BitSet()},
      storedNames: {writable: true, value: {}},
      indentStr: {writable: true, value: guessIndent(string)}
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  };
  MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  };
  MagicString.prototype.append = function append(content) {
    if (typeof content !== "string") {
      throw new TypeError("outro content must be a string");
    }
    this.outro += content;
    return this;
  };
  MagicString.prototype.appendLeft = function appendLeft(index, content) {
    if (typeof content !== "string") {
      throw new TypeError("inserted content must be a string");
    }
    this._split(index);
    var chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  };
  MagicString.prototype.appendRight = function appendRight(index, content) {
    if (typeof content !== "string") {
      throw new TypeError("inserted content must be a string");
    }
    this._split(index);
    var chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  };
  MagicString.prototype.clone = function clone() {
    var cloned = new MagicString(this.original, {filename: this.filename});
    var originalChunk = this.firstChunk;
    var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      var nextOriginalChunk = originalChunk.next;
      var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  };
  MagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {
    var this$1 = this;
    options = options || {};
    var sourceIndex = 0;
    var names = Object.keys(this.storedNames);
    var mappings = new Mappings(options.hires);
    var locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext(function(chunk) {
      var loc = locate(chunk.start);
      if (chunk.intro.length) {
        mappings.advance(chunk.intro);
      }
      if (chunk.edited) {
        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
      }
      if (chunk.outro.length) {
        mappings.advance(chunk.outro);
      }
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : null,
      sources: [options.source ? getRelativePath(options.file || "", options.source) : null],
      sourcesContent: options.includeContent ? [this.original] : [null],
      names,
      mappings: mappings.raw
    };
  };
  MagicString.prototype.generateMap = function generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  };
  MagicString.prototype.getIndentString = function getIndentString() {
    return this.indentStr === null ? "	" : this.indentStr;
  };
  MagicString.prototype.indent = function indent(indentStr, options) {
    var pattern = /^[^\r\n]/gm;
    if (isObject2(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
    if (indentStr === "") {
      return this;
    }
    options = options || {};
    var isExcluded = {};
    if (options.exclude) {
      var exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach(function(exclusion) {
        for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    var shouldIndentNextCharacter = options.indentStart !== false;
    var replacer = function(match) {
      if (shouldIndentNextCharacter) {
        return "" + indentStr + match;
      }
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    var charIndex = 0;
    var chunk = this.firstChunk;
    while (chunk) {
      var end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            var char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  };
  MagicString.prototype.insert = function insert() {
    throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
  };
  MagicString.prototype.insertLeft = function insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  };
  MagicString.prototype.insertRight = function insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  };
  MagicString.prototype.move = function move(start, end, index) {
    if (index >= start && index <= end) {
      throw new Error("Cannot move a selection inside itself");
    }
    this._split(start);
    this._split(end);
    this._split(index);
    var first = this.byStart[start];
    var last = this.byEnd[end];
    var oldLeft = first.previous;
    var oldRight = last.next;
    var newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk) {
      return this;
    }
    var newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft) {
      oldLeft.next = oldRight;
    }
    if (oldRight) {
      oldRight.previous = oldLeft;
    }
    if (newLeft) {
      newLeft.next = first;
    }
    if (newRight) {
      newRight.previous = last;
    }
    if (!first.previous) {
      this.firstChunk = last.next;
    }
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft) {
      this.firstChunk = first;
    }
    if (!newRight) {
      this.lastChunk = last;
    }
    return this;
  };
  MagicString.prototype.overwrite = function overwrite(start, end, content, options) {
    if (typeof content !== "string") {
      throw new TypeError("replacement content must be a string");
    }
    while (start < 0) {
      start += this.original.length;
    }
    while (end < 0) {
      end += this.original.length;
    }
    if (end > this.original.length) {
      throw new Error("end is out of bounds");
    }
    if (start === end) {
      throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
    }
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
        warned.storeName = true;
      }
      options = {storeName: true};
    }
    var storeName = options !== void 0 ? options.storeName : false;
    var contentOnly = options !== void 0 ? options.contentOnly : false;
    if (storeName) {
      var original = this.original.slice(start, end);
      this.storedNames[original] = true;
    }
    var first = this.byStart[start];
    var last = this.byEnd[end];
    if (first) {
      if (end > first.end && first.next !== this.byStart[first.end]) {
        throw new Error("Cannot overwrite across a split point");
      }
      first.edit(content, storeName, contentOnly);
      if (first !== last) {
        var chunk = first.next;
        while (chunk !== last) {
          chunk.edit("", false);
          chunk = chunk.next;
        }
        chunk.edit("", false);
      }
    } else {
      var newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  };
  MagicString.prototype.prepend = function prepend(content) {
    if (typeof content !== "string") {
      throw new TypeError("outro content must be a string");
    }
    this.intro = content + this.intro;
    return this;
  };
  MagicString.prototype.prependLeft = function prependLeft(index, content) {
    if (typeof content !== "string") {
      throw new TypeError("inserted content must be a string");
    }
    this._split(index);
    var chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  };
  MagicString.prototype.prependRight = function prependRight(index, content) {
    if (typeof content !== "string") {
      throw new TypeError("inserted content must be a string");
    }
    this._split(index);
    var chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  };
  MagicString.prototype.remove = function remove(start, end) {
    while (start < 0) {
      start += this.original.length;
    }
    while (end < 0) {
      end += this.original.length;
    }
    if (start === end) {
      return this;
    }
    if (start < 0 || end > this.original.length) {
      throw new Error("Character is out of bounds");
    }
    if (start > end) {
      throw new Error("end must be greater than start");
    }
    this._split(start);
    this._split(end);
    var chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  };
  MagicString.prototype.lastChar = function lastChar() {
    if (this.outro.length) {
      return this.outro[this.outro.length - 1];
    }
    var chunk = this.lastChunk;
    do {
      if (chunk.outro.length) {
        return chunk.outro[chunk.outro.length - 1];
      }
      if (chunk.content.length) {
        return chunk.content[chunk.content.length - 1];
      }
      if (chunk.intro.length) {
        return chunk.intro[chunk.intro.length - 1];
      }
    } while (chunk = chunk.previous);
    if (this.intro.length) {
      return this.intro[this.intro.length - 1];
    }
    return "";
  };
  MagicString.prototype.lastLine = function lastLine() {
    var lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1) {
      return this.outro.substr(lineIndex + 1);
    }
    var lineStr = this.outro;
    var chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1) {
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        }
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1) {
          return chunk.content.substr(lineIndex + 1) + lineStr;
        }
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1) {
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        }
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1) {
      return this.intro.substr(lineIndex + 1) + lineStr;
    }
    return this.intro + lineStr;
  };
  MagicString.prototype.slice = function slice(start, end) {
    if (start === void 0)
      start = 0;
    if (end === void 0)
      end = this.original.length;
    while (start < 0) {
      start += this.original.length;
    }
    while (end < 0) {
      end += this.original.length;
    }
    var result = "";
    var chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start) {
      throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
    }
    var startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      var containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end) {
        throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
      }
      var sliceStart = startChunk === chunk ? start - chunk.start : 0;
      var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  };
  MagicString.prototype.snip = function snip(start, end) {
    var clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  };
  MagicString.prototype._split = function _split(index) {
    if (this.byStart[index] || this.byEnd[index]) {
      return;
    }
    var chunk = this.lastSearchedChunk;
    var searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index)) {
        return this._splitChunk(chunk, index);
      }
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  };
  MagicString.prototype._splitChunk = function _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      var loc = getLocator(this.original)(index);
      throw new Error("Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' \u2013 "' + chunk.original + '")');
    }
    var newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk) {
      this.lastChunk = newChunk;
    }
    this.lastSearchedChunk = chunk;
    return true;
  };
  MagicString.prototype.toString = function toString2() {
    var str = this.intro;
    var chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  };
  MagicString.prototype.isEmpty = function isEmpty() {
    var chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {
        return false;
      }
    } while (chunk = chunk.next);
    return true;
  };
  MagicString.prototype.length = function length() {
    var chunk = this.firstChunk;
    var length2 = 0;
    do {
      length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length2;
  };
  MagicString.prototype.trimLines = function trimLines() {
    return this.trim("[\\r\\n]");
  };
  MagicString.prototype.trim = function trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  };
  MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {
    var rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) {
      return true;
    }
    var chunk = this.lastChunk;
    do {
      var end = chunk.end;
      var aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) {
        return true;
      }
      chunk = chunk.previous;
    } while (chunk);
    return false;
  };
  MagicString.prototype.trimEnd = function trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  };
  MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {
    var rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) {
      return true;
    }
    var chunk = this.firstChunk;
    do {
      var end = chunk.end;
      var aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) {
        return true;
      }
      chunk = chunk.next;
    } while (chunk);
    return false;
  };
  MagicString.prototype.trimStart = function trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  };
  var hasOwnProp = Object.prototype.hasOwnProperty;
  var Bundle = function Bundle2(options) {
    if (options === void 0)
      options = {};
    this.intro = options.intro || "";
    this.separator = options.separator !== void 0 ? options.separator : "\n";
    this.sources = [];
    this.uniqueSources = [];
    this.uniqueSourceIndexByFilename = {};
  };
  Bundle.prototype.addSource = function addSource(source) {
    if (source instanceof MagicString) {
      return this.addSource({
        content: source,
        filename: source.filename,
        separator: this.separator
      });
    }
    if (!isObject2(source) || !source.content) {
      throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");
    }
    ["filename", "indentExclusionRanges", "separator"].forEach(function(option) {
      if (!hasOwnProp.call(source, option)) {
        source[option] = source.content[option];
      }
    });
    if (source.separator === void 0) {
      source.separator = this.separator;
    }
    if (source.filename) {
      if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
        this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
        this.uniqueSources.push({filename: source.filename, content: source.content.original});
      } else {
        var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
        if (source.content.original !== uniqueSource.content) {
          throw new Error("Illegal source: same filename (" + source.filename + "), different contents");
        }
      }
    }
    this.sources.push(source);
    return this;
  };
  Bundle.prototype.append = function append(str, options) {
    this.addSource({
      content: new MagicString(str),
      separator: options && options.separator || ""
    });
    return this;
  };
  Bundle.prototype.clone = function clone() {
    var bundle = new Bundle({
      intro: this.intro,
      separator: this.separator
    });
    this.sources.forEach(function(source) {
      bundle.addSource({
        filename: source.filename,
        content: source.content.clone(),
        separator: source.separator
      });
    });
    return bundle;
  };
  Bundle.prototype.generateDecodedMap = function generateDecodedMap(options) {
    var this$1 = this;
    if (options === void 0)
      options = {};
    var names = [];
    this.sources.forEach(function(source) {
      Object.keys(source.content.storedNames).forEach(function(name) {
        if (!~names.indexOf(name)) {
          names.push(name);
        }
      });
    });
    var mappings = new Mappings(options.hires);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.sources.forEach(function(source, i) {
      if (i > 0) {
        mappings.advance(this$1.separator);
      }
      var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[source.filename] : -1;
      var magicString = source.content;
      var locate = getLocator(magicString.original);
      if (magicString.intro) {
        mappings.advance(magicString.intro);
      }
      magicString.firstChunk.eachNext(function(chunk) {
        var loc = locate(chunk.start);
        if (chunk.intro.length) {
          mappings.advance(chunk.intro);
        }
        if (source.filename) {
          if (chunk.edited) {
            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
          } else {
            mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);
          }
        } else {
          mappings.advance(chunk.content);
        }
        if (chunk.outro.length) {
          mappings.advance(chunk.outro);
        }
      });
      if (magicString.outro) {
        mappings.advance(magicString.outro);
      }
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : null,
      sources: this.uniqueSources.map(function(source) {
        return options.file ? getRelativePath(options.file, source.filename) : source.filename;
      }),
      sourcesContent: this.uniqueSources.map(function(source) {
        return options.includeContent ? source.content : null;
      }),
      names,
      mappings: mappings.raw
    };
  };
  Bundle.prototype.generateMap = function generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  };
  Bundle.prototype.getIndentString = function getIndentString() {
    var indentStringCounts = {};
    this.sources.forEach(function(source) {
      var indentStr = source.content.indentStr;
      if (indentStr === null) {
        return;
      }
      if (!indentStringCounts[indentStr]) {
        indentStringCounts[indentStr] = 0;
      }
      indentStringCounts[indentStr] += 1;
    });
    return Object.keys(indentStringCounts).sort(function(a, b) {
      return indentStringCounts[a] - indentStringCounts[b];
    })[0] || "	";
  };
  Bundle.prototype.indent = function indent(indentStr) {
    var this$1 = this;
    if (!arguments.length) {
      indentStr = this.getIndentString();
    }
    if (indentStr === "") {
      return this;
    }
    var trailingNewline = !this.intro || this.intro.slice(-1) === "\n";
    this.sources.forEach(function(source, i) {
      var separator = source.separator !== void 0 ? source.separator : this$1.separator;
      var indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);
      source.content.indent(indentStr, {
        exclude: source.indentExclusionRanges,
        indentStart
      });
      trailingNewline = source.content.lastChar() === "\n";
    });
    if (this.intro) {
      this.intro = indentStr + this.intro.replace(/^[^\n]/gm, function(match, index) {
        return index > 0 ? indentStr + match : match;
      });
    }
    return this;
  };
  Bundle.prototype.prepend = function prepend(str) {
    this.intro = str + this.intro;
    return this;
  };
  Bundle.prototype.toString = function toString2() {
    var this$1 = this;
    var body = this.sources.map(function(source, i) {
      var separator = source.separator !== void 0 ? source.separator : this$1.separator;
      var str = (i > 0 ? separator : "") + source.content.toString();
      return str;
    }).join("");
    return this.intro + body;
  };
  Bundle.prototype.isEmpty = function isEmpty() {
    if (this.intro.length && this.intro.trim()) {
      return false;
    }
    if (this.sources.some(function(source) {
      return !source.content.isEmpty();
    })) {
      return false;
    }
    return true;
  };
  Bundle.prototype.length = function length() {
    return this.sources.reduce(function(length2, source) {
      return length2 + source.content.length();
    }, this.intro.length);
  };
  Bundle.prototype.trimLines = function trimLines() {
    return this.trim("[\\r\\n]");
  };
  Bundle.prototype.trim = function trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  };
  Bundle.prototype.trimStart = function trimStart(charType) {
    var rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (!this.intro) {
      var source;
      var i = 0;
      do {
        source = this.sources[i++];
        if (!source) {
          break;
        }
      } while (!source.content.trimStartAborted(charType));
    }
    return this;
  };
  Bundle.prototype.trimEnd = function trimEnd(charType) {
    var rx = new RegExp((charType || "\\s") + "+$");
    var source;
    var i = this.sources.length - 1;
    do {
      source = this.sources[i--];
      if (!source) {
        this.intro = this.intro.replace(rx, "");
        break;
      }
    } while (!source.content.trimEndAborted(charType));
    return this;
  };
  var magic_string_es_default = MagicString;
});

// node_modules/@vue/compiler-sfc/node_modules/@babel/parser/lib/index.js
var require_lib = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var beforeExpr = true;
  var startsExpr = true;
  var isLoop = true;
  var isAssign = true;
  var prefix = true;
  var postfix = true;
  var TokenType = class {
    constructor(label, conf = {}) {
      this.label = void 0;
      this.keyword = void 0;
      this.beforeExpr = void 0;
      this.startsExpr = void 0;
      this.rightAssociative = void 0;
      this.isLoop = void 0;
      this.isAssign = void 0;
      this.prefix = void 0;
      this.postfix = void 0;
      this.binop = void 0;
      this.updateContext = void 0;
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop != null ? conf.binop : null;
      this.updateContext = null;
    }
  };
  var keywords$1 = new Map();
  function createKeyword(name, options = {}) {
    options.keyword = name;
    const token = new TokenType(name, options);
    keywords$1.set(name, token);
    return token;
  }
  function createBinop(name, binop) {
    return new TokenType(name, {
      beforeExpr,
      binop
    });
  }
  var types$1 = {
    num: new TokenType("num", {
      startsExpr
    }),
    bigint: new TokenType("bigint", {
      startsExpr
    }),
    decimal: new TokenType("decimal", {
      startsExpr
    }),
    regexp: new TokenType("regexp", {
      startsExpr
    }),
    string: new TokenType("string", {
      startsExpr
    }),
    name: new TokenType("name", {
      startsExpr
    }),
    privateName: new TokenType("#name", {
      startsExpr
    }),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr,
      startsExpr
    }),
    bracketHashL: new TokenType("#[", {
      beforeExpr,
      startsExpr
    }),
    bracketBarL: new TokenType("[|", {
      beforeExpr,
      startsExpr
    }),
    bracketR: new TokenType("]"),
    bracketBarR: new TokenType("|]"),
    braceL: new TokenType("{", {
      beforeExpr,
      startsExpr
    }),
    braceBarL: new TokenType("{|", {
      beforeExpr,
      startsExpr
    }),
    braceHashL: new TokenType("#{", {
      beforeExpr,
      startsExpr
    }),
    braceR: new TokenType("}", {
      beforeExpr
    }),
    braceBarR: new TokenType("|}"),
    parenL: new TokenType("(", {
      beforeExpr,
      startsExpr
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", {
      beforeExpr
    }),
    semi: new TokenType(";", {
      beforeExpr
    }),
    colon: new TokenType(":", {
      beforeExpr
    }),
    doubleColon: new TokenType("::", {
      beforeExpr
    }),
    dot: new TokenType("."),
    question: new TokenType("?", {
      beforeExpr
    }),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", {
      beforeExpr
    }),
    template: new TokenType("template"),
    ellipsis: new TokenType("...", {
      beforeExpr
    }),
    backQuote: new TokenType("`", {
      startsExpr
    }),
    dollarBraceL: new TokenType("${", {
      beforeExpr,
      startsExpr
    }),
    at: new TokenType("@"),
    hash: new TokenType("#", {
      startsExpr
    }),
    interpreterDirective: new TokenType("#!..."),
    eq: new TokenType("=", {
      beforeExpr,
      isAssign
    }),
    assign: new TokenType("_=", {
      beforeExpr,
      isAssign
    }),
    slashAssign: new TokenType("_=", {
      beforeExpr,
      isAssign
    }),
    moduloAssign: new TokenType("_=", {
      beforeExpr,
      isAssign
    }),
    incDec: new TokenType("++/--", {
      prefix,
      postfix,
      startsExpr
    }),
    bang: new TokenType("!", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    tilde: new TokenType("~", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr,
      binop: 9,
      prefix,
      startsExpr
    }),
    modulo: new TokenType("%", {
      binop: 10,
      startsExpr
    }),
    star: new TokenType("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: new TokenType("**", {
      beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr
    }),
    _do: createKeyword("do", {
      isLoop,
      beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr
    }),
    _finally: createKeyword("finally"),
    _for: createKeyword("for", {
      isLoop
    }),
    _function: createKeyword("function", {
      startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _while: createKeyword("while", {
      isLoop
    }),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr,
      startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr
    }),
    _in: createKeyword("in", {
      beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr,
      binop: 7
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr,
      prefix,
      startsExpr
    })
  };
  var lineBreak = /\r\n?|[\n\u2028\u2029]/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    switch (code) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
  var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function isWhitespace(code) {
    switch (code) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  var Position8 = class {
    constructor(line, col) {
      this.line = void 0;
      this.column = void 0;
      this.line = line;
      this.column = col;
    }
  };
  var SourceLocation = class {
    constructor(start, end) {
      this.start = void 0;
      this.end = void 0;
      this.filename = void 0;
      this.identifierName = void 0;
      this.start = start;
      this.end = end;
    }
  };
  function getLineInfo(input, offset) {
    let line = 1;
    let lineStart = 0;
    let match;
    lineBreakG.lastIndex = 0;
    while ((match = lineBreakG.exec(input)) && match.index < offset) {
      line++;
      lineStart = lineBreakG.lastIndex;
    }
    return new Position8(line, offset - lineStart);
  }
  var BaseParser = class {
    constructor() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(name) {
      return this.plugins.has(name);
    }
    getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin))
        return this.plugins.get(plugin)[name];
    }
  };
  function setTrailingComments(node, comments) {
    if (node.trailingComments === void 0) {
      node.trailingComments = comments;
    } else {
      node.trailingComments.unshift(...comments);
    }
  }
  function setInnerComments(node, comments) {
    if (node.innerComments === void 0) {
      node.innerComments = comments;
    } else if (comments !== void 0) {
      node.innerComments.unshift(...comments);
    }
  }
  function adjustInnerComments(node, elements, commentWS) {
    let lastElement = null;
    let i = elements.length;
    while (lastElement === null && i > 0) {
      lastElement = elements[--i];
    }
    if (lastElement === null || lastElement.start > commentWS.start) {
      setInnerComments(node, commentWS.comments);
    } else {
      setTrailingComments(lastElement, commentWS.comments);
    }
  }
  var CommentsParser = class extends BaseParser {
    addComment(comment) {
      if (this.filename)
        comment.loc.filename = this.filename;
      this.state.comments.push(comment);
    }
    processComment(node) {
      const {
        commentStack
      } = this.state;
      const commentStackLength = commentStack.length;
      if (commentStackLength === 0)
        return;
      let i = commentStackLength - 1;
      const lastCommentWS = commentStack[i];
      if (lastCommentWS.start === node.end) {
        lastCommentWS.leadingNode = node;
        i--;
      }
      const {
        start: nodeStart
      } = node;
      for (; i >= 0; i--) {
        const commentWS = commentStack[i];
        const commentEnd = commentWS.end;
        if (commentEnd > nodeStart) {
          commentWS.containingNode = node;
          this.finalizeComment(commentWS);
          commentStack.splice(i, 1);
        } else {
          if (commentEnd === nodeStart) {
            commentWS.trailingNode = node;
          }
          break;
        }
      }
    }
    finalizeComment(commentWS) {
      const {
        comments
      } = commentWS;
      if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
        if (commentWS.leadingNode !== null) {
          setTrailingComments(commentWS.leadingNode, comments);
        }
        if (commentWS.trailingNode !== null) {
          commentWS.trailingNode.leadingComments = comments;
        }
      } else {
        const {
          containingNode: node,
          start: commentStart
        } = commentWS;
        if (this.input.charCodeAt(commentStart - 1) === 44) {
          switch (node.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              adjustInnerComments(node, node.properties, commentWS);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              adjustInnerComments(node, node.arguments, commentWS);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              adjustInnerComments(node, node.params, commentWS);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              adjustInnerComments(node, node.elements, commentWS);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              adjustInnerComments(node, node.specifiers, commentWS);
              break;
            default: {
              setInnerComments(node, comments);
            }
          }
        } else {
          setInnerComments(node, comments);
        }
      }
    }
    finalizeRemainingComments() {
      const {
        commentStack
      } = this.state;
      for (let i = commentStack.length - 1; i >= 0; i--) {
        this.finalizeComment(commentStack[i]);
      }
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(node) {
      const {
        commentStack
      } = this.state;
      const {
        length
      } = commentStack;
      if (length === 0)
        return;
      const commentWS = commentStack[length - 1];
      if (commentWS.leadingNode === node) {
        commentWS.leadingNode = null;
      }
    }
  };
  var ErrorCodes = Object.freeze({
    SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
    SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
  });
  var ErrorMessages = makeErrorTemplates({
    AccessorIsGenerator: "A %0ter cannot be a generator.",
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accesor must not have any formal parameters.",
    BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: "'%0' require an initialization value.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: "Unsyntactic %0.",
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: "`import()` requires exactly %0.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: "Expected number in radix %0.",
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
    InvalidIdentifier: "Invalid identifier %0.",
    InvalidLhs: "Invalid left-hand side in %0.",
    InvalidLhsBinding: "Binding invalid left-hand side in %0.",
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: "Unexpected character '%0'.",
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: "Label '%0' is already declared.",
    LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
    ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
    ModuleExportUndefined: "Export '%0' is not defined.",
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
    PrivateNameRedeclaration: "Duplicate private name #%0.",
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    StaticPrototype: "Classes may not have static property named prototype.",
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: "Assigning to '%0' in strict mode.",
    StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: "Unexpected keyword '%0'.",
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
    UnexpectedReservedWord: "Unexpected reserved word '%0'.",
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: "Unexpected token '%0'.",
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    VarRedeclaration: "Identifier '%0' has already been declared.",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, ErrorCodes.SyntaxError);
  var SourceTypeModuleErrorMessages = makeErrorTemplates({
    ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
    ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`
  }, ErrorCodes.SourceTypeModuleError);
  function makeErrorTemplates(messages, code) {
    const templates = {};
    Object.keys(messages).forEach((reasonCode) => {
      templates[reasonCode] = Object.freeze({
        code,
        reasonCode,
        template: messages[reasonCode]
      });
    });
    return Object.freeze(templates);
  }
  var ParserError = class extends CommentsParser {
    getLocationForPosition(pos) {
      let loc;
      if (pos === this.state.start)
        loc = this.state.startLoc;
      else if (pos === this.state.lastTokStart)
        loc = this.state.lastTokStartLoc;
      else if (pos === this.state.end)
        loc = this.state.endLoc;
      else if (pos === this.state.lastTokEnd)
        loc = this.state.lastTokEndLoc;
      else
        loc = getLineInfo(this.input, pos);
      return loc;
    }
    raise(pos, {
      code,
      reasonCode,
      template
    }, ...params) {
      return this.raiseWithData(pos, {
        code,
        reasonCode
      }, template, ...params);
    }
    raiseOverwrite(pos, {
      code,
      template
    }, ...params) {
      const loc = this.getLocationForPosition(pos);
      const message = template.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
      if (this.options.errorRecovery) {
        const errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];
          if (error.pos === pos) {
            return Object.assign(error, {
              message
            });
          } else if (error.pos < pos) {
            break;
          }
        }
      }
      return this._raise({
        code,
        loc,
        pos
      }, message);
    }
    raiseWithData(pos, data, errorTemplate, ...params) {
      const loc = this.getLocationForPosition(pos);
      const message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
      return this._raise(Object.assign({
        loc,
        pos
      }, data), message);
    }
    _raise(errorContext, message) {
      const err = new SyntaxError(message);
      Object.assign(err, errorContext);
      if (this.options.errorRecovery) {
        if (!this.isLookahead)
          this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    }
  };
  var estree = (superClass) => class extends superClass {
    parseRegExpLiteral({
      pattern,
      flags
    }) {
      let regex = null;
      try {
        regex = new RegExp(pattern, flags);
      } catch (e) {
      }
      const node = this.estreeParseLiteral(regex);
      node.regex = {
        pattern,
        flags
      };
      return node;
    }
    parseBigIntLiteral(value) {
      let bigInt;
      try {
        bigInt = BigInt(value);
      } catch (_unused) {
        bigInt = null;
      }
      const node = this.estreeParseLiteral(bigInt);
      node.bigint = String(node.value || value);
      return node;
    }
    parseDecimalLiteral(value) {
      const decimal = null;
      const node = this.estreeParseLiteral(decimal);
      node.decimal = String(node.value || value);
      return node;
    }
    estreeParseLiteral(value) {
      return this.parseLiteral(value, "Literal");
    }
    parseStringLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNumericLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(value) {
      return this.estreeParseLiteral(value);
    }
    directiveToStmt(directive) {
      const directiveLiteral = directive.value;
      const stmt = this.startNodeAt(directive.start, directive.loc.start);
      const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
      expression.value = directiveLiteral.extra.expressionValue;
      expression.raw = directiveLiteral.extra.raw;
      stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
      return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
    }
    initFunction(node, isAsync) {
      super.initFunction(node, isAsync);
      node.expression = false;
    }
    checkDeclaration(node) {
      if (node != null && this.isObjectProperty(node)) {
        this.checkDeclaration(node.value);
      } else {
        super.checkDeclaration(node);
      }
    }
    getObjectOrClassMethodParams(method) {
      return method.value.params;
    }
    isValidDirective(stmt) {
      var _stmt$expression$extr;
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
    }
    stmtToDirective(stmt) {
      const value = stmt.expression.value;
      const directive = super.stmtToDirective(stmt);
      this.addExtra(directive.value, "expressionValue", value);
      return directive;
    }
    parseBlockBody(node, ...args) {
      super.parseBlockBody(node, ...args);
      const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
      node.body = directiveStatements.concat(node.body);
      delete node.directives;
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
      if (method.typeParameters) {
        method.value.typeParameters = method.typeParameters;
        delete method.typeParameters;
      }
      classBody.body.push(method);
    }
    parseMaybePrivateName(...args) {
      const node = super.parseMaybePrivateName(...args);
      if (node.type === "PrivateName" && this.getPluginOption("estree", "classFeatures")) {
        return this.convertPrivateNameToPrivateIdentifier(node);
      }
      return node;
    }
    convertPrivateNameToPrivateIdentifier(node) {
      const name = super.getPrivateNameSV(node);
      node = node;
      delete node.id;
      node.name = name;
      node.type = "PrivateIdentifier";
      return node;
    }
    isPrivateName(node) {
      if (!this.getPluginOption("estree", "classFeatures")) {
        return super.isPrivateName(node);
      }
      return node.type === "PrivateIdentifier";
    }
    getPrivateNameSV(node) {
      if (!this.getPluginOption("estree", "classFeatures")) {
        return super.getPrivateNameSV(node);
      }
      return node.name;
    }
    parseLiteral(value, type) {
      const node = super.parseLiteral(value, type);
      node.raw = node.extra.raw;
      delete node.extra;
      return node;
    }
    parseFunctionBody(node, allowExpression, isMethod = false) {
      super.parseFunctionBody(node, allowExpression, isMethod);
      node.expression = node.body.type !== "BlockStatement";
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      let funcNode = this.startNode();
      funcNode.kind = node.kind;
      funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
      funcNode.type = "FunctionExpression";
      delete funcNode.kind;
      node.value = funcNode;
      if (type === "ClassPrivateMethod") {
        node.computed = false;
      }
      type = "MethodDefinition";
      return this.finishNode(node, type);
    }
    parseClassProperty(...args) {
      const propertyNode = super.parseClassProperty(...args);
      if (this.getPluginOption("estree", "classFeatures")) {
        propertyNode.type = "PropertyDefinition";
      }
      return propertyNode;
    }
    parseClassPrivateProperty(...args) {
      const propertyNode = super.parseClassPrivateProperty(...args);
      if (this.getPluginOption("estree", "classFeatures")) {
        propertyNode.type = "PropertyDefinition";
        propertyNode.computed = false;
      }
      return propertyNode;
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
      if (node) {
        node.type = "Property";
        if (node.kind === "method")
          node.kind = "init";
        node.shorthand = false;
      }
      return node;
    }
    parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      if (node) {
        node.kind = "init";
        node.type = "Property";
      }
      return node;
    }
    isAssignable(node, isBinding) {
      if (node != null && this.isObjectProperty(node)) {
        return this.isAssignable(node.value, isBinding);
      }
      return super.isAssignable(node, isBinding);
    }
    toAssignable(node, isLHS = false) {
      if (node != null && this.isObjectProperty(node)) {
        this.toAssignable(node.value, isLHS);
        return node;
      }
      return super.toAssignable(node, isLHS);
    }
    toAssignableObjectExpressionProp(prop, ...args) {
      if (prop.kind === "get" || prop.kind === "set") {
        this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
      } else if (prop.method) {
        this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
      } else {
        super.toAssignableObjectExpressionProp(prop, ...args);
      }
    }
    finishCallExpression(node, optional) {
      super.finishCallExpression(node, optional);
      if (node.callee.type === "Import") {
        node.type = "ImportExpression";
        node.source = node.arguments[0];
        if (this.hasPlugin("importAssertions")) {
          var _node$arguments$;
          node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
        }
        delete node.arguments;
        delete node.callee;
      }
      return node;
    }
    toReferencedArguments(node) {
      if (node.type === "ImportExpression") {
        return;
      }
      super.toReferencedArguments(node);
    }
    parseExport(node) {
      super.parseExport(node);
      switch (node.type) {
        case "ExportAllDeclaration":
          node.exported = null;
          break;
        case "ExportNamedDeclaration":
          if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
            node.type = "ExportAllDeclaration";
            node.exported = node.specifiers[0].exported;
            delete node.specifiers;
          }
          break;
      }
      return node;
    }
    parseSubscript(base, startPos, startLoc, noCalls, state) {
      const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);
      if (state.optionalChainMember) {
        if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
          node.type = node.type.substring(8);
        }
        if (state.stop) {
          const chain = this.startNodeAtNode(node);
          chain.expression = node;
          return this.finishNode(chain, "ChainExpression");
        }
      } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
        node.optional = false;
      }
      return node;
    }
    hasPropertyAsPrivateName(node) {
      if (node.type === "ChainExpression") {
        node = node.expression;
      }
      return super.hasPropertyAsPrivateName(node);
    }
    isOptionalChain(node) {
      return node.type === "ChainExpression";
    }
    isObjectProperty(node) {
      return node.type === "Property" && node.kind === "init" && !node.method;
    }
    isObjectMethod(node) {
      return node.method || node.kind === "get" || node.kind === "set";
    }
  };
  var TokContext = class {
    constructor(token, preserveSpace) {
      this.token = void 0;
      this.preserveSpace = void 0;
      this.token = token;
      this.preserveSpace = !!preserveSpace;
    }
  };
  var types = {
    brace: new TokContext("{"),
    template: new TokContext("`", true)
  };
  types$1.braceR.updateContext = (context) => {
    context.pop();
  };
  types$1.braceL.updateContext = types$1.braceHashL.updateContext = types$1.dollarBraceL.updateContext = (context) => {
    context.push(types.brace);
  };
  types$1.backQuote.updateContext = (context) => {
    if (context[context.length - 1] === types.template) {
      context.pop();
    } else {
      context.push(types.template);
    }
  };
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code, set2) {
    let pos = 65536;
    for (let i = 0, length = set2.length; i < length; i += 2) {
      pos += set2[i];
      if (pos > code)
        return false;
      pos += set2[i + 1];
      if (pos >= code)
        return true;
    }
    return false;
  }
  function isIdentifierStart(code) {
    if (code < 65)
      return code === 36;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48)
      return code === 36;
    if (code < 58)
      return true;
    if (code < 65)
      return false;
    if (code <= 90)
      return true;
    if (code < 97)
      return code === 95;
    if (code <= 122)
      return true;
    if (code <= 65535) {
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
  function isIteratorStart(current, next) {
    return current === 64 && next === 64;
  }
  var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
  }
  var SCOPE_OTHER = 0;
  var SCOPE_PROGRAM = 1;
  var SCOPE_FUNCTION = 2;
  var SCOPE_ARROW = 4;
  var SCOPE_SIMPLE_CATCH = 8;
  var SCOPE_SUPER = 16;
  var SCOPE_DIRECT_SUPER = 32;
  var SCOPE_CLASS = 64;
  var SCOPE_STATIC_BLOCK = 128;
  var SCOPE_TS_MODULE = 256;
  var SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
  var BIND_KIND_VALUE = 1;
  var BIND_KIND_TYPE = 2;
  var BIND_SCOPE_VAR = 4;
  var BIND_SCOPE_LEXICAL = 8;
  var BIND_SCOPE_FUNCTION = 16;
  var BIND_FLAGS_NONE = 64;
  var BIND_FLAGS_CLASS = 128;
  var BIND_FLAGS_TS_ENUM = 256;
  var BIND_FLAGS_TS_CONST_ENUM = 512;
  var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
  var BIND_FLAGS_FLOW_DECLARE_FN = 2048;
  var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
  var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
  var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
  var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
  var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
  var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
  var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
  var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
  var BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;
  var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
  var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
  var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
  var BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
  var CLASS_ELEMENT_FLAG_STATIC = 4;
  var CLASS_ELEMENT_KIND_GETTER = 2;
  var CLASS_ELEMENT_KIND_SETTER = 1;
  var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
  var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
  var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
  var CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER;
  var CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER;
  var CLASS_ELEMENT_OTHER = 0;
  var Scope = class {
    constructor(flags) {
      this.var = new Set();
      this.lexical = new Set();
      this.functions = new Set();
      this.flags = flags;
    }
  };
  var ScopeHandler = class {
    constructor(raise, inModule) {
      this.scopeStack = [];
      this.undefinedExports = new Map();
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
      this.inModule = inModule;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const flags = this.currentThisScopeFlags();
      return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
    }
    get inStaticBlock() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & SCOPE_STATIC_BLOCK) {
          return true;
        }
        if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
          return false;
        }
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(flags) {
      return new Scope(flags);
    }
    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
    exit() {
      this.scopeStack.pop();
    }
    treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
    }
    declareName(name, bindingType, pos) {
      let scope = this.currentScope();
      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);
        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.add(name);
        } else {
          scope.lexical.add(name);
        }
        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (let i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope.var.add(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR)
            break;
        }
      }
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }
    maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }
    checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, ErrorMessages.VarRedeclaration, name);
      }
    }
    isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE))
        return false;
      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
      }
      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
      }
      return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
    }
    checkLocalExport(id) {
      const {
        name
      } = id;
      const topLevelScope = this.scopeStack[0];
      if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
        this.undefinedExports.set(name, id.start);
      }
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & SCOPE_VAR) {
          return flags;
        }
      }
    }
    currentThisScopeFlags() {
      for (let i = this.scopeStack.length - 1; ; i--) {
        const {
          flags
        } = this.scopeStack[i];
        if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
          return flags;
        }
      }
    }
  };
  var FlowScope = class extends Scope {
    constructor(...args) {
      super(...args);
      this.declareFunctions = new Set();
    }
  };
  var FlowScopeHandler = class extends ScopeHandler {
    createScope(flags) {
      return new FlowScope(flags);
    }
    declareName(name, bindingType, pos) {
      const scope = this.currentScope();
      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);
        this.maybeExportDefined(scope, name);
        scope.declareFunctions.add(name);
        return;
      }
      super.declareName(...arguments);
    }
    isRedeclaredInScope(scope, name, bindingType) {
      if (super.isRedeclaredInScope(...arguments))
        return true;
      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
      }
      return false;
    }
    checkLocalExport(id) {
      if (!this.scopeStack[0].declareFunctions.has(id.name)) {
        super.checkLocalExport(id);
      }
    }
  };
  var State = class {
    constructor() {
      this.strict = void 0;
      this.curLine = void 0;
      this.startLoc = void 0;
      this.endLoc = void 0;
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.maybeInArrowParameters = false;
      this.inType = false;
      this.noAnonFunctionType = false;
      this.inPropertyName = false;
      this.hasFlowComment = false;
      this.isAmbientContext = false;
      this.inAbstractClass = false;
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.soloAwait = false;
      this.inFSharpPipelineDirectBody = false;
      this.labels = [];
      this.decoratorStack = [[]];
      this.comments = [];
      this.commentStack = [];
      this.pos = 0;
      this.lineStart = 0;
      this.type = types$1.eof;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.lastTokStart = 0;
      this.lastTokEnd = 0;
      this.context = [types.brace];
      this.exprAllowed = true;
      this.containsEsc = false;
      this.strictErrors = new Map();
      this.tokensLength = 0;
    }
    init(options) {
      this.strict = options.strictMode === false ? false : options.strictMode === true ? true : options.sourceType === "module";
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    }
    curPosition() {
      return new Position8(this.curLine, this.pos - this.lineStart);
    }
    clone(skipArrays) {
      const state = new State();
      const keys = Object.keys(this);
      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];
        let val = this[key];
        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }
        state[key] = val;
      }
      return state;
    }
  };
  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100]);
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
    hex: [46, 88, 95, 120]
  };
  var allowedNumericSeparatorSiblings = {};
  allowedNumericSeparatorSiblings.bin = [48, 49];
  allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
  allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
  allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
  var Token = class {
    constructor(state) {
      this.type = state.type;
      this.value = state.value;
      this.start = state.start;
      this.end = state.end;
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
  };
  var Tokenizer = class extends ParserError {
    constructor(options, input) {
      super();
      this.isLookahead = void 0;
      this.tokens = [];
      this.state = new State();
      this.state.init(options);
      this.input = input;
      this.length = input.length;
      this.isLookahead = false;
    }
    pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes();
      if (this.options.tokens) {
        this.pushToken(new Token(this.state));
      }
      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }
    eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }
    match(type) {
      return this.state.type === type;
    }
    createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        lastTokEnd: state.end,
        context: [this.curContext()],
        inType: state.inType
      };
    }
    lookahead() {
      const old = this.state;
      this.state = this.createLookaheadState(old);
      this.isLookahead = true;
      this.nextToken();
      this.isLookahead = false;
      const curr = this.state;
      this.state = old;
      return curr;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    codePointAtPos(pos) {
      let cp = this.input.charCodeAt(pos);
      if ((cp & 64512) === 55296 && ++pos < this.input.length) {
        const trail = this.input.charCodeAt(pos);
        if ((trail & 64512) === 56320) {
          cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
      }
      return cp;
    }
    setStrict(strict) {
      this.state.strict = strict;
      if (strict) {
        this.state.strictErrors.forEach((message, pos) => this.raise(pos, message));
        this.state.strictErrors.clear();
      }
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      const curContext = this.curContext();
      if (!curContext.preserveSpace)
        this.skipSpace();
      this.state.start = this.state.pos;
      if (!this.isLookahead)
        this.state.startLoc = this.state.curPosition();
      if (this.state.pos >= this.length) {
        this.finishToken(types$1.eof);
        return;
      }
      if (curContext === types.template) {
        this.readTmplToken();
      } else {
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
    }
    skipBlockComment() {
      let startLoc;
      if (!this.isLookahead)
        startLoc = this.state.curPosition();
      const start = this.state.pos;
      const end = this.input.indexOf("*/", start + 2);
      if (end === -1)
        throw this.raise(start, ErrorMessages.UnterminatedComment);
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start + 2;
      while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
        ++this.state.curLine;
        this.state.lineStart = lineBreakG.lastIndex;
      }
      if (this.isLookahead)
        return;
      const comment = {
        type: "CommentBlock",
        value: this.input.slice(start + 2, end),
        start,
        end: end + 2,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens)
        this.pushToken(comment);
      return comment;
    }
    skipLineComment(startSkip) {
      const start = this.state.pos;
      let startLoc;
      if (!this.isLookahead)
        startLoc = this.state.curPosition();
      let ch = this.input.charCodeAt(this.state.pos += startSkip);
      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }
      if (this.isLookahead)
        return;
      const end = this.state.pos;
      const value = this.input.slice(start + startSkip, end);
      const comment = {
        type: "CommentLine",
        value,
        start,
        end,
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.options.tokens)
        this.pushToken(comment);
      return comment;
    }
    skipSpace() {
      const spaceStart = this.state.pos;
      const comments = [];
      loop:
        while (this.state.pos < this.length) {
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const comment = this.skipBlockComment();
                  if (comment !== void 0) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                  break;
                }
                case 47: {
                  const comment = this.skipLineComment(2);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else if (ch === 45 && !this.inModule) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  const comment = this.skipLineComment(3);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else if (ch === 60 && !this.inModule) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                  const comment = this.skipLineComment(4);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    if (this.options.attachComment)
                      comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else {
                break loop;
              }
          }
        }
      if (comments.length > 0) {
        const end = this.state.pos;
        const CommentWhitespace = {
          start: spaceStart,
          end,
          comments,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(CommentWhitespace);
      }
    }
    finishToken(type, val) {
      this.state.end = this.state.pos;
      const prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) {
        this.state.endLoc = this.state.curPosition();
        this.updateContext(prevType);
      }
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }
      const nextPos = this.state.pos + 1;
      const next = this.codePointAtPos(nextPos);
      if (next >= 48 && next <= 57) {
        throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
      }
      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
          throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
        }
        this.state.pos += 2;
        if (next === 123) {
          this.finishToken(types$1.braceHashL);
        } else {
          this.finishToken(types$1.bracketHashL);
        }
      } else if (isIdentifierStart(next)) {
        ++this.state.pos;
        this.finishToken(types$1.privateName, this.readWord1(next));
      } else if (next === 92) {
        ++this.state.pos;
        this.finishToken(types$1.privateName, this.readWord1());
      } else {
        this.finishOp(types$1.hash, 1);
      }
    }
    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }
      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types$1.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types$1.dot);
      }
    }
    readToken_slash() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(types$1.slashAssign, 2);
      } else {
        this.finishOp(types$1.slash, 1);
      }
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33)
        return false;
      const start = this.state.pos;
      this.state.pos += 1;
      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }
      const value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types$1.interpreterDirective, value);
      return true;
    }
    readToken_mult_modulo(code) {
      let type = code === 42 ? types$1.star : types$1.modulo;
      let width = 1;
      let next = this.input.charCodeAt(this.state.pos + 1);
      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types$1.exponent;
      }
      if (next === 61 && !this.state.inType) {
        width++;
        type = code === 37 ? types$1.moduloAssign : types$1.assign;
      }
      this.finishOp(type, width);
    }
    readToken_pipe_amp(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types$1.assign, 3);
        } else {
          this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        return;
      }
      if (code === 124) {
        if (next === 62) {
          this.finishOp(types$1.pipeline, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
          }
          this.state.pos += 2;
          this.finishToken(types$1.braceBarR);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
          }
          this.state.pos += 2;
          this.finishToken(types$1.bracketBarR);
          return;
        }
      }
      if (next === 61) {
        this.finishOp(types$1.assign, 2);
        return;
      }
      this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    }
    readToken_caret() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(types$1.assign, 2);
      } else {
        this.finishOp(types$1.bitwiseXOR, 1);
      }
    }
    readToken_plus_min(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code) {
        this.finishOp(types$1.incDec, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(types$1.assign, 2);
      } else {
        this.finishOp(types$1.plusMin, 1);
      }
    }
    readToken_lt_gt(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      let size2 = 1;
      if (next === code) {
        size2 = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.state.pos + size2) === 61) {
          this.finishOp(types$1.assign, size2 + 1);
          return;
        }
        this.finishOp(types$1.bitShift, size2);
        return;
      }
      if (next === 61) {
        size2 = 2;
      }
      this.finishOp(types$1.relational, size2);
    }
    readToken_eq_excl(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(types$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types$1.arrow);
        return;
      }
      this.finishOp(code === 61 ? types$1.eq : types$1.bang, 1);
    }
    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      const next2 = this.input.charCodeAt(this.state.pos + 2);
      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(types$1.assign, 3);
        } else {
          this.finishOp(types$1.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types$1.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types$1.question);
      }
    }
    getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos;
          this.finishToken(types$1.parenL);
          return;
        case 41:
          ++this.state.pos;
          this.finishToken(types$1.parenR);
          return;
        case 59:
          ++this.state.pos;
          this.finishToken(types$1.semi);
          return;
        case 44:
          ++this.state.pos;
          this.finishToken(types$1.comma);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
            }
            this.state.pos += 2;
            this.finishToken(types$1.bracketBarL);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.bracketL);
          }
          return;
        case 93:
          ++this.state.pos;
          this.finishToken(types$1.bracketR);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
            }
            this.state.pos += 2;
            this.finishToken(types$1.braceBarL);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.braceL);
          }
          return;
        case 125:
          ++this.state.pos;
          this.finishToken(types$1.braceR);
          return;
        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(types$1.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.colon);
          }
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          ++this.state.pos;
          this.finishToken(types$1.backQuote);
          return;
        case 48: {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(code);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;
        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;
        case 126:
          this.finishOp(types$1.tilde, 1);
          return;
        case 64:
          ++this.state.pos;
          this.finishToken(types$1.at);
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (isIdentifierStart(code)) {
            this.readWord(code);
            return;
          }
      }
      throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
    }
    finishOp(type, size2) {
      const str = this.input.slice(this.state.pos, this.state.pos + size2);
      this.state.pos += size2;
      this.finishToken(type, str);
    }
    readRegexp() {
      const start = this.state.start + 1;
      let escaped, inClass;
      let {
        pos
      } = this.state;
      for (; ; ++pos) {
        if (pos >= this.length) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }
        const ch = this.input.charCodeAt(pos);
        if (isNewLine(ch)) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }
        if (escaped) {
          escaped = false;
        } else {
          if (ch === 91) {
            inClass = true;
          } else if (ch === 93 && inClass) {
            inClass = false;
          } else if (ch === 47 && !inClass) {
            break;
          }
          escaped = ch === 92;
        }
      }
      const content = this.input.slice(start, pos);
      ++pos;
      let mods = "";
      while (pos < this.length) {
        const cp = this.codePointAtPos(pos);
        const char = String.fromCharCode(cp);
        if (VALID_REGEX_FLAGS.has(cp)) {
          if (mods.includes(char)) {
            this.raise(pos + 1, ErrorMessages.DuplicateRegExpFlags);
          }
        } else if (isIdentifierChar(cp) || cp === 92) {
          this.raise(pos + 1, ErrorMessages.MalformedRegExpFlags);
        } else {
          break;
        }
        ++pos;
        mods += char;
      }
      this.state.pos = pos;
      this.finishToken(types$1.regexp, {
        pattern: content,
        flags: mods
      });
    }
    readInt(radix, len, forceLen, allowNumSeparator = true) {
      const start = this.state.pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code = this.input.charCodeAt(this.state.pos);
        let val;
        if (code === 95) {
          const prev = this.input.charCodeAt(this.state.pos - 1);
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          }
          if (!allowNumSeparator) {
            this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
          }
          ++this.state.pos;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++this.state.pos;
        total = total * radix + val;
      }
      if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
        return null;
      }
      return total;
    }
    readRadixNumber(radix) {
      const start = this.state.pos;
      let isBigInt = false;
      this.state.pos += 2;
      const val = this.readInt(radix);
      if (val == null) {
        this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
      }
      const next = this.input.charCodeAt(this.state.pos);
      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(start, ErrorMessages.InvalidDecimal);
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }
      if (isBigInt) {
        const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types$1.bigint, str);
        return;
      }
      this.finishToken(types$1.num, val);
    }
    readNumber(startsWithDot) {
      const start = this.state.pos;
      let isFloat = false;
      let isBigInt = false;
      let isDecimal = false;
      let hasExponent = false;
      let isOctal = false;
      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, ErrorMessages.InvalidNumber);
      }
      const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (hasLeadingZero) {
        const integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);
        if (!this.state.strict) {
          const underscorePos = integer.indexOf("_");
          if (underscorePos > 0) {
            this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
          }
        }
        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }
      let next = this.input.charCodeAt(this.state.pos);
      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);
        if (next === 43 || next === 45) {
          ++this.state.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, ErrorMessages.InvalidOrMissingExponent);
        }
        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidBigIntLiteral);
        }
        ++this.state.pos;
        isBigInt = true;
      }
      if (next === 109) {
        this.expectPlugin("decimal", this.state.pos);
        if (hasExponent || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidDecimal);
        }
        ++this.state.pos;
        isDecimal = true;
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }
      const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
      if (isBigInt) {
        this.finishToken(types$1.bigint, str);
        return;
      }
      if (isDecimal) {
        this.finishToken(types$1.decimal, str);
        return;
      }
      const val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types$1.num, val);
    }
    readCodePoint(throwOnInvalid) {
      const ch = this.input.charCodeAt(this.state.pos);
      let code;
      if (ch === 123) {
        const codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
        ++this.state.pos;
        if (code !== null && code > 1114111) {
          if (throwOnInvalid) {
            this.raise(codePos, ErrorMessages.InvalidCodePoint);
          } else {
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }
      return code;
    }
    readString(quote) {
      let out = "", chunkStart = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote)
          break;
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        } else {
          ++this.state.pos;
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types$1.string, out);
    }
    readTmplToken() {
      let out = "", chunkStart = this.state.pos, containsInvalid = false;
      for (; ; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
        }
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(types$1.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types$1.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types$1.backQuote);
              return;
            }
          }
          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types$1.template, containsInvalid ? null : out);
          return;
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          const escaped = this.readEscapedChar(true);
          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }
          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;
          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
          }
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    }
    recordStrictModeErrors(pos, message) {
      if (this.state.strict && !this.state.strictErrors.has(pos)) {
        this.raise(pos, message);
      } else {
        this.state.strictErrors.set(pos, message);
      }
    }
    readEscapedChar(inTemplate) {
      const throwOnInvalid = !inTemplate;
      const ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;
      switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120: {
          const code = this.readHexChar(2, false, throwOnInvalid);
          return code === null ? null : String.fromCharCode(code);
        }
        case 117: {
          const code = this.readCodePoint(throwOnInvalid);
          return code === null ? null : String.fromCodePoint(code);
        }
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }
        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;
        case 8232:
        case 8233:
          return "";
        case 56:
        case 57:
          if (inTemplate) {
            return null;
          } else {
            this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const codePos = this.state.pos - 1;
            const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.state.pos += octalStr.length - 1;
            const next = this.input.charCodeAt(this.state.pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return null;
              } else {
                this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
              }
            }
            return String.fromCharCode(octal);
          }
          return String.fromCharCode(ch);
      }
    }
    readHexChar(len, forceLen, throwOnInvalid) {
      const codePos = this.state.pos;
      const n = this.readInt(16, len, forceLen, false);
      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
        } else {
          this.state.pos = codePos - 1;
        }
      }
      return n;
    }
    readWord1(firstCode) {
      this.state.containsEsc = false;
      let word = "";
      const start = this.state.pos;
      let chunkStart = this.state.pos;
      if (firstCode !== void 0) {
        this.state.pos += firstCode <= 65535 ? 1 : 2;
      }
      while (this.state.pos < this.length) {
        const ch = this.codePointAtPos(this.state.pos);
        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          const escStart = this.state.pos;
          const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
            chunkStart = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const esc = this.readCodePoint(true);
          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
            }
            word += String.fromCodePoint(esc);
          }
          chunkStart = this.state.pos;
        } else {
          break;
        }
      }
      return word + this.input.slice(chunkStart, this.state.pos);
    }
    readWord(firstCode) {
      const word = this.readWord1(firstCode);
      const type = keywords$1.get(word) || types$1.name;
      this.finishToken(type, word);
    }
    checkKeywordEscapes() {
      const kw = this.state.type.keyword;
      if (kw && this.state.containsEsc) {
        this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
      }
    }
    updateContext(prevType) {
      var _this$state$type$upda, _this$state$type;
      (_this$state$type$upda = (_this$state$type = this.state.type).updateContext) == null ? void 0 : _this$state$type$upda.call(_this$state$type, this.state.context);
    }
  };
  var ClassScope = class {
    constructor() {
      this.privateNames = new Set();
      this.loneAccessors = new Map();
      this.undefinedPrivateNames = new Map();
    }
  };
  var ClassScopeHandler = class {
    constructor(raise) {
      this.stack = [];
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ClassScope());
    }
    exit() {
      const oldClassScope = this.stack.pop();
      const current = this.current();
      for (const [name, pos] of Array.from(oldClassScope.undefinedPrivateNames)) {
        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, pos);
          }
        } else {
          this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
        }
      }
    }
    declarePrivateName(name, elementType, pos) {
      const classScope = this.current();
      let redefined = classScope.privateNames.has(name);
      if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
        const accessor = redefined && classScope.loneAccessors.get(name);
        if (accessor) {
          const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
          const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
          const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
          const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined)
            classScope.loneAccessors.delete(name);
        } else if (!redefined) {
          classScope.loneAccessors.set(name, elementType);
        }
      }
      if (redefined) {
        this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
      }
      classScope.privateNames.add(name);
      classScope.undefinedPrivateNames.delete(name);
    }
    usePrivateName(name, pos) {
      let classScope;
      for (classScope of this.stack) {
        if (classScope.privateNames.has(name))
          return;
      }
      if (classScope) {
        classScope.undefinedPrivateNames.set(name, pos);
      } else {
        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
      }
    }
  };
  var kExpression = 0;
  var kMaybeArrowParameterDeclaration = 1;
  var kMaybeAsyncArrowParameterDeclaration = 2;
  var kParameterDeclaration = 3;
  var ExpressionScope = class {
    constructor(type = kExpression) {
      this.type = void 0;
      this.type = type;
    }
    canBeArrowParameterDeclaration() {
      return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
    }
    isCertainlyParameterDeclaration() {
      return this.type === kParameterDeclaration;
    }
  };
  var ArrowHeadParsingScope = class extends ExpressionScope {
    constructor(type) {
      super(type);
      this.errors = new Map();
    }
    recordDeclarationError(pos, template) {
      this.errors.set(pos, template);
    }
    clearDeclarationError(pos) {
      this.errors.delete(pos);
    }
    iterateErrors(iterator) {
      this.errors.forEach(iterator);
    }
  };
  var ExpressionScopeHandler = class {
    constructor(raise) {
      this.stack = [new ExpressionScope()];
      this.raise = raise;
    }
    enter(scope) {
      this.stack.push(scope);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(pos, template) {
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope = stack[i];
      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(pos, template);
        } else {
          return;
        }
        scope = stack[--i];
      }
      this.raise(pos, template);
    }
    recordParenthesizedIdentifierError(pos, template) {
      const {
        stack
      } = this;
      const scope = stack[stack.length - 1];
      if (scope.isCertainlyParameterDeclaration()) {
        this.raise(pos, template);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(pos, template);
      } else {
        return;
      }
    }
    recordAsyncArrowParametersError(pos, template) {
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope = stack[i];
      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
          scope.recordDeclarationError(pos, template);
        }
        scope = stack[--i];
      }
    }
    validateAsPattern() {
      const {
        stack
      } = this;
      const currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration())
        return;
      currentScope.iterateErrors((template, pos) => {
        this.raise(pos, template);
        let i = stack.length - 2;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(pos);
          scope = stack[--i];
        }
      });
    }
  };
  function newParameterDeclarationScope() {
    return new ExpressionScope(kParameterDeclaration);
  }
  function newArrowHeadScope() {
    return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
  }
  function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
  }
  function newExpressionScope() {
    return new ExpressionScope();
  }
  var PARAM = 0;
  var PARAM_YIELD = 1;
  var PARAM_AWAIT = 2;
  var PARAM_RETURN = 4;
  var PARAM_IN = 8;
  var ProductionParameterHandler = class {
    constructor() {
      this.stacks = [];
    }
    enter(flags) {
      this.stacks.push(flags);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & PARAM_AWAIT) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & PARAM_YIELD) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & PARAM_RETURN) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & PARAM_IN) > 0;
    }
  };
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
  }
  var UtilParser = class extends Tokenizer {
    addExtra(node, key, val) {
      if (!node)
        return;
      const extra = node.extra = node.extra || {};
      extra[key] = val;
    }
    isRelational(op) {
      return this.match(types$1.relational) && this.state.value === op;
    }
    expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types$1.relational);
      }
    }
    isContextual(name) {
      return this.match(types$1.name) && this.state.value === name && !this.state.containsEsc;
    }
    isUnparsedContextual(nameStart, name) {
      const nameEnd = nameStart + name.length;
      if (this.input.slice(nameStart, nameEnd) === name) {
        const nextCh = this.input.charCodeAt(nameEnd);
        return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
      }
      return false;
    }
    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
    eatContextual(name) {
      return this.isContextual(name) && this.eat(types$1.name);
    }
    expectContextual(name, template) {
      if (!this.eatContextual(name))
        this.unexpected(null, template);
    }
    canInsertSemicolon() {
      return this.match(types$1.eof) || this.match(types$1.braceR) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }
    hasFollowingLineBreak() {
      skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
      return skipWhiteSpaceToLineBreak.test(this.input);
    }
    isLineTerminator() {
      return this.eat(types$1.semi) || this.canInsertSemicolon();
    }
    semicolon(allowAsi = true) {
      if (allowAsi ? this.isLineTerminator() : this.eat(types$1.semi))
        return;
      this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
    }
    expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    }
    assertNoSpace(message = "Unexpected space.") {
      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, {
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedSpace",
          template: message
        });
      }
    }
    unexpected(pos, messageOrType = {
      code: ErrorCodes.SyntaxError,
      reasonCode: "UnexpectedToken",
      template: "Unexpected token"
    }) {
      if (messageOrType instanceof TokenType) {
        messageOrType = {
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedToken",
          template: `Unexpected token, expected "${messageOrType.label}"`
        };
      }
      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    }
    expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: [name]
        }, `This experimental syntax requires enabling the parser plugin: '${name}'`);
      }
      return true;
    }
    expectOnePlugin(names, pos) {
      if (!names.some((n) => this.hasPlugin(n))) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: names
        }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`);
      }
    }
    tryParse(fn, oldState = this.state.clone()) {
      const abortSignal = {
        node: null
      };
      try {
        const node = fn((node2 = null) => {
          abortSignal.node = node2;
          throw abortSignal;
        });
        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          this.state = oldState;
          this.state.tokensLength = failState.tokensLength;
          return {
            node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState
          };
        }
        return {
          node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        const failState = this.state;
        this.state = oldState;
        if (error instanceof SyntaxError) {
          return {
            node: null,
            error,
            thrown: true,
            aborted: false,
            failState
          };
        }
        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState
          };
        }
        throw error;
      }
    }
    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors)
        return false;
      const {
        shorthandAssign,
        doubleProto,
        optionalParameters
      } = refExpressionErrors;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0 || optionalParameters >= 0;
      }
      if (shorthandAssign >= 0) {
        this.unexpected(shorthandAssign);
      }
      if (doubleProto >= 0) {
        this.raise(doubleProto, ErrorMessages.DuplicateProto);
      }
      if (optionalParameters >= 0) {
        this.unexpected(optionalParameters);
      }
    }
    isLiteralPropertyName() {
      return this.match(types$1.name) || !!this.state.type.keyword || this.match(types$1.string) || this.match(types$1.num) || this.match(types$1.bigint) || this.match(types$1.decimal);
    }
    isPrivateName(node) {
      return node.type === "PrivateName";
    }
    getPrivateNameSV(node) {
      return node.id.name;
    }
    hasPropertyAsPrivateName(node) {
      return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    }
    isOptionalChain(node) {
      return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
    }
    isObjectProperty(node) {
      return node.type === "ObjectProperty";
    }
    isObjectMethod(node) {
      return node.type === "ObjectMethod";
    }
    initializeScopes(inModule = this.options.sourceType === "module") {
      const oldLabels = this.state.labels;
      this.state.labels = [];
      const oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set();
      const oldInModule = this.inModule;
      this.inModule = inModule;
      const oldScope = this.scope;
      const ScopeHandler2 = this.getScopeHandler();
      this.scope = new ScopeHandler2(this.raise.bind(this), this.inModule);
      const oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      const oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this.raise.bind(this));
      const oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
      return () => {
        this.state.labels = oldLabels;
        this.exportedIdentifiers = oldExportedIdentifiers;
        this.inModule = oldInModule;
        this.scope = oldScope;
        this.prodParam = oldProdParam;
        this.classScope = oldClassScope;
        this.expressionScope = oldExpressionScope;
      };
    }
    enterInitialScopes() {
      let paramFlags = PARAM;
      if (this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }
      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
    }
  };
  var ExpressionErrors = class {
    constructor() {
      this.shorthandAssign = -1;
      this.doubleProto = -1;
      this.optionalParameters = -1;
    }
  };
  var Node = class {
    constructor(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if (parser != null && parser.options.ranges)
        this.range = [pos, 0];
      if (parser != null && parser.filename)
        this.loc.filename = parser.filename;
    }
  };
  var NodePrototype = Node.prototype;
  {
    NodePrototype.__clone = function() {
      const newNode = new Node();
      const keys = Object.keys(this);
      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];
        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }
      return newNode;
    };
  }
  function clonePlaceholder(node) {
    return cloneIdentifier(node);
  }
  function cloneIdentifier(node) {
    const {
      type,
      start,
      end,
      loc,
      range,
      extra,
      name
    } = node;
    const cloned = Object.create(NodePrototype);
    cloned.type = type;
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    cloned.extra = extra;
    cloned.name = name;
    if (type === "Placeholder") {
      cloned.expectedNode = node.expectedNode;
    }
    return cloned;
  }
  function cloneStringLiteral(node) {
    const {
      type,
      start,
      end,
      loc,
      range,
      extra
    } = node;
    if (type === "Placeholder") {
      return clonePlaceholder(node);
    }
    const cloned = Object.create(NodePrototype);
    cloned.type = "StringLiteral";
    cloned.start = start;
    cloned.end = end;
    cloned.loc = loc;
    cloned.range = range;
    cloned.extra = extra;
    cloned.value = node.value;
    return cloned;
  }
  var NodeUtils = class extends UtilParser {
    startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    }
    startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    }
    finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }
    finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges)
        node.range[1] = pos;
      if (this.options.attachComment)
        this.processComment(node);
      return node;
    }
    resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges)
        node.range[0] = start;
    }
    resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {
      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges)
        node.range[1] = end;
    }
    resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    }
  };
  var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  var FlowErrors = makeErrorTemplates({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: "Cannot overwrite reserved type %0.",
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
    EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
    EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
    EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
    EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
    EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
    EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
    EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
    EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: "Unexpected reserved type %0.",
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  }, ErrorCodes.SyntaxError);
  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }
  function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
  }
  function isMaybeDefaultImport(state) {
    return (state.type === types$1.name || !!state.type.keyword) && state.value !== "from";
  }
  var exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function partition(list, test) {
    const list1 = [];
    const list2 = [];
    for (let i = 0; i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }
    return [list1, list2];
  }
  var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow = (superClass) => class extends superClass {
    constructor(...args) {
      super(...args);
      this.flowPragma = void 0;
    }
    getScopeHandler() {
      return FlowScopeHandler;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(type, val) {
      if (type !== types$1.string && type !== types$1.semi && type !== types$1.interpreterDirective) {
        if (this.flowPragma === void 0) {
          this.flowPragma = null;
        }
      }
      return super.finishToken(type, val);
    }
    addComment(comment) {
      if (this.flowPragma === void 0) {
        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
        if (!matches)
          ;
        else if (matches[1] === "flow") {
          this.flowPragma = "flow";
        } else if (matches[1] === "noflow") {
          this.flowPragma = "noflow";
        } else {
          throw new Error("Unexpected flow pragma");
        }
      }
      return super.addComment(comment);
    }
    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(tok || types$1.colon);
      const type = this.flowParseType();
      this.state.inType = oldInType;
      return type;
    }
    flowParsePredicate() {
      const node = this.startNode();
      const moduloPos = this.state.start;
      this.next();
      this.expectContextual("checks");
      if (this.state.lastTokStart > moduloPos + 1) {
        this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
      }
      if (this.eat(types$1.parenL)) {
        node.value = this.parseExpression();
        this.expect(types$1.parenR);
        return this.finishNode(node, "DeclaredPredicate");
      } else {
        return this.finishNode(node, "InferredPredicate");
      }
    }
    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(types$1.colon);
      let type = null;
      let predicate = null;
      if (this.match(types$1.modulo)) {
        this.state.inType = oldInType;
        predicate = this.flowParsePredicate();
      } else {
        type = this.flowParseType();
        this.state.inType = oldInType;
        if (this.match(types$1.modulo)) {
          predicate = this.flowParsePredicate();
        }
      }
      return [type, predicate];
    }
    flowParseDeclareClass(node) {
      this.next();
      this.flowParseInterfaceish(node, true);
      return this.finishNode(node, "DeclareClass");
    }
    flowParseDeclareFunction(node) {
      this.next();
      const id = node.id = this.parseIdentifier();
      const typeNode = this.startNode();
      const typeContainer = this.startNode();
      if (this.isRelational("<")) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        typeNode.typeParameters = null;
      }
      this.expect(types$1.parenL);
      const tmp = this.flowParseFunctionTypeParams();
      typeNode.params = tmp.params;
      typeNode.rest = tmp.rest;
      typeNode.this = tmp._this;
      this.expect(types$1.parenR);
      [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
      typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
      this.resetEndLocation(id);
      this.semicolon();
      this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);
      return this.finishNode(node, "DeclareFunction");
    }
    flowParseDeclare(node, insideModule) {
      if (this.match(types$1._class)) {
        return this.flowParseDeclareClass(node);
      } else if (this.match(types$1._function)) {
        return this.flowParseDeclareFunction(node);
      } else if (this.match(types$1._var)) {
        return this.flowParseDeclareVariable(node);
      } else if (this.eatContextual("module")) {
        if (this.match(types$1.dot)) {
          return this.flowParseDeclareModuleExports(node);
        } else {
          if (insideModule) {
            this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
          }
          return this.flowParseDeclareModule(node);
        }
      } else if (this.isContextual("type")) {
        return this.flowParseDeclareTypeAlias(node);
      } else if (this.isContextual("opaque")) {
        return this.flowParseDeclareOpaqueType(node);
      } else if (this.isContextual("interface")) {
        return this.flowParseDeclareInterface(node);
      } else if (this.match(types$1._export)) {
        return this.flowParseDeclareExportDeclaration(node, insideModule);
      } else {
        throw this.unexpected();
      }
    }
    flowParseDeclareVariable(node) {
      this.next();
      node.id = this.flowParseTypeAnnotatableIdentifier(true);
      this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
      this.semicolon();
      return this.finishNode(node, "DeclareVariable");
    }
    flowParseDeclareModule(node) {
      this.scope.enter(SCOPE_OTHER);
      if (this.match(types$1.string)) {
        node.id = this.parseExprAtom();
      } else {
        node.id = this.parseIdentifier();
      }
      const bodyNode = node.body = this.startNode();
      const body = bodyNode.body = [];
      this.expect(types$1.braceL);
      while (!this.match(types$1.braceR)) {
        let bodyNode2 = this.startNode();
        if (this.match(types$1._import)) {
          this.next();
          if (!this.isContextual("type") && !this.match(types$1._typeof)) {
            this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
          }
          this.parseImport(bodyNode2);
        } else {
          this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
          bodyNode2 = this.flowParseDeclare(bodyNode2, true);
        }
        body.push(bodyNode2);
      }
      this.scope.exit();
      this.expect(types$1.braceR);
      this.finishNode(bodyNode, "BlockStatement");
      let kind = null;
      let hasModuleExport = false;
      body.forEach((bodyElement) => {
        if (isEsModuleType(bodyElement)) {
          if (kind === "CommonJS") {
            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
          }
          kind = "ES";
        } else if (bodyElement.type === "DeclareModuleExports") {
          if (hasModuleExport) {
            this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
          }
          if (kind === "ES") {
            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
          }
          kind = "CommonJS";
          hasModuleExport = true;
        }
      });
      node.kind = kind || "CommonJS";
      return this.finishNode(node, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(node, insideModule) {
      this.expect(types$1._export);
      if (this.eat(types$1._default)) {
        if (this.match(types$1._function) || this.match(types$1._class)) {
          node.declaration = this.flowParseDeclare(this.startNode());
        } else {
          node.declaration = this.flowParseType();
          this.semicolon();
        }
        node.default = true;
        return this.finishNode(node, "DeclareExportDeclaration");
      } else {
        if (this.match(types$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
          const label = this.state.value;
          const suggestion = exportSuggestions[label];
          throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
        }
        if (this.match(types$1._var) || this.match(types$1._function) || this.match(types$1._class) || this.isContextual("opaque")) {
          node.declaration = this.flowParseDeclare(this.startNode());
          node.default = false;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else if (this.match(types$1.star) || this.match(types$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
          node = this.parseExport(node);
          if (node.type === "ExportNamedDeclaration") {
            node.type = "ExportDeclaration";
            node.default = false;
            delete node.exportKind;
          }
          node.type = "Declare" + node.type;
          return node;
        }
      }
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(node) {
      this.next();
      this.expectContextual("exports");
      node.typeAnnotation = this.flowParseTypeAnnotation();
      this.semicolon();
      return this.finishNode(node, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(node) {
      this.next();
      this.flowParseTypeAlias(node);
      node.type = "DeclareTypeAlias";
      return node;
    }
    flowParseDeclareOpaqueType(node) {
      this.next();
      this.flowParseOpaqueType(node, true);
      node.type = "DeclareOpaqueType";
      return node;
    }
    flowParseDeclareInterface(node) {
      this.next();
      this.flowParseInterfaceish(node);
      return this.finishNode(node, "DeclareInterface");
    }
    flowParseInterfaceish(node, isClass = false) {
      node.id = this.flowParseRestrictedIdentifier(!isClass, true);
      this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.extends = [];
      node.implements = [];
      node.mixins = [];
      if (this.eat(types$1._extends)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (!isClass && this.eat(types$1.comma));
      }
      if (this.isContextual("mixins")) {
        this.next();
        do {
          node.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(types$1.comma));
      }
      if (this.isContextual("implements")) {
        this.next();
        do {
          node.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(types$1.comma));
      }
      node.body = this.flowParseObjectType({
        allowStatic: isClass,
        allowExact: false,
        allowSpread: false,
        allowProto: isClass,
        allowInexact: false
      });
    }
    flowParseInterfaceExtends() {
      const node = this.startNode();
      node.id = this.flowParseQualifiedTypeIdentifier();
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      } else {
        node.typeParameters = null;
      }
      return this.finishNode(node, "InterfaceExtends");
    }
    flowParseInterface(node) {
      this.flowParseInterfaceish(node);
      return this.finishNode(node, "InterfaceDeclaration");
    }
    checkNotUnderscore(word) {
      if (word === "_") {
        this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
      }
    }
    checkReservedType(word, startLoc, declaration) {
      if (!reservedTypes.has(word))
        return;
      this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
    }
    flowParseRestrictedIdentifier(liberal, declaration) {
      this.checkReservedType(this.state.value, this.state.start, declaration);
      return this.parseIdentifier(liberal);
    }
    flowParseTypeAlias(node) {
      node.id = this.flowParseRestrictedIdentifier(false, true);
      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.right = this.flowParseTypeInitialiser(types$1.eq);
      this.semicolon();
      return this.finishNode(node, "TypeAlias");
    }
    flowParseOpaqueType(node, declare) {
      this.expectContextual("type");
      node.id = this.flowParseRestrictedIdentifier(true, true);
      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.supertype = null;
      if (this.match(types$1.colon)) {
        node.supertype = this.flowParseTypeInitialiser(types$1.colon);
      }
      node.impltype = null;
      if (!declare) {
        node.impltype = this.flowParseTypeInitialiser(types$1.eq);
      }
      this.semicolon();
      return this.finishNode(node, "OpaqueType");
    }
    flowParseTypeParameter(requireDefault = false) {
      const nodeStart = this.state.start;
      const node = this.startNode();
      const variance = this.flowParseVariance();
      const ident = this.flowParseTypeAnnotatableIdentifier();
      node.name = ident.name;
      node.variance = variance;
      node.bound = ident.typeAnnotation;
      if (this.match(types$1.eq)) {
        this.eat(types$1.eq);
        node.default = this.flowParseType();
      } else {
        if (requireDefault) {
          this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
        }
      }
      return this.finishNode(node, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType;
      const node = this.startNode();
      node.params = [];
      this.state.inType = true;
      if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
        this.next();
      } else {
        this.unexpected();
      }
      let defaultRequired = false;
      do {
        const typeParameter = this.flowParseTypeParameter(defaultRequired);
        node.params.push(typeParameter);
        if (typeParameter.default) {
          defaultRequired = true;
        }
        if (!this.isRelational(">")) {
          this.expect(types$1.comma);
        }
      } while (!this.isRelational(">"));
      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const node = this.startNode();
      const oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expectRelational("<");
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = false;
      while (!this.isRelational(">")) {
        node.params.push(this.flowParseType());
        if (!this.isRelational(">")) {
          this.expect(types$1.comma);
        }
      }
      this.state.noAnonFunctionType = oldNoAnonFunctionType;
      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const node = this.startNode();
      const oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expectRelational("<");
      while (!this.isRelational(">")) {
        node.params.push(this.flowParseTypeOrImplicitInstantiation());
        if (!this.isRelational(">")) {
          this.expect(types$1.comma);
        }
      }
      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const node = this.startNode();
      this.expectContextual("interface");
      node.extends = [];
      if (this.eat(types$1._extends)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(types$1.comma));
      }
      node.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      });
      return this.finishNode(node, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(types$1.num) || this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(node, isStatic, variance) {
      node.static = isStatic;
      if (this.lookahead().type === types$1.colon) {
        node.id = this.flowParseObjectPropertyKey();
        node.key = this.flowParseTypeInitialiser();
      } else {
        node.id = null;
        node.key = this.flowParseType();
      }
      this.expect(types$1.bracketR);
      node.value = this.flowParseTypeInitialiser();
      node.variance = variance;
      return this.finishNode(node, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(node, isStatic) {
      node.static = isStatic;
      node.id = this.flowParseObjectPropertyKey();
      this.expect(types$1.bracketR);
      this.expect(types$1.bracketR);
      if (this.isRelational("<") || this.match(types$1.parenL)) {
        node.method = true;
        node.optional = false;
        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
      } else {
        node.method = false;
        if (this.eat(types$1.question)) {
          node.optional = true;
        }
        node.value = this.flowParseTypeInitialiser();
      }
      return this.finishNode(node, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(node) {
      node.params = [];
      node.rest = null;
      node.typeParameters = null;
      node.this = null;
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      this.expect(types$1.parenL);
      if (this.match(types$1._this)) {
        node.this = this.flowParseFunctionTypeParam(true);
        node.this.name = null;
        if (!this.match(types$1.parenR)) {
          this.expect(types$1.comma);
        }
      }
      while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
        node.params.push(this.flowParseFunctionTypeParam(false));
        if (!this.match(types$1.parenR)) {
          this.expect(types$1.comma);
        }
      }
      if (this.eat(types$1.ellipsis)) {
        node.rest = this.flowParseFunctionTypeParam(false);
      }
      this.expect(types$1.parenR);
      node.returnType = this.flowParseTypeInitialiser();
      return this.finishNode(node, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(node, isStatic) {
      const valueNode = this.startNode();
      node.static = isStatic;
      node.value = this.flowParseObjectTypeMethodish(valueNode);
      return this.finishNode(node, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic,
      allowExact,
      allowSpread,
      allowProto,
      allowInexact
    }) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const nodeStart = this.startNode();
      nodeStart.callProperties = [];
      nodeStart.properties = [];
      nodeStart.indexers = [];
      nodeStart.internalSlots = [];
      let endDelim;
      let exact;
      let inexact = false;
      if (allowExact && this.match(types$1.braceBarL)) {
        this.expect(types$1.braceBarL);
        endDelim = types$1.braceBarR;
        exact = true;
      } else {
        this.expect(types$1.braceL);
        endDelim = types$1.braceR;
        exact = false;
      }
      nodeStart.exact = exact;
      while (!this.match(endDelim)) {
        let isStatic = false;
        let protoStart = null;
        let inexactStart = null;
        const node = this.startNode();
        if (allowProto && this.isContextual("proto")) {
          const lookahead = this.lookahead();
          if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
            this.next();
            protoStart = this.state.start;
            allowStatic = false;
          }
        }
        if (allowStatic && this.isContextual("static")) {
          const lookahead = this.lookahead();
          if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
            this.next();
            isStatic = true;
          }
        }
        const variance = this.flowParseVariance();
        if (this.eat(types$1.bracketL)) {
          if (protoStart != null) {
            this.unexpected(protoStart);
          }
          if (this.eat(types$1.bracketL)) {
            if (variance) {
              this.unexpected(variance.start);
            }
            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
          } else {
            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
          }
        } else if (this.match(types$1.parenL) || this.isRelational("<")) {
          if (protoStart != null) {
            this.unexpected(protoStart);
          }
          if (variance) {
            this.unexpected(variance.start);
          }
          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
        } else {
          let kind = "init";
          if (this.isContextual("get") || this.isContextual("set")) {
            const lookahead = this.lookahead();
            if (lookahead.type === types$1.name || lookahead.type === types$1.string || lookahead.type === types$1.num) {
              kind = this.state.value;
              this.next();
            }
          }
          const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
          if (propOrInexact === null) {
            inexact = true;
            inexactStart = this.state.lastTokStart;
          } else {
            nodeStart.properties.push(propOrInexact);
          }
        }
        this.flowObjectTypeSemicolon();
        if (inexactStart && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
          this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
        }
      }
      this.expect(endDelim);
      if (allowSpread) {
        nodeStart.inexact = inexact;
      }
      const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      this.state.inType = oldInType;
      return out;
    }
    flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
      if (this.eat(types$1.ellipsis)) {
        const isInexactToken = this.match(types$1.comma) || this.match(types$1.semi) || this.match(types$1.braceR) || this.match(types$1.braceBarR);
        if (isInexactToken) {
          if (!allowSpread) {
            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
          } else if (!allowInexact) {
            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
          }
          if (variance) {
            this.raise(variance.start, FlowErrors.InexactVariance);
          }
          return null;
        }
        if (!allowSpread) {
          this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
        }
        if (protoStart != null) {
          this.unexpected(protoStart);
        }
        if (variance) {
          this.raise(variance.start, FlowErrors.SpreadVariance);
        }
        node.argument = this.flowParseType();
        return this.finishNode(node, "ObjectTypeSpreadProperty");
      } else {
        node.key = this.flowParseObjectPropertyKey();
        node.static = isStatic;
        node.proto = protoStart != null;
        node.kind = kind;
        let optional = false;
        if (this.isRelational("<") || this.match(types$1.parenL)) {
          node.method = true;
          if (protoStart != null) {
            this.unexpected(protoStart);
          }
          if (variance) {
            this.unexpected(variance.start);
          }
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
          if (kind === "get" || kind === "set") {
            this.flowCheckGetterSetterParams(node);
          }
          if (!allowSpread && node.key.name === "constructor" && node.value.this) {
            this.raise(node.value.this.start, FlowErrors.ThisParamBannedInConstructor);
          }
        } else {
          if (kind !== "init")
            this.unexpected();
          node.method = false;
          if (this.eat(types$1.question)) {
            optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
        }
        node.optional = optional;
        return this.finishNode(node, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(property) {
      const paramCount = property.kind === "get" ? 0 : 1;
      const start = property.start;
      const length = property.value.params.length + (property.value.rest ? 1 : 0);
      if (property.value.this) {
        this.raise(property.value.this.start, property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);
      }
      if (length !== paramCount) {
        if (property.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }
      if (property.kind === "set" && property.value.rest) {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    }
    flowObjectTypeSemicolon() {
      if (!this.eat(types$1.semi) && !this.eat(types$1.comma) && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
        this.unexpected();
      }
    }
    flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      let node = id || this.flowParseRestrictedIdentifier(true);
      while (this.eat(types$1.dot)) {
        const node2 = this.startNodeAt(startPos, startLoc);
        node2.qualification = node;
        node2.id = this.flowParseRestrictedIdentifier(true);
        node = this.finishNode(node2, "QualifiedTypeIdentifier");
      }
      return node;
    }
    flowParseGenericType(startPos, startLoc, id) {
      const node = this.startNodeAt(startPos, startLoc);
      node.typeParameters = null;
      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      }
      return this.finishNode(node, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const node = this.startNode();
      this.expect(types$1._typeof);
      node.argument = this.flowParsePrimaryType();
      return this.finishNode(node, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const node = this.startNode();
      node.types = [];
      this.expect(types$1.bracketL);
      while (this.state.pos < this.length && !this.match(types$1.bracketR)) {
        node.types.push(this.flowParseType());
        if (this.match(types$1.bracketR))
          break;
        this.expect(types$1.comma);
      }
      this.expect(types$1.bracketR);
      return this.finishNode(node, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(first) {
      let name = null;
      let optional = false;
      let typeAnnotation = null;
      const node = this.startNode();
      const lh = this.lookahead();
      const isThis = this.state.type === types$1._this;
      if (lh.type === types$1.colon || lh.type === types$1.question) {
        if (isThis && !first) {
          this.raise(node.start, FlowErrors.ThisParamMustBeFirst);
        }
        name = this.parseIdentifier(isThis);
        if (this.eat(types$1.question)) {
          optional = true;
          if (isThis) {
            this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);
          }
        }
        typeAnnotation = this.flowParseTypeInitialiser();
      } else {
        typeAnnotation = this.flowParseType();
      }
      node.name = name;
      node.optional = optional;
      node.typeAnnotation = typeAnnotation;
      return this.finishNode(node, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(type) {
      const node = this.startNodeAt(type.start, type.loc.start);
      node.name = null;
      node.optional = false;
      node.typeAnnotation = type;
      return this.finishNode(node, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(params = []) {
      let rest = null;
      let _this = null;
      if (this.match(types$1._this)) {
        _this = this.flowParseFunctionTypeParam(true);
        _this.name = null;
        if (!this.match(types$1.parenR)) {
          this.expect(types$1.comma);
        }
      }
      while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
        params.push(this.flowParseFunctionTypeParam(false));
        if (!this.match(types$1.parenR)) {
          this.expect(types$1.comma);
        }
      }
      if (this.eat(types$1.ellipsis)) {
        rest = this.flowParseFunctionTypeParam(false);
      }
      return {
        params,
        rest,
        _this
      };
    }
    flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
      switch (id.name) {
        case "any":
          return this.finishNode(node, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(node, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(node, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(node, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(node, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(node, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(node, "SymbolTypeAnnotation");
        default:
          this.checkNotUnderscore(id.name);
          return this.flowParseGenericType(startPos, startLoc, id);
      }
    }
    flowParsePrimaryType() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const node = this.startNode();
      let tmp;
      let type;
      let isGroupedType = false;
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case types$1.name:
          if (this.isContextual("interface")) {
            return this.flowParseInterfaceType();
          }
          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
        case types$1.braceL:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });
        case types$1.braceBarL:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });
        case types$1.bracketL:
          this.state.noAnonFunctionType = false;
          type = this.flowParseTupleType();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          return type;
        case types$1.relational:
          if (this.state.value === "<") {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(types$1.parenL);
            tmp = this.flowParseFunctionTypeParams();
            node.params = tmp.params;
            node.rest = tmp.rest;
            node.this = tmp._this;
            this.expect(types$1.parenR);
            this.expect(types$1.arrow);
            node.returnType = this.flowParseType();
            return this.finishNode(node, "FunctionTypeAnnotation");
          }
          break;
        case types$1.parenL:
          this.next();
          if (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
            if (this.match(types$1.name) || this.match(types$1._this)) {
              const token = this.lookahead().type;
              isGroupedType = token !== types$1.question && token !== types$1.colon;
            } else {
              isGroupedType = true;
            }
          }
          if (isGroupedType) {
            this.state.noAnonFunctionType = false;
            type = this.flowParseType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.state.noAnonFunctionType || !(this.match(types$1.comma) || this.match(types$1.parenR) && this.lookahead().type === types$1.arrow)) {
              this.expect(types$1.parenR);
              return type;
            } else {
              this.eat(types$1.comma);
            }
          }
          if (type) {
            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
          } else {
            tmp = this.flowParseFunctionTypeParams();
          }
          node.params = tmp.params;
          node.rest = tmp.rest;
          node.this = tmp._this;
          this.expect(types$1.parenR);
          this.expect(types$1.arrow);
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        case types$1.string:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case types$1._true:
        case types$1._false:
          node.value = this.match(types$1._true);
          this.next();
          return this.finishNode(node, "BooleanLiteralTypeAnnotation");
        case types$1.plusMin:
          if (this.state.value === "-") {
            this.next();
            if (this.match(types$1.num)) {
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
            }
            if (this.match(types$1.bigint)) {
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
            }
            throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
          }
          throw this.unexpected();
        case types$1.num:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case types$1.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case types$1._void:
          this.next();
          return this.finishNode(node, "VoidTypeAnnotation");
        case types$1._null:
          this.next();
          return this.finishNode(node, "NullLiteralTypeAnnotation");
        case types$1._this:
          this.next();
          return this.finishNode(node, "ThisTypeAnnotation");
        case types$1.star:
          this.next();
          return this.finishNode(node, "ExistsTypeAnnotation");
        default:
          if (this.state.type.keyword === "typeof") {
            return this.flowParseTypeofType();
          } else if (this.state.type.keyword) {
            const label = this.state.type.label;
            this.next();
            return super.createIdentifier(node, label);
          }
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let type = this.flowParsePrimaryType();
      let seenOptionalIndexedAccess = false;
      while ((this.match(types$1.bracketL) || this.match(types$1.questionDot)) && !this.canInsertSemicolon()) {
        const node = this.startNodeAt(startPos, startLoc);
        const optional = this.eat(types$1.questionDot);
        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
        this.expect(types$1.bracketL);
        if (!optional && this.match(types$1.bracketR)) {
          node.elementType = type;
          this.next();
          type = this.finishNode(node, "ArrayTypeAnnotation");
        } else {
          node.objectType = type;
          node.indexType = this.flowParseType();
          this.expect(types$1.bracketR);
          if (seenOptionalIndexedAccess) {
            node.optional = optional;
            type = this.finishNode(node, "OptionalIndexedAccessType");
          } else {
            type = this.finishNode(node, "IndexedAccessType");
          }
        }
      }
      return type;
    }
    flowParsePrefixType() {
      const node = this.startNode();
      if (this.eat(types$1.question)) {
        node.typeAnnotation = this.flowParsePrefixType();
        return this.finishNode(node, "NullableTypeAnnotation");
      } else {
        return this.flowParsePostfixType();
      }
    }
    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(types$1.arrow)) {
        const node = this.startNodeAt(param.start, param.loc.start);
        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
        node.rest = null;
        node.this = null;
        node.returnType = this.flowParseType();
        node.typeParameters = null;
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      return param;
    }
    flowParseIntersectionType() {
      const node = this.startNode();
      this.eat(types$1.bitwiseAND);
      const type = this.flowParseAnonFunctionWithoutParens();
      node.types = [type];
      while (this.eat(types$1.bitwiseAND)) {
        node.types.push(this.flowParseAnonFunctionWithoutParens());
      }
      return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const node = this.startNode();
      this.eat(types$1.bitwiseOR);
      const type = this.flowParseIntersectionType();
      node.types = [type];
      while (this.eat(types$1.bitwiseOR)) {
        node.types.push(this.flowParseIntersectionType());
      }
      return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
    }
    flowParseType() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const type = this.flowParseUnionType();
      this.state.inType = oldInType;
      return type;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === types$1.name && this.state.value === "_") {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const node = this.parseIdentifier();
        return this.flowParseGenericType(startPos, startLoc, node);
      } else {
        return this.flowParseType();
      }
    }
    flowParseTypeAnnotation() {
      const node = this.startNode();
      node.typeAnnotation = this.flowParseTypeInitialiser();
      return this.finishNode(node, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      if (this.match(types$1.colon)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(ident);
      }
      return ident;
    }
    typeCastToParameter(node) {
      node.expression.typeAnnotation = node.typeAnnotation;
      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
      return node.expression;
    }
    flowParseVariance() {
      let variance = null;
      if (this.match(types$1.plusMin)) {
        variance = this.startNode();
        if (this.state.value === "+") {
          variance.kind = "plus";
        } else {
          variance.kind = "minus";
        }
        this.next();
        this.finishNode(variance, "Variance");
      }
      return variance;
    }
    parseFunctionBody(node, allowExpressionBody, isMethod = false) {
      if (allowExpressionBody) {
        return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
      }
      return super.parseFunctionBody(node, false, isMethod);
    }
    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      if (this.match(types$1.colon)) {
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      }
      super.parseFunctionBodyAndFinish(node, type, isMethod);
    }
    parseStatement(context, topLevel) {
      if (this.state.strict && this.match(types$1.name) && this.state.value === "interface") {
        const lookahead = this.lookahead();
        if (lookahead.type === types$1.name || isKeyword(lookahead.value)) {
          const node = this.startNode();
          this.next();
          return this.flowParseInterface(node);
        }
      } else if (this.shouldParseEnums() && this.isContextual("enum")) {
        const node = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node);
      }
      const stmt = super.parseStatement(context, topLevel);
      if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
        this.flowPragma = null;
      }
      return stmt;
    }
    parseExpressionStatement(node, expr) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(types$1._class) || this.match(types$1.name) || this.match(types$1._function) || this.match(types$1._var) || this.match(types$1._export)) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(types$1.name)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          } else if (expr.name === "opaque") {
            return this.flowParseOpaqueType(node, false);
          }
        }
      }
      return super.parseExpressionStatement(node, expr);
    }
    shouldParseExportDeclaration() {
      return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      if (this.match(types$1.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
        return false;
      }
      return super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual("enum")) {
        const node = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (!this.match(types$1.question))
        return expr;
      if (this.state.maybeInArrowParameters) {
        const nextCh = this.lookaheadCharCode();
        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
          this.setOptionalParametersError(refExpressionErrors);
          return expr;
        }
      }
      this.expect(types$1.question);
      const state = this.state.clone();
      const originalNoArrowAt = this.state.noArrowAt;
      const node = this.startNodeAt(startPos, startLoc);
      let {
        consequent,
        failed
      } = this.tryParseConditionalConsequent();
      let [valid, invalid] = this.getArrowLikeExpressions(consequent);
      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt];
        if (invalid.length > 0) {
          this.state = state;
          this.state.noArrowAt = noArrowAt;
          for (let i = 0; i < invalid.length; i++) {
            noArrowAt.push(invalid[i].start);
          }
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
          [valid, invalid] = this.getArrowLikeExpressions(consequent);
        }
        if (failed && valid.length > 1) {
          this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
        }
        if (failed && valid.length === 1) {
          this.state = state;
          this.state.noArrowAt = noArrowAt.concat(valid[0].start);
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
        }
      }
      this.getArrowLikeExpressions(consequent, true);
      this.state.noArrowAt = originalNoArrowAt;
      this.expect(types$1.colon);
      node.test = expr;
      node.consequent = consequent;
      node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
      return this.finishNode(node, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const consequent = this.parseMaybeAssignAllowIn();
      const failed = !this.match(types$1.colon);
      this.state.noArrowParamsConversionAt.pop();
      return {
        consequent,
        failed
      };
    }
    getArrowLikeExpressions(node, disallowInvalid) {
      const stack = [node];
      const arrows = [];
      while (stack.length !== 0) {
        const node2 = stack.pop();
        if (node2.type === "ArrowFunctionExpression") {
          if (node2.typeParameters || !node2.returnType) {
            this.finishArrowValidation(node2);
          } else {
            arrows.push(node2);
          }
          stack.push(node2.body);
        } else if (node2.type === "ConditionalExpression") {
          stack.push(node2.consequent);
          stack.push(node2.alternate);
        }
      }
      if (disallowInvalid) {
        arrows.forEach((node2) => this.finishArrowValidation(node2));
        return [arrows, []];
      }
      return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
    }
    finishArrowValidation(node) {
      var _node$extra;
      this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      super.checkParams(node, false, true);
      this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(node, parse3) {
      let result;
      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        result = parse3();
        this.state.noArrowParamsConversionAt.pop();
      } else {
        result = parse3();
      }
      return result;
    }
    parseParenItem(node, startPos, startLoc) {
      node = super.parseParenItem(node, startPos, startLoc);
      if (this.eat(types$1.question)) {
        node.optional = true;
        this.resetEndLocation(node);
      }
      if (this.match(types$1.colon)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TypeCastExpression");
      }
      return node;
    }
    assertModuleNodeAllowed(node) {
      if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
        return;
      }
      super.assertModuleNodeAllowed(node);
    }
    parseExport(node) {
      const decl = super.parseExport(node);
      if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
        decl.exportKind = decl.exportKind || "value";
      }
      return decl;
    }
    parseExportDeclaration(node) {
      if (this.isContextual("type")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        if (this.match(types$1.braceL)) {
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual("opaque")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseOpaqueType(declarationNode, false);
      } else if (this.isContextual("interface")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(declarationNode);
      } else if (this.shouldParseEnums() && this.isContextual("enum")) {
        node.exportKind = "value";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(declarationNode);
      } else {
        return super.parseExportDeclaration(node);
      }
    }
    eatExportStar(node) {
      if (super.eatExportStar(...arguments))
        return true;
      if (this.isContextual("type") && this.lookahead().type === types$1.star) {
        node.exportKind = "type";
        this.next();
        this.next();
        return true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(node) {
      const pos = this.state.start;
      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
      if (hasNamespace && node.exportKind === "type") {
        this.unexpected(pos);
      }
      return hasNamespace;
    }
    parseClassId(node, isStatement, optionalId) {
      super.parseClassId(node, isStatement, optionalId);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    }
    parseClassMember(classBody, member, state) {
      const pos = this.state.start;
      if (this.isContextual("declare")) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }
        member.declare = true;
      }
      super.parseClassMember(classBody, member, state);
      if (member.declare) {
        if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
          this.raise(pos, FlowErrors.DeclareClassElement);
        } else if (member.value) {
          this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
        }
      }
    }
    isIterator(word) {
      return word === "iterator" || word === "asyncIterator";
    }
    readIterator() {
      const word = super.readWord1();
      const fullWord = "@@" + word;
      if (!this.isIterator(word) || !this.state.inType) {
        this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, fullWord);
      }
      this.finishToken(types$1.name, fullWord);
    }
    getTokenFromCode(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code === 123 && next === 124) {
        return this.finishOp(types$1.braceBarL, 2);
      } else if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types$1.relational, 1);
      } else if (this.state.inType && code === 63) {
        if (next === 46) {
          return this.finishOp(types$1.questionDot, 2);
        }
        return this.finishOp(types$1.question, 1);
      } else if (isIteratorStart(code, next)) {
        this.state.pos += 2;
        return this.readIterator();
      } else {
        return super.getTokenFromCode(code);
      }
    }
    isAssignable(node, isBinding) {
      if (node.type === "TypeCastExpression") {
        return this.isAssignable(node.expression, isBinding);
      } else {
        return super.isAssignable(node, isBinding);
      }
    }
    toAssignable(node, isLHS = false) {
      if (node.type === "TypeCastExpression") {
        return super.toAssignable(this.typeCastToParameter(node), isLHS);
      } else {
        return super.toAssignable(node, isLHS);
      }
    }
    toAssignableList(exprList, trailingCommaPos, isLHS) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      return super.toAssignableList(exprList, trailingCommaPos, isLHS);
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i = 0; i < exprList.length; i++) {
        var _expr$extra;
        const expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
          this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
        }
      }
      return exprList;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
      if (canBePattern && !this.state.maybeInArrowParameters) {
        this.toReferencedList(node.elements);
      }
      return node;
    }
    checkLVal(expr, ...args) {
      if (expr.type !== "TypeCastExpression") {
        return super.checkLVal(expr, ...args);
      }
    }
    parseClassProperty(node) {
      if (this.match(types$1.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassProperty(node);
    }
    parseClassPrivateProperty(node) {
      if (this.match(types$1.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return super.parseClassPrivateProperty(node);
    }
    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(types$1.colon) || super.isClassProperty();
    }
    isNonstaticConstructor(method) {
      return !this.match(types$1.colon) && super.isNonstaticConstructor(method);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      if (method.variance) {
        this.unexpected(method.variance.start);
      }
      delete method.variance;
      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      if (method.params && isConstructor) {
        const params = method.params;
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
        }
      } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
        const params = method.value.params;
        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
        }
      }
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      if (method.variance) {
        this.unexpected(method.variance.start);
      }
      delete method.variance;
      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    parseClassSuper(node) {
      super.parseClassSuper(node);
      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual("implements")) {
        this.next();
        const implemented = node.implements = [];
        do {
          const node2 = this.startNode();
          node2.id = this.flowParseRestrictedIdentifier(true);
          if (this.isRelational("<")) {
            node2.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node2.typeParameters = null;
          }
          implemented.push(this.finishNode(node2, "ClassImplements"));
        } while (this.eat(types$1.comma));
      }
    }
    checkGetterSetterParams(method) {
      super.checkGetterSetterParams(method);
      const params = this.getObjectOrClassMethodParams(method);
      if (params.length > 0) {
        const param = params[0];
        if (this.isThisParam(param) && method.kind === "get") {
          this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
        } else if (this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
        }
      }
    }
    parsePropertyName(node, isPrivateNameAllowed) {
      const variance = this.flowParseVariance();
      const key = super.parsePropertyName(node, isPrivateNameAllowed);
      node.variance = variance;
      return key;
    }
    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      if (prop.variance) {
        this.unexpected(prop.variance.start);
      }
      delete prop.variance;
      let typeParameters;
      if (this.isRelational("<") && !isAccessor) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(types$1.parenL))
          this.unexpected();
      }
      super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    }
    parseAssignableListItemTypes(param) {
      if (this.eat(types$1.question)) {
        if (param.type !== "Identifier") {
          this.raise(param.start, FlowErrors.OptionalBindingPattern);
        }
        if (this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
        }
        param.optional = true;
      }
      if (this.match(types$1.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      } else if (this.isThisParam(param)) {
        this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
      }
      if (this.match(types$1.eq) && this.isThisParam(param)) {
        this.raise(param.start, FlowErrors.ThisParamNoDefault);
      }
      this.resetEndLocation(param);
      return param;
    }
    parseMaybeDefault(startPos, startLoc, left) {
      const node = super.parseMaybeDefault(startPos, startLoc, left);
      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
      }
      return node;
    }
    shouldParseDefaultImport(node) {
      if (!hasTypeImportKind(node)) {
        return super.shouldParseDefaultImport(node);
      }
      return isMaybeDefaultImport(this.state);
    }
    parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, type));
    }
    maybeParseDefaultImportSpecifier(node) {
      node.importKind = "value";
      let kind = null;
      if (this.match(types$1._typeof)) {
        kind = "typeof";
      } else if (this.isContextual("type")) {
        kind = "type";
      }
      if (kind) {
        const lh = this.lookahead();
        if (kind === "type" && lh.type === types$1.star) {
          this.unexpected(lh.start);
        }
        if (isMaybeDefaultImport(lh) || lh.type === types$1.braceL || lh.type === types$1.star) {
          this.next();
          node.importKind = kind;
        }
      }
      return super.maybeParseDefaultImportSpecifier(node);
    }
    parseImportSpecifier(node) {
      const specifier = this.startNode();
      const firstIdentIsString = this.match(types$1.string);
      const firstIdent = this.parseModuleExportName();
      let specifierTypeKind = null;
      if (firstIdent.type === "Identifier") {
        if (firstIdent.name === "type") {
          specifierTypeKind = "type";
        } else if (firstIdent.name === "typeof") {
          specifierTypeKind = "typeof";
        }
      }
      let isBinding = false;
      if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
        const as_ident = this.parseIdentifier(true);
        if (specifierTypeKind !== null && !this.match(types$1.name) && !this.state.type.keyword) {
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = cloneIdentifier(as_ident);
        } else {
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else {
        if (specifierTypeKind !== null && (this.match(types$1.name) || this.state.type.keyword)) {
          specifier.imported = this.parseIdentifier(true);
          specifier.importKind = specifierTypeKind;
        } else {
          if (firstIdentIsString) {
            throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
          }
          specifier.imported = firstIdent;
          specifier.importKind = null;
        }
        if (this.eatContextual("as")) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding = true;
          specifier.local = cloneIdentifier(specifier.imported);
        }
      }
      const nodeIsTypeImport = hasTypeImportKind(node);
      const specifierIsTypeImport = hasTypeImportKind(specifier);
      if (nodeIsTypeImport && specifierIsTypeImport) {
        this.raise(specifier.start, FlowErrors.ImportTypeShorthandOnlyInPureImport);
      }
      if (nodeIsTypeImport || specifierIsTypeImport) {
        this.checkReservedType(specifier.local.name, specifier.local.start, true);
      }
      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
        this.checkReservedWord(specifier.local.name, specifier.start, true, true);
      }
      this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case types$1._this:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(node, allowModifiers) {
      const kind = node.kind;
      if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      super.parseFunctionParams(node, allowModifiers);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);
      if (this.match(types$1.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(decl.id);
      }
    }
    parseAsyncArrowFromCallExpression(node, call) {
      if (this.match(types$1.colon)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }
      return super.parseAsyncArrowFromCallExpression(node, call);
    }
    shouldParseAsyncArrow() {
      return this.match(types$1.colon) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx;
      let state = null;
      let jsx2;
      if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
        state = this.state.clone();
        jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!jsx2.error)
          return jsx2.node;
        const {
          context
        } = this.state;
        const curContext = context[context.length - 1];
        if (curContext === types.j_oTag) {
          context.length -= 2;
        } else if (curContext === types.j_expr) {
          context.length -= 1;
        }
      }
      if ((_jsx = jsx2) != null && _jsx.error || this.isRelational("<")) {
        var _jsx2, _jsx3;
        state = state || this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _arrowExpression$extr;
          typeParameters = this.flowParseTypeParameterDeclaration();
          const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            this.resetStartLocationFromNode(result, typeParameters);
            return result;
          });
          if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
            abort();
          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
          if (expr.type !== "ArrowFunctionExpression")
            abort();
          expr.typeParameters = typeParameters;
          this.resetStartLocationFromNode(expr, typeParameters);
          return arrowExpression2;
        }, state);
        let arrowExpression = null;
        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
          if (!arrow.error && !arrow.aborted) {
            if (arrow.node.async) {
              this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
            }
            return arrow.node;
          }
          arrowExpression = arrow.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrowExpression) {
          this.state = arrow.failState;
          return arrowExpression;
        }
        if ((_jsx3 = jsx2) != null && _jsx3.thrown)
          throw jsx2.error;
        if (arrow.thrown)
          throw arrow.error;
        throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
      }
      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    }
    parseArrow(node) {
      if (this.match(types$1.colon)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          if (this.canInsertSemicolon())
            this.unexpected();
          if (!this.match(types$1.arrow))
            this.unexpected();
          return typeNode;
        });
        if (result.thrown)
          return null;
        if (result.error)
          this.state = result.failState;
        node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(node);
    }
    shouldParseArrow(params) {
      return this.match(types$1.colon) || super.shouldParseArrow(params);
    }
    setArrowFunctionParameters(node, params) {
      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        node.params = params;
      } else {
        super.setArrowFunctionParameters(node, params);
      }
    }
    checkParams(node, allowDuplicates, isArrowFunction) {
      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        return;
      }
      for (let i = 0; i < node.params.length; i++) {
        if (this.isThisParam(node.params[i]) && i > 0) {
          this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);
        }
      }
      return super.checkParams(...arguments);
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(base, startPos, startLoc, noCalls) {
      if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
        this.next();
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
        base = this.finishNode(node, "CallExpression");
      } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
        const state = this.state.clone();
        const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
        if (!arrow.error && !arrow.aborted)
          return arrow.node;
        const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
        if (result.node && !result.error)
          return result.node;
        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }
        if (result.node) {
          this.state = result.failState;
          return result.node;
        }
        throw arrow.error || result.error;
      }
      return super.parseSubscripts(base, startPos, startLoc, noCalls);
    }
    parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
      if (this.match(types$1.questionDot) && this.isLookaheadToken_lt()) {
        subscriptState.optionalChainMember = true;
        if (noCalls) {
          subscriptState.stop = true;
          return base;
        }
        this.next();
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        node.typeArguments = this.flowParseTypeParameterInstantiation();
        this.expect(types$1.parenL);
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
        node.optional = true;
        return this.finishCallExpression(node, true);
      } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        const result = this.tryParse(() => {
          node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
          this.expect(types$1.parenL);
          node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
          if (subscriptState.optionalChainMember)
            node.optional = false;
          return this.finishCallExpression(node, subscriptState.optionalChainMember);
        });
        if (result.node) {
          if (result.error)
            this.state = result.failState;
          return result.node;
        }
      }
      return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
    }
    parseNewArguments(node) {
      let targs = null;
      if (this.shouldParseTypes() && this.isRelational("<")) {
        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
      }
      node.typeArguments = targs;
      super.parseNewArguments(node);
    }
    parseAsyncArrowWithTypeParameters(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      this.parseFunctionParams(node);
      if (!this.parseArrow(node))
        return;
      return this.parseArrowExpression(node, void 0, true);
    }
    readToken_mult_modulo(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false;
        this.state.pos += 2;
        this.nextToken();
        return;
      }
      super.readToken_mult_modulo(code);
    }
    readToken_pipe_amp(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (code === 124 && next === 125) {
        this.finishOp(types$1.braceBarR, 2);
        return;
      }
      super.readToken_pipe_amp(code);
    }
    parseTopLevel(file, program) {
      const fileNode = super.parseTopLevel(file, program);
      if (this.state.hasFlowComment) {
        this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
      }
      return fileNode;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment) {
          this.unexpected(null, FlowErrors.NestedFlowComment);
        }
        this.hasFlowCommentCompletion();
        this.state.pos += this.skipFlowComment();
        this.state.hasFlowComment = true;
        return;
      }
      if (this.state.hasFlowComment) {
        const end = this.input.indexOf("*-/", this.state.pos += 2);
        if (end === -1) {
          throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
        }
        this.state.pos = end + 3;
        return;
      }
      return super.skipBlockComment();
    }
    skipFlowComment() {
      const {
        pos
      } = this.state;
      let shiftToFirstNonWhiteSpace = 2;
      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
        shiftToFirstNonWhiteSpace++;
      }
      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
      if (ch2 === 58 && ch3 === 58) {
        return shiftToFirstNonWhiteSpace + 2;
      }
      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
        return shiftToFirstNonWhiteSpace + 12;
      }
      if (ch2 === 58 && ch3 !== 58) {
        return shiftToFirstNonWhiteSpace;
      }
      return false;
    }
    hasFlowCommentCompletion() {
      const end = this.input.indexOf("*/", this.state.pos);
      if (end === -1) {
        throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
      }
    }
    flowEnumErrorBooleanMemberNotInitialized(pos, {
      enumName,
      memberName
    }) {
      this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
    }
    flowEnumErrorInvalidMemberName(pos, {
      enumName,
      memberName
    }) {
      const suggestion = memberName[0].toUpperCase() + memberName.slice(1);
      this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
    }
    flowEnumErrorDuplicateMemberName(pos, {
      enumName,
      memberName
    }) {
      this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
    }
    flowEnumErrorInconsistentMemberValues(pos, {
      enumName
    }) {
      this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
    }
    flowEnumErrorInvalidExplicitType(pos, {
      enumName,
      suppliedType
    }) {
      return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
    }
    flowEnumErrorInvalidMemberInitializer(pos, {
      enumName,
      explicitType,
      memberName
    }) {
      let message = null;
      switch (explicitType) {
        case "boolean":
        case "number":
        case "string":
          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
          break;
        case "symbol":
          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
          break;
        default:
          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
      }
      return this.raise(pos, message, enumName, memberName, explicitType);
    }
    flowEnumErrorNumberMemberNotInitialized(pos, {
      enumName,
      memberName
    }) {
      this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(pos, {
      enumName
    }) {
      this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
    }
    flowEnumMemberInit() {
      const startPos = this.state.start;
      const endOfInit = () => this.match(types$1.comma) || this.match(types$1.braceR);
      switch (this.state.type) {
        case types$1.num: {
          const literal = this.parseNumericLiteral(this.state.value);
          if (endOfInit()) {
            return {
              type: "number",
              pos: literal.start,
              value: literal
            };
          }
          return {
            type: "invalid",
            pos: startPos
          };
        }
        case types$1.string: {
          const literal = this.parseStringLiteral(this.state.value);
          if (endOfInit()) {
            return {
              type: "string",
              pos: literal.start,
              value: literal
            };
          }
          return {
            type: "invalid",
            pos: startPos
          };
        }
        case types$1._true:
        case types$1._false: {
          const literal = this.parseBooleanLiteral(this.match(types$1._true));
          if (endOfInit()) {
            return {
              type: "boolean",
              pos: literal.start,
              value: literal
            };
          }
          return {
            type: "invalid",
            pos: startPos
          };
        }
        default:
          return {
            type: "invalid",
            pos: startPos
          };
      }
    }
    flowEnumMemberRaw() {
      const pos = this.state.start;
      const id = this.parseIdentifier(true);
      const init = this.eat(types$1.eq) ? this.flowEnumMemberInit() : {
        type: "none",
        pos
      };
      return {
        id,
        init
      };
    }
    flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
      const {
        explicitType
      } = context;
      if (explicitType === null) {
        return;
      }
      if (explicitType !== expectedType) {
        this.flowEnumErrorInvalidMemberInitializer(pos, context);
      }
    }
    flowEnumMembers({
      enumName,
      explicitType
    }) {
      const seenNames = new Set();
      const members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let hasUnknownMembers = false;
      while (!this.match(types$1.braceR)) {
        if (this.eat(types$1.ellipsis)) {
          hasUnknownMembers = true;
          break;
        }
        const memberNode = this.startNode();
        const {
          id,
          init
        } = this.flowEnumMemberRaw();
        const memberName = id.name;
        if (memberName === "") {
          continue;
        }
        if (/^[a-z]/.test(memberName)) {
          this.flowEnumErrorInvalidMemberName(id.start, {
            enumName,
            memberName
          });
        }
        if (seenNames.has(memberName)) {
          this.flowEnumErrorDuplicateMemberName(id.start, {
            enumName,
            memberName
          });
        }
        seenNames.add(memberName);
        const context = {
          enumName,
          explicitType,
          memberName
        };
        memberNode.id = id;
        switch (init.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
            memberNode.init = init.value;
            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
            memberNode.init = init.value;
            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
            memberNode.init = init.value;
            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
            break;
          }
          case "invalid": {
            throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
          }
          case "none": {
            switch (explicitType) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                break;
              default:
                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
            }
          }
        }
        if (!this.match(types$1.braceR)) {
          this.expect(types$1.comma);
        }
      }
      return {
        members,
        hasUnknownMembers
      };
    }
    flowEnumStringMembers(initializedMembers, defaultedMembers, {
      enumName
    }) {
      if (initializedMembers.length === 0) {
        return defaultedMembers;
      } else if (defaultedMembers.length === 0) {
        return initializedMembers;
      } else if (defaultedMembers.length > initializedMembers.length) {
        for (const member of initializedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
            enumName
          });
        }
        return defaultedMembers;
      } else {
        for (const member of defaultedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
            enumName
          });
        }
        return initializedMembers;
      }
    }
    flowEnumParseExplicitType({
      enumName
    }) {
      if (this.eatContextual("of")) {
        if (!this.match(types$1.name)) {
          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
            enumName,
            suppliedType: null
          });
        }
        const {
          value
        } = this.state;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.flowEnumErrorInvalidExplicitType(this.state.start, {
            enumName,
            suppliedType: value
          });
        }
        return value;
      }
      return null;
    }
    flowEnumBody(node, {
      enumName,
      nameLoc
    }) {
      const explicitType = this.flowEnumParseExplicitType({
        enumName
      });
      this.expect(types$1.braceL);
      const {
        members,
        hasUnknownMembers
      } = this.flowEnumMembers({
        enumName,
        explicitType
      });
      node.hasUnknownMembers = hasUnknownMembers;
      switch (explicitType) {
        case "boolean":
          node.explicitType = true;
          node.members = members.booleanMembers;
          this.expect(types$1.braceR);
          return this.finishNode(node, "EnumBooleanBody");
        case "number":
          node.explicitType = true;
          node.members = members.numberMembers;
          this.expect(types$1.braceR);
          return this.finishNode(node, "EnumNumberBody");
        case "string":
          node.explicitType = true;
          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName
          });
          this.expect(types$1.braceR);
          return this.finishNode(node, "EnumStringBody");
        case "symbol":
          node.members = members.defaultedMembers;
          this.expect(types$1.braceR);
          return this.finishNode(node, "EnumSymbolBody");
        default: {
          const empty = () => {
            node.members = [];
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumStringBody");
          };
          node.explicitType = false;
          const boolsLen = members.booleanMembers.length;
          const numsLen = members.numberMembers.length;
          const strsLen = members.stringMembers.length;
          const defaultedLen = members.defaultedMembers.length;
          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
            return empty();
          } else if (!boolsLen && !numsLen) {
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumStringBody");
          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                enumName,
                memberName: member.id.name
              });
            }
            node.members = members.booleanMembers;
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumBooleanBody");
          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
            for (const member of members.defaultedMembers) {
              this.flowEnumErrorNumberMemberNotInitialized(member.start, {
                enumName,
                memberName: member.id.name
              });
            }
            node.members = members.numberMembers;
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumNumberBody");
          } else {
            this.flowEnumErrorInconsistentMemberValues(nameLoc, {
              enumName
            });
            return empty();
          }
        }
      }
    }
    flowParseEnumDeclaration(node) {
      const id = this.parseIdentifier();
      node.id = id;
      node.body = this.flowEnumBody(this.startNode(), {
        enumName: id.name,
        nameLoc: id.start
      });
      return this.finishNode(node, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const next = this.nextTokenStart();
      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== 60 && afterNext !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(node) {
      return node.type === "TypeCastExpression" ? node.expression : node;
    }
  };
  var entities = {
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };
  var HEX_NUMBER = /^[\da-fA-F]+$/;
  var DECIMAL_NUMBER = /^\d+$/;
  var JsxErrors = makeErrorTemplates({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  }, ErrorCodes.SyntaxError);
  types.j_oTag = new TokContext("<tag");
  types.j_cTag = new TokContext("</tag");
  types.j_expr = new TokContext("<tag>...</tag>", true);
  types$1.jsxName = new TokenType("jsxName");
  types$1.jsxText = new TokenType("jsxText", {
    beforeExpr: true
  });
  types$1.jsxTagStart = new TokenType("jsxTagStart", {
    startsExpr: true
  });
  types$1.jsxTagEnd = new TokenType("jsxTagEnd");
  types$1.jsxTagStart.updateContext = (context) => {
    context.push(types.j_expr, types.j_oTag);
  };
  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  }
  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }
    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }
    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    throw new Error("Node had unexpected type: " + object.type);
  }
  var jsx = (superClass) => class extends superClass {
    jsxReadToken() {
      let out = "";
      let chunkStart = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
        }
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (ch === 60 && this.state.exprAllowed) {
                ++this.state.pos;
                return this.finishToken(types$1.jsxTagStart);
              }
              return super.getTokenFromCode(ch);
            }
            out += this.input.slice(chunkStart, this.state.pos);
            return this.finishToken(types$1.jsxText, out);
          case 38:
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(true);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
        }
      }
    }
    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos);
      let out;
      ++this.state.pos;
      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
        ++this.state.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }
      ++this.state.curLine;
      this.state.lineStart = this.state.pos;
      return out;
    }
    jsxReadString(quote) {
      let out = "";
      let chunkStart = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote)
          break;
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(false);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++);
      return this.finishToken(types$1.string, out);
    }
    jsxReadEntity() {
      let str = "";
      let count = 0;
      let entity;
      let ch = this.input[this.state.pos];
      const startPos = ++this.state.pos;
      while (this.state.pos < this.length && count++ < 10) {
        ch = this.input[this.state.pos++];
        if (ch === ";") {
          if (str[0] === "#") {
            if (str[1] === "x") {
              str = str.substr(2);
              if (HEX_NUMBER.test(str)) {
                entity = String.fromCodePoint(parseInt(str, 16));
              }
            } else {
              str = str.substr(1);
              if (DECIMAL_NUMBER.test(str)) {
                entity = String.fromCodePoint(parseInt(str, 10));
              }
            }
          } else {
            entity = entities[str];
          }
          break;
        }
        str += ch;
      }
      if (!entity) {
        this.state.pos = startPos;
        return "&";
      }
      return entity;
    }
    jsxReadWord() {
      let ch;
      const start = this.state.pos;
      do {
        ch = this.input.charCodeAt(++this.state.pos);
      } while (isIdentifierChar(ch) || ch === 45);
      return this.finishToken(types$1.jsxName, this.input.slice(start, this.state.pos));
    }
    jsxParseIdentifier() {
      const node = this.startNode();
      if (this.match(types$1.jsxName)) {
        node.name = this.state.value;
      } else if (this.state.type.keyword) {
        node.name = this.state.type.keyword;
      } else {
        this.unexpected();
      }
      this.next();
      return this.finishNode(node, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const name = this.jsxParseIdentifier();
      if (!this.eat(types$1.colon))
        return name;
      const node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsxParseIdentifier();
      return this.finishNode(node, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let node = this.jsxParseNamespacedName();
      if (node.type === "JSXNamespacedName") {
        return node;
      }
      while (this.eat(types$1.dot)) {
        const newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsxParseIdentifier();
        node = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node;
    }
    jsxParseAttributeValue() {
      let node;
      switch (this.state.type) {
        case types$1.braceL:
          node = this.startNode();
          this.next();
          node = this.jsxParseExpressionContainer(node);
          if (node.expression.type === "JSXEmptyExpression") {
            this.raise(node.start, JsxErrors.AttributeIsEmpty);
          }
          return node;
        case types$1.jsxTagStart:
        case types$1.string:
          return this.parseExprAtom();
        default:
          throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
      }
    }
    jsxParseEmptyExpression() {
      const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
      return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
    }
    jsxParseSpreadChild(node) {
      this.next();
      node.expression = this.parseExpression();
      this.expect(types$1.braceR);
      return this.finishNode(node, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(node) {
      if (this.match(types$1.braceR)) {
        node.expression = this.jsxParseEmptyExpression();
      } else {
        const expression = this.parseExpression();
        node.expression = expression;
      }
      this.expect(types$1.braceR);
      return this.finishNode(node, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const node = this.startNode();
      if (this.eat(types$1.braceL)) {
        this.expect(types$1.ellipsis);
        node.argument = this.parseMaybeAssignAllowIn();
        this.expect(types$1.braceR);
        return this.finishNode(node, "JSXSpreadAttribute");
      }
      node.name = this.jsxParseNamespacedName();
      node.value = this.eat(types$1.eq) ? this.jsxParseAttributeValue() : null;
      return this.finishNode(node, "JSXAttribute");
    }
    jsxParseOpeningElementAt(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      if (this.match(types$1.jsxTagEnd)) {
        this.expect(types$1.jsxTagEnd);
        return this.finishNode(node, "JSXOpeningFragment");
      }
      node.name = this.jsxParseElementName();
      return this.jsxParseOpeningElementAfterName(node);
    }
    jsxParseOpeningElementAfterName(node) {
      const attributes = [];
      while (!this.match(types$1.slash) && !this.match(types$1.jsxTagEnd)) {
        attributes.push(this.jsxParseAttribute());
      }
      node.attributes = attributes;
      node.selfClosing = this.eat(types$1.slash);
      this.expect(types$1.jsxTagEnd);
      return this.finishNode(node, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      if (this.match(types$1.jsxTagEnd)) {
        this.expect(types$1.jsxTagEnd);
        return this.finishNode(node, "JSXClosingFragment");
      }
      node.name = this.jsxParseElementName();
      this.expect(types$1.jsxTagEnd);
      return this.finishNode(node, "JSXClosingElement");
    }
    jsxParseElementAt(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      const children = [];
      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents:
          for (; ; ) {
            switch (this.state.type) {
              case types$1.jsxTagStart:
                startPos = this.state.start;
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(types$1.slash)) {
                  closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startPos, startLoc));
                break;
              case types$1.jsxText:
                children.push(this.parseExprAtom());
                break;
              case types$1.braceL: {
                const node2 = this.startNode();
                this.next();
                if (this.match(types$1.ellipsis)) {
                  children.push(this.jsxParseSpreadChild(node2));
                } else {
                  children.push(this.jsxParseExpressionContainer(node2));
                }
                break;
              }
              default:
                throw this.unexpected();
            }
          }
        if (isFragment(openingElement) && !isFragment(closingElement)) {
          this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
          }
        }
      }
      if (isFragment(openingElement)) {
        node.openingFragment = openingElement;
        node.closingFragment = closingElement;
      } else {
        node.openingElement = openingElement;
        node.closingElement = closingElement;
      }
      node.children = children;
      if (this.isRelational("<")) {
        throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
      }
      return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
    }
    jsxParseElement() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      this.next();
      return this.jsxParseElementAt(startPos, startLoc);
    }
    parseExprAtom(refExpressionErrors) {
      if (this.match(types$1.jsxText)) {
        return this.parseLiteral(this.state.value, "JSXText");
      } else if (this.match(types$1.jsxTagStart)) {
        return this.jsxParseElement();
      } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
        this.finishToken(types$1.jsxTagStart);
        return this.jsxParseElement();
      } else {
        return super.parseExprAtom(refExpressionErrors);
      }
    }
    createLookaheadState(state) {
      const lookaheadState = super.createLookaheadState(state);
      lookaheadState.inPropertyName = state.inPropertyName;
      return lookaheadState;
    }
    getTokenFromCode(code) {
      if (this.state.inPropertyName)
        return super.getTokenFromCode(code);
      const context = this.curContext();
      if (context === types.j_expr) {
        return this.jsxReadToken();
      }
      if (context === types.j_oTag || context === types.j_cTag) {
        if (isIdentifierStart(code)) {
          return this.jsxReadWord();
        }
        if (code === 62) {
          ++this.state.pos;
          return this.finishToken(types$1.jsxTagEnd);
        }
        if ((code === 34 || code === 39) && context === types.j_oTag) {
          return this.jsxReadString(code);
        }
      }
      if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos;
        return this.finishToken(types$1.jsxTagStart);
      }
      return super.getTokenFromCode(code);
    }
    updateContext(prevType) {
      super.updateContext(prevType);
      const {
        context,
        type
      } = this.state;
      if (type === types$1.slash && prevType === types$1.jsxTagStart) {
        context.splice(-2, 2, types.j_cTag);
        this.state.exprAllowed = false;
      } else if (type === types$1.jsxTagEnd) {
        const out = context.pop();
        if (out === types.j_oTag && prevType === types$1.slash || out === types.j_cTag) {
          context.pop();
          this.state.exprAllowed = context[context.length - 1] === types.j_expr;
        } else {
          this.state.exprAllowed = true;
        }
      } else if (type.keyword && (prevType === types$1.dot || prevType === types$1.questionDot)) {
        this.state.exprAllowed = false;
      } else {
        this.state.exprAllowed = type.beforeExpr;
      }
    }
  };
  var TypeScriptScope = class extends Scope {
    constructor(...args) {
      super(...args);
      this.types = new Set();
      this.enums = new Set();
      this.constEnums = new Set();
      this.classes = new Set();
      this.exportOnlyBindings = new Set();
    }
  };
  var TypeScriptScopeHandler = class extends ScopeHandler {
    createScope(flags) {
      return new TypeScriptScope(flags);
    }
    declareName(name, bindingType, pos) {
      const scope = this.currentScope();
      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.add(name);
        return;
      }
      super.declareName(...arguments);
      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }
        scope.types.add(name);
      }
      if (bindingType & BIND_FLAGS_TS_ENUM)
        scope.enums.add(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
        scope.constEnums.add(name);
      if (bindingType & BIND_FLAGS_CLASS)
        scope.classes.add(name);
    }
    isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.has(name)) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          const wasConst = scope.constEnums.has(name);
          return isConst !== wasConst;
        }
        return true;
      }
      if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
        if (scope.lexical.has(name)) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }
      if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
        return true;
      }
      return super.isRedeclaredInScope(...arguments);
    }
    checkLocalExport(id) {
      const topLevelScope = this.scopeStack[0];
      const {
        name
      } = id;
      if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
        super.checkLocalExport(id);
      }
    }
  };
  function nonNull(x) {
    if (x == null) {
      throw new Error(`Unexpected ${x} value.`);
    }
    return x;
  }
  function assert(x) {
    if (!x) {
      throw new Error("Assert fail");
    }
  }
  var TSErrors = makeErrorTemplates({
    AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
    AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.",
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: "'declare' is not allowed in %0ters.",
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
    DuplicateModifier: "Duplicate modifier: '%0'.",
    EmptyHeritageClauseType: "'%0' list cannot be empty.",
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
    InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
  }, ErrorCodes.SyntaxError);
  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return void 0;
    }
  }
  function tsIsAccessModifier(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
  }
  var typescript = (superClass) => class extends superClass {
    getScopeHandler() {
      return TypeScriptScopeHandler;
    }
    tsIsIdentifier() {
      return this.match(types$1.name);
    }
    tsTokenCanFollowModifier() {
      return (this.match(types$1.bracketL) || this.match(types$1.braceL) || this.match(types$1.star) || this.match(types$1.ellipsis) || this.match(types$1.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      this.next();
      return this.tsTokenCanFollowModifier();
    }
    tsParseModifier(allowedModifiers) {
      if (!this.match(types$1.name)) {
        return void 0;
      }
      const modifier = this.state.value;
      if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
        return modifier;
      }
      return void 0;
    }
    tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate) {
      const enforceOrder = (pos, modifier, before, after) => {
        if (modifier === before && modified[after]) {
          this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);
        }
      };
      const incompatible = (pos, modifier, mod1, mod2) => {
        if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
          this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);
        }
      };
      for (; ; ) {
        const startPos = this.state.start;
        const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []));
        if (!modifier)
          break;
        if (tsIsAccessModifier(modifier)) {
          if (modified.accessibility) {
            this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
          } else {
            enforceOrder(startPos, modifier, modifier, "override");
            enforceOrder(startPos, modifier, modifier, "static");
            enforceOrder(startPos, modifier, modifier, "readonly");
            modified.accessibility = modifier;
          }
        } else {
          if (Object.hasOwnProperty.call(modified, modifier)) {
            this.raise(startPos, TSErrors.DuplicateModifier, modifier);
          } else {
            enforceOrder(startPos, modifier, "static", "readonly");
            enforceOrder(startPos, modifier, "static", "override");
            enforceOrder(startPos, modifier, "override", "readonly");
            enforceOrder(startPos, modifier, "abstract", "override");
            incompatible(startPos, modifier, "declare", "override");
            incompatible(startPos, modifier, "static", "abstract");
          }
          modified[modifier] = true;
        }
        if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
          this.raise(startPos, errorTemplate, modifier);
        }
      }
    }
    tsIsListTerminator(kind) {
      switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(types$1.braceR);
        case "HeritageClauseElement":
          return this.match(types$1.braceL);
        case "TupleElementTypes":
          return this.match(types$1.bracketR);
        case "TypeParametersOrArguments":
          return this.isRelational(">");
      }
      throw new Error("Unreachable");
    }
    tsParseList(kind, parseElement) {
      const result = [];
      while (!this.tsIsListTerminator(kind)) {
        result.push(parseElement());
      }
      return result;
    }
    tsParseDelimitedList(kind, parseElement) {
      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
    }
    tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
      const result = [];
      for (; ; ) {
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        const element = parseElement();
        if (element == null) {
          return void 0;
        }
        result.push(element);
        if (this.eat(types$1.comma)) {
          continue;
        }
        if (this.tsIsListTerminator(kind)) {
          break;
        }
        if (expectSuccess) {
          this.expect(types$1.comma);
        }
        return void 0;
      }
      return result;
    }
    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
      if (!skipFirstToken) {
        if (bracket) {
          this.expect(types$1.bracketL);
        } else {
          this.expectRelational("<");
        }
      }
      const result = this.tsParseDelimitedList(kind, parseElement);
      if (bracket) {
        this.expect(types$1.bracketR);
      } else {
        this.expectRelational(">");
      }
      return result;
    }
    tsParseImportType() {
      const node = this.startNode();
      this.expect(types$1._import);
      this.expect(types$1.parenL);
      if (!this.match(types$1.string)) {
        this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
      }
      node.argument = this.parseExprAtom();
      this.expect(types$1.parenR);
      if (this.eat(types$1.dot)) {
        node.qualifier = this.tsParseEntityName(true);
      }
      if (this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node, "TSImportType");
    }
    tsParseEntityName(allowReservedWords) {
      let entity = this.parseIdentifier();
      while (this.eat(types$1.dot)) {
        const node = this.startNodeAtNode(entity);
        node.left = entity;
        node.right = this.parseIdentifier(allowReservedWords);
        entity = this.finishNode(node, "TSQualifiedName");
      }
      return entity;
    }
    tsParseTypeReference() {
      const node = this.startNode();
      node.typeName = this.tsParseEntityName(false);
      if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node, "TSTypeReference");
    }
    tsParseThisTypePredicate(lhs) {
      this.next();
      const node = this.startNodeAtNode(lhs);
      node.parameterName = lhs;
      node.typeAnnotation = this.tsParseTypeAnnotation(false);
      node.asserts = false;
      return this.finishNode(node, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const node = this.startNode();
      this.next();
      return this.finishNode(node, "TSThisType");
    }
    tsParseTypeQuery() {
      const node = this.startNode();
      this.expect(types$1._typeof);
      if (this.match(types$1._import)) {
        node.exprName = this.tsParseImportType();
      } else {
        node.exprName = this.tsParseEntityName(true);
      }
      return this.finishNode(node, "TSTypeQuery");
    }
    tsParseTypeParameter() {
      const node = this.startNode();
      node.name = this.tsParseTypeParameterName();
      node.constraint = this.tsEatThenParseType(types$1._extends);
      node.default = this.tsEatThenParseType(types$1.eq);
      return this.finishNode(node, "TSTypeParameter");
    }
    tsTryParseTypeParameters() {
      if (this.isRelational("<")) {
        return this.tsParseTypeParameters();
      }
    }
    tsParseTypeParameters() {
      const node = this.startNode();
      if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
        this.next();
      } else {
        this.unexpected();
      }
      node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
      if (node.params.length === 0) {
        this.raise(node.start, TSErrors.EmptyTypeParameters);
      }
      return this.finishNode(node, "TSTypeParameterDeclaration");
    }
    tsTryNextParseConstantContext() {
      if (this.lookahead().type === types$1._const) {
        this.next();
        return this.tsParseTypeReference();
      }
      return null;
    }
    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === types$1.arrow;
      signature.typeParameters = this.tsTryParseTypeParameters();
      this.expect(types$1.parenL);
      signature.parameters = this.tsParseBindingListForSignature();
      if (returnTokenRequired) {
        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      } else if (this.match(returnToken)) {
        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      }
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(types$1.parenR, 41).map((pattern) => {
        if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
          this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
        }
        return pattern;
      });
    }
    tsParseTypeMemberSemicolon() {
      if (!this.eat(types$1.comma) && !this.isLineTerminator()) {
        this.expect(types$1.semi);
      }
    }
    tsParseSignatureMember(kind, node) {
      this.tsFillSignature(types$1.colon, node);
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, kind);
    }
    tsIsUnambiguouslyIndexSignature() {
      this.next();
      return this.eat(types$1.name) && this.match(types$1.colon);
    }
    tsTryParseIndexSignature(node) {
      if (!(this.match(types$1.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
        return void 0;
      }
      this.expect(types$1.bracketL);
      const id = this.parseIdentifier();
      id.typeAnnotation = this.tsParseTypeAnnotation();
      this.resetEndLocation(id);
      this.expect(types$1.bracketR);
      node.parameters = [id];
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        node.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(node, readonly2) {
      if (this.eat(types$1.question))
        node.optional = true;
      const nodeAny = node;
      if (this.match(types$1.parenL) || this.isRelational("<")) {
        if (readonly2) {
          this.raise(node.start, TSErrors.ReadonlyForMethodSignature);
        }
        const method = nodeAny;
        if (method.kind && this.isRelational("<")) {
          this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);
        }
        this.tsFillSignature(types$1.colon, method);
        this.tsParseTypeMemberSemicolon();
        if (method.kind === "get") {
          if (method.parameters.length > 0) {
            this.raise(this.state.pos, ErrorMessages.BadGetterArity);
            if (this.isThisParam(method.parameters[0])) {
              this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
            }
          }
        } else if (method.kind === "set") {
          if (method.parameters.length !== 1) {
            this.raise(this.state.pos, ErrorMessages.BadSetterArity);
          } else {
            const firstParameter = method.parameters[0];
            if (this.isThisParam(firstParameter)) {
              this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
            }
            if (firstParameter.type === "Identifier" && firstParameter.optional) {
              this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);
            }
            if (firstParameter.type === "RestElement") {
              this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);
            }
          }
          if (method.typeAnnotation) {
            this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);
          }
        } else {
          method.kind = "method";
        }
        return this.finishNode(method, "TSMethodSignature");
      } else {
        const property = nodeAny;
        if (readonly2)
          property.readonly = true;
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          property.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(property, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const node = this.startNode();
      if (this.match(types$1.parenL) || this.isRelational("<")) {
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
      }
      if (this.match(types$1._new)) {
        const id = this.startNode();
        this.next();
        if (this.match(types$1.parenL) || this.isRelational("<")) {
          return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
        } else {
          node.key = this.createIdentifier(id, "new");
          return this.tsParsePropertyOrMethodSignature(node, false);
        }
      }
      this.tsParseModifiers(node, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
      const idx = this.tsTryParseIndexSignature(node);
      if (idx) {
        return idx;
      }
      this.parsePropertyName(node, false);
      if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
        node.kind = node.key.name;
        this.parsePropertyName(node, false);
      }
      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
    }
    tsParseTypeLiteral() {
      const node = this.startNode();
      node.members = this.tsParseObjectTypeMembers();
      return this.finishNode(node, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(types$1.braceL);
      const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      this.expect(types$1.braceR);
      return members;
    }
    tsIsStartOfMappedType() {
      this.next();
      if (this.eat(types$1.plusMin)) {
        return this.isContextual("readonly");
      }
      if (this.isContextual("readonly")) {
        this.next();
      }
      if (!this.match(types$1.bracketL)) {
        return false;
      }
      this.next();
      if (!this.tsIsIdentifier()) {
        return false;
      }
      this.next();
      return this.match(types$1._in);
    }
    tsParseMappedTypeParameter() {
      const node = this.startNode();
      node.name = this.tsParseTypeParameterName();
      node.constraint = this.tsExpectThenParseType(types$1._in);
      return this.finishNode(node, "TSTypeParameter");
    }
    tsParseMappedType() {
      const node = this.startNode();
      this.expect(types$1.braceL);
      if (this.match(types$1.plusMin)) {
        node.readonly = this.state.value;
        this.next();
        this.expectContextual("readonly");
      } else if (this.eatContextual("readonly")) {
        node.readonly = true;
      }
      this.expect(types$1.bracketL);
      node.typeParameter = this.tsParseMappedTypeParameter();
      node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
      this.expect(types$1.bracketR);
      if (this.match(types$1.plusMin)) {
        node.optional = this.state.value;
        this.next();
        this.expect(types$1.question);
      } else if (this.eat(types$1.question)) {
        node.optional = true;
      }
      node.typeAnnotation = this.tsTryParseType();
      this.semicolon();
      this.expect(types$1.braceR);
      return this.finishNode(node, "TSMappedType");
    }
    tsParseTupleType() {
      const node = this.startNode();
      node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let seenOptionalElement = false;
      let labeledElements = null;
      node.elementTypes.forEach((elementNode) => {
        var _labeledElements;
        let {
          type
        } = elementNode;
        if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
          this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
        }
        seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";
        if (type === "TSRestType") {
          elementNode = elementNode.typeAnnotation;
          type = elementNode.type;
        }
        const isLabeled = type === "TSNamedTupleMember";
        labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;
        if (labeledElements !== isLabeled) {
          this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
        }
      });
      return this.finishNode(node, "TSTupleType");
    }
    tsParseTupleElementType() {
      const {
        start: startPos,
        startLoc
      } = this.state;
      const rest = this.eat(types$1.ellipsis);
      let type = this.tsParseType();
      const optional = this.eat(types$1.question);
      const labeled = this.eat(types$1.colon);
      if (labeled) {
        const labeledNode = this.startNodeAtNode(type);
        labeledNode.optional = optional;
        if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
          labeledNode.label = type.typeName;
        } else {
          this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
          labeledNode.label = type;
        }
        labeledNode.elementType = this.tsParseType();
        type = this.finishNode(labeledNode, "TSNamedTupleMember");
      } else if (optional) {
        const optionalTypeNode = this.startNodeAtNode(type);
        optionalTypeNode.typeAnnotation = type;
        type = this.finishNode(optionalTypeNode, "TSOptionalType");
      }
      if (rest) {
        const restNode = this.startNodeAt(startPos, startLoc);
        restNode.typeAnnotation = type;
        type = this.finishNode(restNode, "TSRestType");
      }
      return type;
    }
    tsParseParenthesizedType() {
      const node = this.startNode();
      this.expect(types$1.parenL);
      node.typeAnnotation = this.tsParseType();
      this.expect(types$1.parenR);
      return this.finishNode(node, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(type, abstract) {
      const node = this.startNode();
      if (type === "TSConstructorType") {
        node.abstract = !!abstract;
        if (abstract)
          this.next();
        this.next();
      }
      this.tsFillSignature(types$1.arrow, node);
      return this.finishNode(node, type);
    }
    tsParseLiteralTypeNode() {
      const node = this.startNode();
      node.literal = (() => {
        switch (this.state.type) {
          case types$1.num:
          case types$1.bigint:
          case types$1.string:
          case types$1._true:
          case types$1._false:
            return this.parseExprAtom();
          default:
            throw this.unexpected();
        }
      })();
      return this.finishNode(node, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const node = this.startNode();
      node.literal = this.parseTemplate(false);
      return this.finishNode(node, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      if (this.state.inType)
        return this.tsParseType();
      return super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode();
      if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
        return this.tsParseThisTypePredicate(thisKeyword);
      } else {
        return thisKeyword;
      }
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case types$1.name:
        case types$1._void:
        case types$1._null: {
          const type = this.match(types$1._void) ? "TSVoidKeyword" : this.match(types$1._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
          if (type !== void 0 && this.lookaheadCharCode() !== 46) {
            const node = this.startNode();
            this.next();
            return this.finishNode(node, type);
          }
          return this.tsParseTypeReference();
        }
        case types$1.string:
        case types$1.num:
        case types$1.bigint:
        case types$1._true:
        case types$1._false:
          return this.tsParseLiteralTypeNode();
        case types$1.plusMin:
          if (this.state.value === "-") {
            const node = this.startNode();
            const nextToken = this.lookahead();
            if (nextToken.type !== types$1.num && nextToken.type !== types$1.bigint) {
              throw this.unexpected();
            }
            node.literal = this.parseMaybeUnary();
            return this.finishNode(node, "TSLiteralType");
          }
          break;
        case types$1._this:
          return this.tsParseThisTypeOrThisTypePredicate();
        case types$1._typeof:
          return this.tsParseTypeQuery();
        case types$1._import:
          return this.tsParseImportType();
        case types$1.braceL:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case types$1.bracketL:
          return this.tsParseTupleType();
        case types$1.parenL:
          return this.tsParseParenthesizedType();
        case types$1.backQuote:
          return this.tsParseTemplateLiteralType();
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let type = this.tsParseNonArrayType();
      while (!this.hasPrecedingLineBreak() && this.eat(types$1.bracketL)) {
        if (this.match(types$1.bracketR)) {
          const node = this.startNodeAtNode(type);
          node.elementType = type;
          this.expect(types$1.bracketR);
          type = this.finishNode(node, "TSArrayType");
        } else {
          const node = this.startNodeAtNode(type);
          node.objectType = type;
          node.indexType = this.tsParseType();
          this.expect(types$1.bracketR);
          type = this.finishNode(node, "TSIndexedAccessType");
        }
      }
      return type;
    }
    tsParseTypeOperator(operator) {
      const node = this.startNode();
      this.expectContextual(operator);
      node.operator = operator;
      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
      if (operator === "readonly") {
        this.tsCheckTypeAnnotationForReadOnly(node);
      }
      return this.finishNode(node, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(node) {
      switch (node.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(node.start, TSErrors.UnexpectedReadonly);
      }
    }
    tsParseInferType() {
      const node = this.startNode();
      this.expectContextual("infer");
      const typeParameter = this.startNode();
      typeParameter.name = this.tsParseTypeParameterName();
      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
      return this.finishNode(node, "TSInferType");
    }
    tsParseTypeOperatorOrHigher() {
      const operator = ["keyof", "unique", "readonly"].find((kw) => this.isContextual(kw));
      return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
    }
    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      const node = this.startNode();
      const hasLeadingOperator = this.eat(operator);
      const types2 = [];
      do {
        types2.push(parseConstituentType());
      } while (this.eat(operator));
      if (types2.length === 1 && !hasLeadingOperator) {
        return types2[0];
      }
      node.types = types2;
      return this.finishNode(node, kind);
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types$1.bitwiseAND);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types$1.bitwiseOR);
    }
    tsIsStartOfFunctionType() {
      if (this.isRelational("<")) {
        return true;
      }
      return this.match(types$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (this.match(types$1.name) || this.match(types$1._this)) {
        this.next();
        return true;
      }
      if (this.match(types$1.braceL)) {
        let braceStackCounter = 1;
        this.next();
        while (braceStackCounter > 0) {
          if (this.match(types$1.braceL)) {
            ++braceStackCounter;
          } else if (this.match(types$1.braceR)) {
            --braceStackCounter;
          }
          this.next();
        }
        return true;
      }
      if (this.match(types$1.bracketL)) {
        let braceStackCounter = 1;
        this.next();
        while (braceStackCounter > 0) {
          if (this.match(types$1.bracketL)) {
            ++braceStackCounter;
          } else if (this.match(types$1.bracketR)) {
            --braceStackCounter;
          }
          this.next();
        }
        return true;
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      this.next();
      if (this.match(types$1.parenR) || this.match(types$1.ellipsis)) {
        return true;
      }
      if (this.tsSkipParameterStart()) {
        if (this.match(types$1.colon) || this.match(types$1.comma) || this.match(types$1.question) || this.match(types$1.eq)) {
          return true;
        }
        if (this.match(types$1.parenR)) {
          this.next();
          if (this.match(types$1.arrow)) {
            return true;
          }
        }
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(returnToken);
        const node = this.startNode();
        const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (asserts && this.match(types$1._this)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
          if (thisTypePredicate.type === "TSThisType") {
            node.parameterName = thisTypePredicate;
            node.asserts = true;
            node.typeAnnotation = null;
            thisTypePredicate = this.finishNode(node, "TSTypePredicate");
          } else {
            this.resetStartLocationFromNode(thisTypePredicate, node);
            thisTypePredicate.asserts = true;
          }
          t.typeAnnotation = thisTypePredicate;
          return this.finishNode(t, "TSTypeAnnotation");
        }
        const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!typePredicateVariable) {
          if (!asserts) {
            return this.tsParseTypeAnnotation(false, t);
          }
          node.parameterName = this.parseIdentifier();
          node.asserts = asserts;
          node.typeAnnotation = null;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        }
        const type = this.tsParseTypeAnnotation(false);
        node.parameterName = typePredicateVariable;
        node.typeAnnotation = type;
        node.asserts = asserts;
        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
        return this.finishNode(t, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(types$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types$1.colon) : void 0;
    }
    tsTryParseTypeAnnotation() {
      return this.match(types$1.colon) ? this.tsParseTypeAnnotation() : void 0;
    }
    tsTryParseType() {
      return this.tsEatThenParseType(types$1.colon);
    }
    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier();
      if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
        this.next();
        return id;
      }
    }
    tsParseTypePredicateAsserts() {
      if (!this.match(types$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
        return false;
      }
      const containsEsc = this.state.containsEsc;
      this.next();
      if (!this.match(types$1.name) && !this.match(types$1._this)) {
        return false;
      }
      if (containsEsc) {
        this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
      }
      return true;
    }
    tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
      this.tsInType(() => {
        if (eatColon)
          this.expect(types$1.colon);
        t.typeAnnotation = this.tsParseType();
      });
      return this.finishNode(t, "TSTypeAnnotation");
    }
    tsParseType() {
      assert(this.state.inType);
      const type = this.tsParseNonConditionalType();
      if (this.hasPrecedingLineBreak() || !this.eat(types$1._extends)) {
        return type;
      }
      const node = this.startNodeAtNode(type);
      node.checkType = type;
      node.extendsType = this.tsParseNonConditionalType();
      this.expect(types$1.question);
      node.trueType = this.tsParseType();
      this.expect(types$1.colon);
      node.falseType = this.tsParseType();
      return this.finishNode(node, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual("abstract") && this.lookahead().type === types$1._new;
    }
    tsParseNonConditionalType() {
      if (this.tsIsStartOfFunctionType()) {
        return this.tsParseFunctionOrConstructorType("TSFunctionType");
      }
      if (this.match(types$1._new)) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType");
      } else if (this.isAbstractConstructorSignature()) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
      }
      return this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      const node = this.startNode();
      const _const = this.tsTryNextParseConstantContext();
      node.typeAnnotation = _const || this.tsNextThenParseType();
      this.expectRelational(">");
      node.expression = this.parseMaybeUnary();
      return this.finishNode(node, "TSTypeAssertion");
    }
    tsParseHeritageClause(descriptor) {
      const originalStart = this.state.start;
      const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
      if (!delimitedList.length) {
        this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
      }
      return delimitedList;
    }
    tsParseExpressionWithTypeArguments() {
      const node = this.startNode();
      node.expression = this.tsParseEntityName(false);
      if (this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }
      return this.finishNode(node, "TSExpressionWithTypeArguments");
    }
    tsParseInterfaceDeclaration(node) {
      if (this.match(types$1.name)) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
      } else {
        node.id = null;
        this.raise(this.state.start, TSErrors.MissingInterfaceName);
      }
      node.typeParameters = this.tsTryParseTypeParameters();
      if (this.eat(types$1._extends)) {
        node.extends = this.tsParseHeritageClause("extends");
      }
      const body = this.startNode();
      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
      node.body = this.finishNode(body, "TSInterfaceBody");
      return this.finishNode(node, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(node) {
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, "typescript type alias", BIND_TS_TYPE);
      node.typeParameters = this.tsTryParseTypeParameters();
      node.typeAnnotation = this.tsInType(() => {
        this.expect(types$1.eq);
        if (this.isContextual("intrinsic") && this.lookahead().type !== types$1.dot) {
          const node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      });
      this.semicolon();
      return this.finishNode(node, "TSTypeAliasDeclaration");
    }
    tsInNoContext(cb) {
      const oldContext = this.state.context;
      this.state.context = [oldContext[0]];
      try {
        return cb();
      } finally {
        this.state.context = oldContext;
      }
    }
    tsInType(cb) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      try {
        return cb();
      } finally {
        this.state.inType = oldInType;
      }
    }
    tsEatThenParseType(token) {
      return !this.match(token) ? void 0 : this.tsNextThenParseType();
    }
    tsExpectThenParseType(token) {
      return this.tsDoThenParseType(() => this.expect(token));
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(cb) {
      return this.tsInType(() => {
        cb();
        return this.tsParseType();
      });
    }
    tsParseEnumMember() {
      const node = this.startNode();
      node.id = this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
      if (this.eat(types$1.eq)) {
        node.initializer = this.parseMaybeAssignAllowIn();
      }
      return this.finishNode(node, "TSEnumMember");
    }
    tsParseEnumDeclaration(node, isConst) {
      if (isConst)
        node.const = true;
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
      this.expect(types$1.braceL);
      node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
      this.expect(types$1.braceR);
      return this.finishNode(node, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const node = this.startNode();
      this.scope.enter(SCOPE_OTHER);
      this.expect(types$1.braceL);
      this.parseBlockOrModuleBlockBody(node.body = [], void 0, true, types$1.braceR);
      this.scope.exit();
      return this.finishNode(node, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(node, nested = false) {
      node.id = this.parseIdentifier();
      if (!nested) {
        this.checkLVal(node.id, "module or namespace declaration", BIND_TS_NAMESPACE);
      }
      if (this.eat(types$1.dot)) {
        const inner = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(inner, true);
        node.body = inner;
      } else {
        this.scope.enter(SCOPE_TS_MODULE);
        this.prodParam.enter(PARAM);
        node.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      }
      return this.finishNode(node, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(node) {
      if (this.isContextual("global")) {
        node.global = true;
        node.id = this.parseIdentifier();
      } else if (this.match(types$1.string)) {
        node.id = this.parseExprAtom();
      } else {
        this.unexpected();
      }
      if (this.match(types$1.braceL)) {
        this.scope.enter(SCOPE_TS_MODULE);
        this.prodParam.enter(PARAM);
        node.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      } else {
        this.semicolon();
      }
      return this.finishNode(node, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(node, isExport) {
      node.isExport = isExport || false;
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, "import equals declaration", BIND_LEXICAL);
      this.expect(types$1.eq);
      const moduleReference = this.tsParseModuleReference();
      if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
        this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
      }
      node.moduleReference = moduleReference;
      this.semicolon();
      return this.finishNode(node, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual("require") && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const node = this.startNode();
      this.expectContextual("require");
      this.expect(types$1.parenL);
      if (!this.match(types$1.string)) {
        throw this.unexpected();
      }
      node.expression = this.parseExprAtom();
      this.expect(types$1.parenR);
      return this.finishNode(node, "TSExternalModuleReference");
    }
    tsLookAhead(f) {
      const state = this.state.clone();
      const res = f();
      this.state = state;
      return res;
    }
    tsTryParseAndCatch(f) {
      const result = this.tryParse((abort) => f() || abort());
      if (result.aborted || !result.node)
        return void 0;
      if (result.error)
        this.state = result.failState;
      return result.node;
    }
    tsTryParse(f) {
      const state = this.state.clone();
      const result = f();
      if (result !== void 0 && result !== false) {
        return result;
      } else {
        this.state = state;
        return void 0;
      }
    }
    tsTryParseDeclare(nany) {
      if (this.isLineTerminator()) {
        return;
      }
      let starttype = this.state.type;
      let kind;
      if (this.isContextual("let")) {
        starttype = types$1._var;
        kind = "let";
      }
      return this.tsInAmbientContext(() => {
        switch (starttype) {
          case types$1._function:
            nany.declare = true;
            return this.parseFunctionStatement(nany, false, true);
          case types$1._class:
            nany.declare = true;
            return this.parseClass(nany, true, false);
          case types$1._const:
            if (this.match(types$1._const) && this.isLookaheadContextual("enum")) {
              this.expect(types$1._const);
              this.expectContextual("enum");
              return this.tsParseEnumDeclaration(nany, true);
            }
          case types$1._var:
            kind = kind || this.state.value;
            return this.parseVarStatement(nany, kind);
          case types$1.name: {
            const value = this.state.value;
            if (value === "global") {
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            } else {
              return this.tsParseDeclaration(nany, value, true);
            }
          }
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }
    tsParseExpressionStatement(node, expr) {
      switch (expr.name) {
        case "declare": {
          const declaration = this.tsTryParseDeclare(node);
          if (declaration) {
            declaration.declare = true;
            return declaration;
          }
          break;
        }
        case "global":
          if (this.match(types$1.braceL)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            const mod = node;
            mod.global = true;
            mod.id = expr;
            mod.body = this.tsParseModuleBlock();
            this.scope.exit();
            this.prodParam.exit();
            return this.finishNode(mod, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(node, expr.name, false);
      }
    }
    tsParseDeclaration(node, value, next) {
      switch (value) {
        case "abstract":
          if (this.tsCheckLineTerminator(next) && (this.match(types$1._class) || this.match(types$1.name))) {
            return this.tsParseAbstractDeclaration(node);
          }
          break;
        case "enum":
          if (next || this.match(types$1.name)) {
            if (next)
              this.next();
            return this.tsParseEnumDeclaration(node, false);
          }
          break;
        case "interface":
          if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
            return this.tsParseInterfaceDeclaration(node);
          }
          break;
        case "module":
          if (this.tsCheckLineTerminator(next)) {
            if (this.match(types$1.string)) {
              return this.tsParseAmbientExternalModuleDeclaration(node);
            } else if (this.match(types$1.name)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
            return this.tsParseModuleOrNamespaceDeclaration(node);
          }
          break;
        case "type":
          if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
            return this.tsParseTypeAliasDeclaration(node);
          }
          break;
      }
    }
    tsCheckLineTerminator(next) {
      if (next) {
        if (this.hasFollowingLineBreak())
          return false;
        this.next();
        return true;
      }
      return !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
      if (!this.isRelational("<")) {
        return void 0;
      }
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const res = this.tsTryParseAndCatch(() => {
        const node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = this.tsParseTypeParameters();
        super.parseFunctionParams(node);
        node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
        this.expect(types$1.arrow);
        return node;
      });
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      if (!res) {
        return void 0;
      }
      return this.parseArrowExpression(res, null, true);
    }
    tsParseTypeArguments() {
      const node = this.startNode();
      node.params = this.tsInType(() => this.tsInNoContext(() => {
        this.expectRelational("<");
        return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
      }));
      if (node.params.length === 0) {
        this.raise(node.start, TSErrors.EmptyTypeArguments);
      }
      this.expectRelational(">");
      return this.finishNode(node, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      if (this.match(types$1.name)) {
        switch (this.state.value) {
          case "abstract":
          case "declare":
          case "enum":
          case "interface":
          case "module":
          case "namespace":
          case "type":
            return true;
        }
      }
      return false;
    }
    isExportDefaultSpecifier() {
      if (this.tsIsDeclarationStart())
        return false;
      return super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(allowModifiers, decorators) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let accessibility;
      let readonly2 = false;
      let override = false;
      if (allowModifiers !== void 0) {
        const modified = {};
        this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
        accessibility = modified.accessibility;
        override = modified.override;
        readonly2 = modified.readonly;
        if (allowModifiers === false && (accessibility || readonly2 || override)) {
          this.raise(startPos, TSErrors.UnexpectedParameterModifier);
        }
      }
      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
      if (accessibility || readonly2 || override) {
        const pp = this.startNodeAt(startPos, startLoc);
        if (decorators.length) {
          pp.decorators = decorators;
        }
        if (accessibility)
          pp.accessibility = accessibility;
        if (readonly2)
          pp.readonly = readonly2;
        if (override)
          pp.override = override;
        if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
          this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
        }
        pp.parameter = elt;
        return this.finishNode(pp, "TSParameterProperty");
      }
      if (decorators.length) {
        left.decorators = decorators;
      }
      return elt;
    }
    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      if (this.match(types$1.colon)) {
        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
      }
      const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : void 0;
      if (bodilessType && !this.match(types$1.braceL) && this.isLineTerminator()) {
        this.finishNode(node, bodilessType);
        return;
      }
      if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
        this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);
        if (node.declare) {
          super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
          return;
        }
      }
      super.parseFunctionBodyAndFinish(node, type, isMethod);
    }
    registerFunctionStatementId(node) {
      if (!node.body && node.id) {
        this.checkLVal(node.id, "function name", BIND_TS_AMBIENT);
      } else {
        super.registerFunctionStatementId(...arguments);
      }
    }
    tsCheckForInvalidTypeCasts(items) {
      items.forEach((node) => {
        if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
          this.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
        }
      });
    }
    toReferencedList(exprList, isInParens) {
      this.tsCheckForInvalidTypeCasts(exprList);
      return exprList;
    }
    parseArrayLike(...args) {
      const node = super.parseArrayLike(...args);
      if (node.type === "ArrayExpression") {
        this.tsCheckForInvalidTypeCasts(node.elements);
      }
      return node;
    }
    parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!this.hasPrecedingLineBreak() && this.match(types$1.bang)) {
        this.state.exprAllowed = false;
        this.next();
        const nonNullExpression = this.startNodeAt(startPos, startLoc);
        nonNullExpression.expression = base;
        return this.finishNode(nonNullExpression, "TSNonNullExpression");
      }
      let isOptionalCall = false;
      if (this.match(types$1.questionDot) && this.lookaheadCharCode() === 60) {
        if (noCalls) {
          state.stop = true;
          return base;
        }
        state.optionalChainMember = isOptionalCall = true;
        this.next();
      }
      if (this.isRelational("<")) {
        let missingParenErrorPos;
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
            if (asyncArrowFn) {
              return asyncArrowFn;
            }
          }
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const typeArguments = this.tsParseTypeArguments();
          if (typeArguments) {
            if (isOptionalCall && !this.match(types$1.parenL)) {
              missingParenErrorPos = this.state.pos;
              this.unexpected();
            }
            if (!noCalls && this.eat(types$1.parenL)) {
              node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
              this.tsCheckForInvalidTypeCasts(node.arguments);
              node.typeParameters = typeArguments;
              if (state.optionalChainMember) {
                node.optional = isOptionalCall;
              }
              return this.finishCallExpression(node, state.optionalChainMember);
            } else if (this.match(types$1.backQuote)) {
              const result2 = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
              result2.typeParameters = typeArguments;
              return result2;
            }
          }
          this.unexpected();
        });
        if (missingParenErrorPos) {
          this.unexpected(missingParenErrorPos, types$1.parenL);
        }
        if (result)
          return result;
      }
      return super.parseSubscript(base, startPos, startLoc, noCalls, state);
    }
    parseNewArguments(node) {
      if (this.isRelational("<")) {
        const typeParameters = this.tsTryParseAndCatch(() => {
          const args = this.tsParseTypeArguments();
          if (!this.match(types$1.parenL))
            this.unexpected();
          return args;
        });
        if (typeParameters) {
          node.typeParameters = typeParameters;
        }
      }
      super.parseNewArguments(node);
    }
    parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      if (nonNull(types$1._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
        const node = this.startNodeAt(leftStartPos, leftStartLoc);
        node.expression = left;
        const _const = this.tsTryNextParseConstantContext();
        if (_const) {
          node.typeAnnotation = _const;
        } else {
          node.typeAnnotation = this.tsNextThenParseType();
        }
        this.finishNode(node, "TSAsExpression");
        this.reScan_lt_gt();
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
      }
      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    }
    checkDuplicateExports() {
    }
    parseImport(node) {
      node.importKind = "value";
      if (this.match(types$1.name) || this.match(types$1.star) || this.match(types$1.braceL)) {
        let ahead = this.lookahead();
        if (this.isContextual("type") && ahead.type !== types$1.comma && !(ahead.type === types$1.name && ahead.value === "from") && ahead.type !== types$1.eq) {
          node.importKind = "type";
          this.next();
          ahead = this.lookahead();
        }
        if (this.match(types$1.name) && ahead.type === types$1.eq) {
          return this.tsParseImportEqualsDeclaration(node);
        }
      }
      const importNode = super.parseImport(node);
      if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
        this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);
      }
      return importNode;
    }
    parseExport(node) {
      if (this.match(types$1._import)) {
        this.next();
        if (this.isContextual("type") && this.lookaheadCharCode() !== 61) {
          node.importKind = "type";
          this.next();
        } else {
          node.importKind = "value";
        }
        return this.tsParseImportEqualsDeclaration(node, true);
      } else if (this.eat(types$1.eq)) {
        const assign = node;
        assign.expression = this.parseExpression();
        this.semicolon();
        return this.finishNode(assign, "TSExportAssignment");
      } else if (this.eatContextual("as")) {
        const decl = node;
        this.expectContextual("namespace");
        decl.id = this.parseIdentifier();
        this.semicolon();
        return this.finishNode(decl, "TSNamespaceExportDeclaration");
      } else {
        if (this.isContextual("type") && this.lookahead().type === types$1.braceL) {
          this.next();
          node.exportKind = "type";
        } else {
          node.exportKind = "value";
        }
        return super.parseExport(node);
      }
    }
    isAbstractClass() {
      return this.isContextual("abstract") && this.lookahead().type === types$1._class;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode();
        this.next();
        cls.abstract = true;
        this.parseClass(cls, true, true);
        return cls;
      }
      if (this.state.value === "interface") {
        const interfaceNode = this.startNode();
        this.next();
        const result = this.tsParseInterfaceDeclaration(interfaceNode);
        if (result)
          return result;
      }
      return super.parseExportDefaultExpression();
    }
    parseStatementContent(context, topLevel) {
      if (this.state.type === types$1._const) {
        const ahead = this.lookahead();
        if (ahead.type === types$1.name && ahead.value === "enum") {
          const node = this.startNode();
          this.expect(types$1._const);
          this.expectContextual("enum");
          return this.tsParseEnumDeclaration(node, true);
        }
      }
      return super.parseStatementContent(context, topLevel);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(member, modifiers) {
      return modifiers.some((modifier) => {
        if (tsIsAccessModifier(modifier)) {
          return member.accessibility === modifier;
        }
        return !!member[modifier];
      });
    }
    parseClassMember(classBody, member, state) {
      const invalidModifersForStaticBlocks = ["declare", "private", "public", "protected", "override", "abstract", "readonly"];
      this.tsParseModifiers(member, invalidModifersForStaticBlocks.concat(["static"]));
      const callParseClassMemberWithIsStatic = () => {
        const isStatic = !!member.static;
        if (isStatic && this.eat(types$1.braceL)) {
          if (this.tsHasSomeModifiers(member, invalidModifersForStaticBlocks)) {
            this.raise(this.state.pos, TSErrors.StaticBlockCannotHaveModifier);
          }
          this.parseClassStaticBlock(classBody, member);
        } else {
          this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
      };
      if (member.declare) {
        this.tsInAmbientContext(callParseClassMemberWithIsStatic);
      } else {
        callParseClassMemberWithIsStatic();
      }
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const idx = this.tsTryParseIndexSignature(member);
      if (idx) {
        classBody.body.push(idx);
        if (member.abstract) {
          this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
        }
        if (member.accessibility) {
          this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
        }
        if (member.declare) {
          this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
        }
        if (member.override) {
          this.raise(member.start, TSErrors.IndexSignatureHasOverride);
        }
        return;
      }
      if (!this.state.inAbstractClass && member.abstract) {
        this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);
      }
      if (member.override) {
        if (!state.hadSuperClass) {
          this.raise(member.start, TSErrors.OverrideNotInSubClass);
        }
      }
      super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parsePostMemberNameModifiers(methodOrProp) {
      const optional = this.eat(types$1.question);
      if (optional)
        methodOrProp.optional = true;
      if (methodOrProp.readonly && this.match(types$1.parenL)) {
        this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
      }
      if (methodOrProp.declare && this.match(types$1.parenL)) {
        this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
      }
    }
    parseExpressionStatement(node, expr) {
      const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
      return decl || super.parseExpressionStatement(node, expr);
    }
    shouldParseExportDeclaration() {
      if (this.tsIsDeclarationStart())
        return true;
      return super.shouldParseExportDeclaration();
    }
    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (!this.state.maybeInArrowParameters || !this.match(types$1.question)) {
        return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
      }
      const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));
      if (!result.node) {
        if (result.error) {
          super.setOptionalParametersError(refExpressionErrors, result.error);
        }
        return expr;
      }
      if (result.error)
        this.state = result.failState;
      return result.node;
    }
    parseParenItem(node, startPos, startLoc) {
      node = super.parseParenItem(node, startPos, startLoc);
      if (this.eat(types$1.question)) {
        node.optional = true;
        this.resetEndLocation(node);
      }
      if (this.match(types$1.colon)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TSTypeCastExpression");
      }
      return node;
    }
    parseExportDeclaration(node) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const isDeclare = this.eatContextual("declare");
      if (isDeclare && (this.isContextual("declare") || !this.shouldParseExportDeclaration())) {
        throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);
      }
      let declaration;
      if (this.match(types$1.name)) {
        declaration = this.tsTryParseExportDeclaration();
      }
      if (!declaration) {
        declaration = super.parseExportDeclaration(node);
      }
      if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
        node.exportKind = "type";
      }
      if (declaration && isDeclare) {
        this.resetStartLocation(declaration, startPos, startLoc);
        declaration.declare = true;
      }
      return declaration;
    }
    parseClassId(node, isStatement, optionalId) {
      if ((!isStatement || optionalId) && this.isContextual("implements")) {
        return;
      }
      super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters)
        node.typeParameters = typeParameters;
    }
    parseClassPropertyAnnotation(node) {
      if (!node.optional && this.eat(types$1.bang)) {
        node.definite = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        node.typeAnnotation = type;
    }
    parseClassProperty(node) {
      this.parseClassPropertyAnnotation(node);
      if (this.state.isAmbientContext && this.match(types$1.eq)) {
        this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
      }
      if (node.abstract && this.match(types$1.eq)) {
        const {
          key
        } = node;
        this.raise(this.state.start, TSErrors.AbstractPropertyHasInitializer, key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
      }
      return super.parseClassProperty(node);
    }
    parseClassPrivateProperty(node) {
      if (node.abstract) {
        this.raise(node.start, TSErrors.PrivateElementHasAbstract);
      }
      if (node.accessibility) {
        this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
      }
      this.parseClassPropertyAnnotation(node);
      return super.parseClassPrivateProperty(node);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters && isConstructor) {
        this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
      }
      if (method.declare && (method.kind === "get" || method.kind === "set")) {
        this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
      }
      if (typeParameters)
        method.typeParameters = typeParameters;
      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters)
        method.typeParameters = typeParameters;
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }
    parseClassSuper(node) {
      super.parseClassSuper(node);
      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.tsParseTypeArguments();
      }
      if (this.eatContextual("implements")) {
        node.implements = this.tsParseHeritageClause("implements");
      }
    }
    parseObjPropValue(prop, ...args) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters)
        prop.typeParameters = typeParameters;
      super.parseObjPropValue(prop, ...args);
    }
    parseFunctionParams(node, allowModifiers) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters)
        node.typeParameters = typeParameters;
      super.parseFunctionParams(node, allowModifiers);
    }
    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);
      if (decl.id.type === "Identifier" && this.eat(types$1.bang)) {
        decl.definite = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type) {
        decl.id.typeAnnotation = type;
        this.resetEndLocation(decl.id);
      }
    }
    parseAsyncArrowFromCallExpression(node, call) {
      if (this.match(types$1.colon)) {
        node.returnType = this.tsParseTypeAnnotation();
      }
      return super.parseAsyncArrowFromCallExpression(node, call);
    }
    parseMaybeAssign(...args) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
      let state;
      let jsx2;
      let typeCast;
      if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
        state = this.state.clone();
        jsx2 = this.tryParse(() => super.parseMaybeAssign(...args), state);
        if (!jsx2.error)
          return jsx2.node;
        const {
          context
        } = this.state;
        if (context[context.length - 1] === types.j_oTag) {
          context.length -= 2;
        } else if (context[context.length - 1] === types.j_expr) {
          context.length -= 1;
        }
      }
      if (!((_jsx = jsx2) != null && _jsx.error) && !this.isRelational("<")) {
        return super.parseMaybeAssign(...args);
      }
      let typeParameters;
      state = state || this.state.clone();
      const arrow = this.tryParse((abort) => {
        var _expr$extra, _typeParameters;
        typeParameters = this.tsParseTypeParameters();
        const expr = super.parseMaybeAssign(...args);
        if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          abort();
        }
        if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
          this.resetStartLocationFromNode(expr, typeParameters);
        }
        expr.typeParameters = typeParameters;
        return expr;
      }, state);
      if (!arrow.error && !arrow.aborted)
        return arrow.node;
      if (!jsx2) {
        assert(!this.hasPlugin("jsx"));
        typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);
        if (!typeCast.error)
          return typeCast.node;
      }
      if ((_jsx2 = jsx2) != null && _jsx2.node) {
        this.state = jsx2.failState;
        return jsx2.node;
      }
      if (arrow.node) {
        this.state = arrow.failState;
        return arrow.node;
      }
      if ((_typeCast = typeCast) != null && _typeCast.node) {
        this.state = typeCast.failState;
        return typeCast.node;
      }
      if ((_jsx3 = jsx2) != null && _jsx3.thrown)
        throw jsx2.error;
      if (arrow.thrown)
        throw arrow.error;
      if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
        throw typeCast.error;
      throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
    }
    parseMaybeUnary(refExpressionErrors) {
      if (!this.hasPlugin("jsx") && this.isRelational("<")) {
        return this.tsParseTypeAssertion();
      } else {
        return super.parseMaybeUnary(refExpressionErrors);
      }
    }
    parseArrow(node) {
      if (this.match(types$1.colon)) {
        const result = this.tryParse((abort) => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
          if (this.canInsertSemicolon() || !this.match(types$1.arrow))
            abort();
          return returnType;
        });
        if (result.aborted)
          return;
        if (!result.thrown) {
          if (result.error)
            this.state = result.failState;
          node.returnType = result.node;
        }
      }
      return super.parseArrow(node);
    }
    parseAssignableListItemTypes(param) {
      if (this.eat(types$1.question)) {
        if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
          this.raise(param.start, TSErrors.PatternIsOptional);
        }
        param.optional = true;
      }
      const type = this.tsTryParseTypeAnnotation();
      if (type)
        param.typeAnnotation = type;
      this.resetEndLocation(param);
      return param;
    }
    isAssignable(node, isBinding) {
      switch (node.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(node.expression, isBinding);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(node, isBinding);
      }
    }
    toAssignable(node, isLHS = false) {
      switch (node.type) {
        case "TSTypeCastExpression":
          return super.toAssignable(this.typeCastToParameter(node), isLHS);
        case "TSParameterProperty":
          return super.toAssignable(node, isLHS);
        case "ParenthesizedExpression":
          return this.toAssignableParenthesizedExpression(node, isLHS);
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          node.expression = this.toAssignable(node.expression, isLHS);
          return node;
        default:
          return super.toAssignable(node, isLHS);
      }
    }
    toAssignableParenthesizedExpression(node, isLHS) {
      switch (node.expression.type) {
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          node.expression = this.toAssignable(node.expression, isLHS);
          return node;
        default:
          return super.toAssignable(node, isLHS);
      }
    }
    checkLVal(expr, contextDescription, ...args) {
      var _expr$extra2;
      switch (expr.type) {
        case "TSTypeCastExpression":
          return;
        case "TSParameterProperty":
          this.checkLVal(expr.parameter, "parameter property", ...args);
          return;
        case "TSAsExpression":
        case "TSTypeAssertion":
          if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {
            this.raise(expr.start, ErrorMessages.InvalidLhs, contextDescription);
            break;
          }
          this.checkLVal(expr.expression, "parenthesized expression", ...args);
          return;
        case "TSNonNullExpression":
          this.checkLVal(expr.expression, contextDescription, ...args);
          return;
        default:
          super.checkLVal(expr, contextDescription, ...args);
          return;
      }
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case types$1._this:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.isRelational("<")) {
        const typeArguments = this.tsParseTypeArguments();
        if (this.match(types$1.parenL)) {
          const call = super.parseMaybeDecoratorArguments(expr);
          call.typeParameters = typeArguments;
          return call;
        }
        this.unexpected(this.state.start, types$1.parenL);
      }
      return super.parseMaybeDecoratorArguments(expr);
    }
    checkCommaAfterRest(close) {
      if (this.state.isAmbientContext && this.match(types$1.comma) && this.lookaheadCharCode() === close) {
        this.next();
      } else {
        super.checkCommaAfterRest(close);
      }
    }
    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(types$1.bang) || this.match(types$1.colon) || super.isClassProperty();
    }
    parseMaybeDefault(...args) {
      const node = super.parseMaybeDefault(...args);
      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
      }
      return node;
    }
    getTokenFromCode(code) {
      if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types$1.relational, 1);
      } else {
        return super.getTokenFromCode(code);
      }
    }
    reScan_lt_gt() {
      if (this.match(types$1.relational)) {
        const code = this.input.charCodeAt(this.state.start);
        if (code === 60 || code === 62) {
          this.state.pos -= 1;
          this.readToken_lt_gt(code);
        }
      }
    }
    toAssignableList(exprList) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        if (!expr)
          continue;
        switch (expr.type) {
          case "TSTypeCastExpression":
            exprList[i] = this.typeCastToParameter(expr);
            break;
          case "TSAsExpression":
          case "TSTypeAssertion":
            if (!this.state.maybeInArrowParameters) {
              exprList[i] = this.typeCastToParameter(expr);
            } else {
              this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
            }
            break;
        }
      }
      return super.toAssignableList(...arguments);
    }
    typeCastToParameter(node) {
      node.expression.typeAnnotation = node.typeAnnotation;
      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
      return node.expression;
    }
    shouldParseArrow(params) {
      if (this.match(types$1.colon)) {
        return params.every((expr) => this.isAssignable(expr, true));
      }
      return super.shouldParseArrow(params);
    }
    shouldParseAsyncArrow() {
      return this.match(types$1.colon) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(node) {
      if (this.isRelational("<")) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
        if (typeArguments)
          node.typeParameters = typeArguments;
      }
      return super.jsxParseOpeningElementAfterName(node);
    }
    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      const firstParam = params[0];
      const hasContextParam = firstParam && this.isThisParam(firstParam);
      return hasContextParam ? baseCount + 1 : baseCount;
    }
    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam();
      const type = this.tsTryParseTypeAnnotation();
      if (type) {
        param.typeAnnotation = type;
        this.resetEndLocation(param);
      }
      return param;
    }
    tsInAmbientContext(cb) {
      const oldIsAmbientContext = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return cb();
      } finally {
        this.state.isAmbientContext = oldIsAmbientContext;
      }
    }
    parseClass(node, ...args) {
      const oldInAbstractClass = this.state.inAbstractClass;
      this.state.inAbstractClass = !!node.abstract;
      try {
        return super.parseClass(node, ...args);
      } finally {
        this.state.inAbstractClass = oldInAbstractClass;
      }
    }
    tsParseAbstractDeclaration(node) {
      if (this.match(types$1._class)) {
        node.abstract = true;
        return this.parseClass(node, true, false);
      } else if (this.isContextual("interface")) {
        if (!this.hasFollowingLineBreak()) {
          node.abstract = true;
          this.raise(node.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);
          this.next();
          return this.tsParseInterfaceDeclaration(node);
        }
      } else {
        this.unexpected(null, types$1._class);
      }
    }
    parseMethod(...args) {
      const method = super.parseMethod(...args);
      if (method.abstract) {
        const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
        if (hasBody) {
          const {
            key
          } = method;
          this.raise(method.start, TSErrors.AbstractMethodHasImplementation, key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
        }
      }
      return method;
    }
    tsParseTypeParameterName() {
      const typeName = this.parseIdentifier();
      return typeName.name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }
      return super.parse();
    }
    getExpression() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }
      return super.getExpression();
    }
  };
  types$1.placeholder = new TokenType("%%", {
    startsExpr: true
  });
  var PlaceHolderErrors = makeErrorTemplates({
    ClassNameIsRequired: "A class name is required."
  }, ErrorCodes.SyntaxError);
  var placeholders = (superClass) => class extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(types$1.placeholder)) {
        const node = this.startNode();
        this.next();
        this.assertNoSpace("Unexpected space in placeholder.");
        node.name = super.parseIdentifier(true);
        this.assertNoSpace("Unexpected space in placeholder.");
        this.expect(types$1.placeholder);
        return this.finishPlaceholder(node, expectedNode);
      }
    }
    finishPlaceholder(node, expectedNode) {
      const isFinished = !!(node.expectedNode && node.type === "Placeholder");
      node.expectedNode = expectedNode;
      return isFinished ? node : this.finishNode(node, "Placeholder");
    }
    getTokenFromCode(code) {
      if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
        return this.finishOp(types$1.placeholder, 2);
      }
      return super.getTokenFromCode(...arguments);
    }
    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }
    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }
    checkReservedWord(word) {
      if (word !== void 0)
        super.checkReservedWord(...arguments);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }
    checkLVal(expr) {
      if (expr.type !== "Placeholder")
        super.checkLVal(...arguments);
    }
    toAssignable(node) {
      if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
        node.expectedNode = "Pattern";
        return node;
      }
      return super.toAssignable(...arguments);
    }
    isLet(context) {
      if (super.isLet(context)) {
        return true;
      }
      if (!this.isContextual("let")) {
        return false;
      }
      if (context)
        return false;
      const nextToken = this.lookahead();
      if (nextToken.type === types$1.placeholder) {
        return true;
      }
      return false;
    }
    verifyBreakContinue(node) {
      if (node.label && node.label.type === "Placeholder")
        return;
      super.verifyBreakContinue(...arguments);
    }
    parseExpressionStatement(node, expr) {
      if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
        return super.parseExpressionStatement(...arguments);
      }
      if (this.match(types$1.colon)) {
        const stmt = node;
        stmt.label = this.finishPlaceholder(expr, "Identifier");
        this.next();
        stmt.body = this.parseStatement("label");
        return this.finishNode(stmt, "LabeledStatement");
      }
      this.semicolon();
      node.name = expr.name;
      return this.finishPlaceholder(node, "Statement");
    }
    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }
    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }
    parseClass(node, isStatement, optionalId) {
      const type = isStatement ? "ClassDeclaration" : "ClassExpression";
      this.next();
      this.takeDecorators(node);
      const oldStrict = this.state.strict;
      const placeholder = this.parsePlaceholder("Identifier");
      if (placeholder) {
        if (this.match(types$1._extends) || this.match(types$1.placeholder) || this.match(types$1.braceL)) {
          node.id = placeholder;
        } else if (optionalId || !isStatement) {
          node.id = null;
          node.body = this.finishPlaceholder(placeholder, "ClassBody");
          return this.finishNode(node, type);
        } else {
          this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);
        }
      } else {
        this.parseClassId(node, isStatement, optionalId);
      }
      this.parseClassSuper(node);
      node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, type);
    }
    parseExport(node) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder)
        return super.parseExport(...arguments);
      if (!this.isContextual("from") && !this.match(types$1.comma)) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.finishPlaceholder(placeholder, "Declaration");
        return this.finishNode(node, "ExportNamedDeclaration");
      }
      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      specifier.exported = placeholder;
      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      return super.parseExport(node);
    }
    isExportDefaultSpecifier() {
      if (this.match(types$1._default)) {
        const next = this.nextTokenStart();
        if (this.isUnparsedContextual(next, "from")) {
          if (this.input.startsWith(types$1.placeholder.label, this.nextTokenStartSince(next + 4))) {
            return true;
          }
        }
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(node) {
      if (node.specifiers && node.specifiers.length > 0) {
        return true;
      }
      return super.maybeParseExportDefaultSpecifier(...arguments);
    }
    checkExport(node) {
      const {
        specifiers
      } = node;
      if (specifiers != null && specifiers.length) {
        node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
      }
      super.checkExport(node);
      node.specifiers = specifiers;
    }
    parseImport(node) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder)
        return super.parseImport(...arguments);
      node.specifiers = [];
      if (!this.isContextual("from") && !this.match(types$1.comma)) {
        node.source = this.finishPlaceholder(placeholder, "StringLiteral");
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      const specifier = this.startNodeAtNode(placeholder);
      specifier.local = placeholder;
      this.finishNode(specifier, "ImportDefaultSpecifier");
      node.specifiers.push(specifier);
      if (this.eat(types$1.comma)) {
        const hasStarImport = this.maybeParseStarImportSpecifier(node);
        if (!hasStarImport)
          this.parseNamedImportSpecifiers(node);
      }
      this.expectContextual("from");
      node.source = this.parseImportSource();
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }
  };
  var v8intrinsic = (superClass) => class extends superClass {
    parseV8Intrinsic() {
      if (this.match(types$1.modulo)) {
        const v8IntrinsicStart = this.state.start;
        const node = this.startNode();
        this.eat(types$1.modulo);
        if (this.match(types$1.name)) {
          const name = this.parseIdentifierName(this.state.start);
          const identifier = this.createIdentifier(node, name);
          identifier.type = "V8IntrinsicIdentifier";
          if (this.match(types$1.parenL)) {
            return identifier;
          }
        }
        this.unexpected(v8IntrinsicStart);
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }
  };
  function hasPlugin(plugins, name) {
    return plugins.some((plugin) => {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });
  }
  function getPluginOption(plugins, name, option) {
    const plugin = plugins.find((plugin2) => {
      if (Array.isArray(plugin2)) {
        return plugin2[0] === name;
      } else {
        return plugin2 === name;
      }
    });
    if (plugin && Array.isArray(plugin)) {
      return plugin[1][option];
    }
    return null;
  }
  var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
  var TOPIC_TOKENS = ["%", "#"];
  var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
  function validatePlugins(plugins) {
    if (hasPlugin(plugins, "decorators")) {
      if (hasPlugin(plugins, "decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }
      const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
      if (decoratorsBeforeExport == null) {
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
      } else if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }
    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }
    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }
    if (hasPlugin(plugins, "pipelineOperator")) {
      const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
      if (!PIPELINE_PROPOSALS.includes(proposal)) {
        const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
      }
      const tupleSyntaxIsHash = hasPlugin(plugins, "recordAndTuple") && getPluginOption(plugins, "recordAndTuple", "syntaxType") === "hash";
      if (proposal === "hack") {
        if (hasPlugin(plugins, "placeholders")) {
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        }
        if (hasPlugin(plugins, "v8intrinsic")) {
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        }
        const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
        if (!TOPIC_TOKENS.includes(topicToken)) {
          const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
        }
        if (topicToken === "#" && tupleSyntaxIsHash) {
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        }
      } else if (proposal === "smart" && tupleSyntaxIsHash) {
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
    }
    if (hasPlugin(plugins, "moduleAttributes")) {
      {
        if (hasPlugin(plugins, "importAssertions")) {
          throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
        }
        const moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
        if (moduleAttributesVerionPluginOption !== "may-2020") {
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
        }
      }
    }
    if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
    }
    if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
      const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      error.missingPlugins = "doExpressions";
      throw error;
    }
  }
  var mixinPlugins = {
    estree,
    jsx,
    flow,
    typescript,
    v8intrinsic,
    placeholders
  };
  var mixinPluginNames = Object.keys(mixinPlugins);
  var defaultOptions = {
    sourceType: "script",
    sourceFilename: void 0,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false,
    attachComment: true
  };
  function getOptions(opts) {
    const options = {};
    for (const key of Object.keys(defaultOptions)) {
      options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
    }
    return options;
  }
  var unwrapParenthesizedExpression = (node) => {
    return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
  };
  var LValParser = class extends NodeUtils {
    toAssignable(node, isLHS = false) {
      var _node$extra, _node$extra3;
      let parenthesized = void 0;
      if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
        parenthesized = unwrapParenthesizedExpression(node);
        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          } else if (parenthesized.type !== "MemberExpression") {
            this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          }
        } else {
          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
        }
      }
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node.type = "ObjectPattern";
          for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;
            const prop = node.properties[i];
            const isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
            if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingComma) {
              this.raiseRestNotLast(node.extra.trailingComma);
            }
          }
          break;
        case "ObjectProperty":
          this.toAssignable(node.value, isLHS);
          break;
        case "SpreadElement": {
          this.checkToRestConversion(node);
          node.type = "RestElement";
          const arg = node.argument;
          this.toAssignable(arg, isLHS);
          break;
        }
        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
          break;
        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
          }
          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isLHS);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }
      return node;
    }
    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        const error = prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
        this.raise(prop.key.start, error);
      } else if (prop.type === "SpreadElement" && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop, isLHS);
      }
    }
    toAssignableList(exprList, trailingCommaPos, isLHS) {
      let end = exprList.length;
      if (end) {
        const last = exprList[end - 1];
        if ((last == null ? void 0 : last.type) === "RestElement") {
          --end;
        } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
          last.type = "RestElement";
          let arg = last.argument;
          this.toAssignable(arg, isLHS);
          arg = unwrapParenthesizedExpression(arg);
          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
            this.unexpected(arg.start);
          }
          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }
          --end;
        }
      }
      for (let i = 0; i < end; i++) {
        const elt = exprList[i];
        if (elt) {
          this.toAssignable(elt, isLHS);
          if (elt.type === "RestElement") {
            this.raiseRestNotLast(elt.start);
          }
        }
      }
      return exprList;
    }
    isAssignable(node, isBinding) {
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const last = node.properties.length - 1;
          return node.properties.every((prop, i) => {
            return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
          });
        }
        case "ObjectProperty":
          return this.isAssignable(node.value);
        case "SpreadElement":
          return this.isAssignable(node.argument);
        case "ArrayExpression":
          return node.elements.every((element) => element === null || this.isAssignable(element));
        case "AssignmentExpression":
          return node.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(node.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;
        default:
          return false;
      }
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      for (const expr of exprList) {
        if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    }
    parseSpread(refExpressionErrors, refNeedsArrowPos) {
      const node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos);
      return this.finishNode(node, "SpreadElement");
    }
    parseRestBinding() {
      const node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case types$1.bracketL: {
          const node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types$1.bracketR, 93, true);
          return this.finishNode(node, "ArrayPattern");
        }
        case types$1.braceL:
          return this.parseObjectLike(types$1.braceR, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      const elts = [];
      let first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
        }
        if (allowEmpty && this.match(types$1.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types$1.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          const decorators = [];
          if (this.match(types$1.at) && this.hasPlugin("decorators")) {
            this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
          }
          while (this.match(types$1.at)) {
            decorators.push(this.parseDecorator());
          }
          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }
      return elts;
    }
    parseAssignableListItem(allowModifiers, decorators) {
      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
      if (decorators.length) {
        left.decorators = decorators;
      }
      return elt;
    }
    parseAssignableListItemTypes(param) {
      return param;
    }
    parseMaybeDefault(startPos, startLoc, left) {
      var _startLoc, _startPos, _left;
      startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
      startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
      left = (_left = left) != null ? _left : this.parseBindingAtom();
      if (!this.eat(types$1.eq))
        return left;
      const node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, "AssignmentPattern");
    }
    checkLVal(expr, contextDescription, bindingType = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged = false) {
      switch (expr.type) {
        case "Identifier": {
          const {
            name
          } = expr;
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {
            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);
          }
          if (checkClashes) {
            if (checkClashes.has(name)) {
              this.raise(expr.start, ErrorMessages.ParamDupe);
            } else {
              checkClashes.add(name);
            }
          }
          if (disallowLetBinding && name === "let") {
            this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
          }
          if (!(bindingType & BIND_NONE)) {
            this.scope.declareName(name, bindingType, expr.start);
          }
          break;
        }
        case "MemberExpression":
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
          }
          break;
        case "ObjectPattern":
          for (let prop of expr.properties) {
            if (this.isObjectProperty(prop))
              prop = prop.value;
            else if (this.isObjectMethod(prop))
              continue;
            this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
          }
          break;
        case "ArrayPattern":
          for (const elem of expr.elements) {
            if (elem) {
              this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
            }
          }
          break;
        case "AssignmentPattern":
          this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
          break;
        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
          break;
        default: {
          this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
        }
      }
    }
    checkToRestConversion(node) {
      if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
        this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
      }
    }
    checkCommaAfterRest(close) {
      if (this.match(types$1.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    }
    raiseRestNotLast(pos) {
      throw this.raise(pos, ErrorMessages.ElementAfterRest);
    }
    raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, ErrorMessages.RestTrailingComma);
    }
  };
  var ExpressionParser = class extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return;
      }
      const key = prop.key;
      const name = key.type === "Identifier" ? key.name : key.value;
      if (name === "__proto__") {
        if (isRecord) {
          this.raise(key.start, ErrorMessages.RecordNoProto);
          return;
        }
        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProto === -1) {
              refExpressionErrors.doubleProto = key.start;
            }
          } else {
            this.raise(key.start, ErrorMessages.DuplicateProto);
          }
        }
        protoRef.used = true;
      }
    }
    shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    }
    getExpression() {
      this.enterInitialScopes();
      this.nextToken();
      const expr = this.parseExpression();
      if (!this.match(types$1.eof)) {
        this.unexpected();
      }
      this.finalizeRemainingComments();
      expr.comments = this.state.comments;
      expr.errors = this.state.errors;
      if (this.options.tokens) {
        expr.tokens = this.tokens;
      }
      return expr;
    }
    parseExpression(disallowIn, refExpressionErrors) {
      if (disallowIn) {
        return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }
    parseExpressionBase(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const expr = this.parseMaybeAssign(refExpressionErrors);
      if (this.match(types$1.comma)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types$1.comma)) {
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }
        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    }
    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }
    setOptionalParametersError(refExpressionErrors, resultError) {
      var _resultError$pos;
      refExpressionErrors.optionalParameters = (_resultError$pos = resultError == null ? void 0 : resultError.pos) != null ? _resultError$pos : this.state.start;
    }
    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      if (this.isContextual("yield")) {
        if (this.prodParam.hasYield) {
          let left2 = this.parseYield();
          if (afterLeftParse) {
            left2 = afterLeftParse.call(this, left2, startPos, startLoc);
          }
          return left2;
        }
      }
      let ownExpressionErrors;
      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }
      if (this.match(types$1.parenL) || this.match(types$1.name)) {
        this.state.potentialArrowAt = this.state.start;
      }
      let left = this.parseMaybeConditional(refExpressionErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.state.type.isAssign) {
        const node = this.startNodeAt(startPos, startLoc);
        const operator = this.state.value;
        node.operator = operator;
        const leftIsHackPipeExpression = left.type === "BinaryExpression" && left.operator === "|>" && this.getPluginOption("pipelineOperator", "proposal") === "hack";
        if (leftIsHackPipeExpression) {
          throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, operator);
        }
        if (this.match(types$1.eq)) {
          node.left = this.toAssignable(left, true);
          refExpressionErrors.doubleProto = -1;
        } else {
          node.left = left;
        }
        if (refExpressionErrors.shorthandAssign >= node.left.start) {
          refExpressionErrors.shorthandAssign = -1;
        }
        this.checkLVal(left, "assignment expression");
        this.next();
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentExpression");
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      return left;
    }
    parseMaybeConditional(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprOps(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
    }
    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (this.eat(types$1.question)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssignAllowIn();
        this.expect(types$1.colon);
        node.alternate = this.parseMaybeAssign();
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    }
    parseExprOps(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseMaybeUnary(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseExprOp(expr, startPos, startLoc, -1);
    }
    parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      let prec = this.state.type.binop;
      if (prec != null && (this.prodParam.hasIn || !this.match(types$1._in))) {
        if (prec > minPrec) {
          const op = this.state.type;
          if (op === types$1.pipeline) {
            this.expectPlugin("pipelineOperator");
            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }
            this.checkPipelineAtInfixOperator(left, leftStartPos);
          }
          const node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.state.value;
          const logical = op === types$1.logicalOR || op === types$1.logicalAND;
          const coalesce = op === types$1.nullishCoalescing;
          if (coalesce) {
            prec = types$1.logicalAND.binop;
          }
          this.next();
          if (op === types$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
            if (this.match(types$1.name) && this.state.value === "await" && this.prodParam.hasAwait) {
              throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
            }
          }
          node.right = this.parseExprOpRightExpr(op, prec);
          this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          const nextOp = this.state.type;
          if (coalesce && (nextOp === types$1.logicalOR || nextOp === types$1.logicalAND) || logical && nextOp === types$1.nullishCoalescing) {
            throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
          }
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }
      }
      return left;
    }
    parseExprOpRightExpr(op, prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      switch (op) {
        case types$1.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => {
                const bodyExpr = this.parseHackPipeBody(op, prec);
                this.checkHackPipeBodyEarlyErrors(startPos);
                return bodyExpr;
              });
            case "smart":
              return this.withTopicBindingContext(() => {
                const childExpr = this.parseHackPipeBody(op, prec);
                return this.parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => {
                return this.parseFSharpPipelineBody(prec);
              });
          }
        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }
    parseExprOpBaseRightExpr(op, prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);
    }
    parseHackPipeBody(op, prec) {
      const bodyIsInGeneratorContext = this.prodParam.hasYield;
      const bodyIsYieldExpression = bodyIsInGeneratorContext && this.isContextual("yield");
      if (bodyIsYieldExpression) {
        throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, this.state.value);
      } else {
        return this.parseExprOpBaseRightExpr(op, prec);
      }
    }
    checkExponentialAfterUnary(node) {
      if (this.match(types$1.exponent)) {
        this.raise(node.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
      }
    }
    parseMaybeUnary(refExpressionErrors, sawUnary) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const isAwait = this.isContextual("await");
      if (isAwait && this.isAwaitAllowed()) {
        this.next();
        const expr2 = this.parseAwait(startPos, startLoc);
        if (!sawUnary)
          this.checkExponentialAfterUnary(expr2);
        return expr2;
      }
      const update = this.match(types$1.incDec);
      const node = this.startNode();
      if (this.state.type.prefix) {
        node.operator = this.state.value;
        node.prefix = true;
        if (this.match(types$1._throw)) {
          this.expectPlugin("throwExpressions");
        }
        const isDelete = this.match(types$1._delete);
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);
        if (this.state.strict && isDelete) {
          const arg = node.argument;
          if (arg.type === "Identifier") {
            this.raise(node.start, ErrorMessages.StrictDelete);
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(node.start, ErrorMessages.DeletePrivateField);
          }
        }
        if (!update) {
          if (!sawUnary)
            this.checkExponentialAfterUnary(node);
          return this.finishNode(node, "UnaryExpression");
        }
      }
      const expr = this.parseUpdate(node, update, refExpressionErrors);
      if (isAwait) {
        const startsExpr2 = this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(types$1.modulo);
        if (startsExpr2 && !this.isAmbiguousAwait()) {
          this.raiseOverwrite(startPos, ErrorMessages.AwaitNotInAsyncContext);
          return this.parseAwait(startPos, startLoc);
        }
      }
      return expr;
    }
    parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        this.checkLVal(node.argument, "prefix operation");
        return this.finishNode(node, "UpdateExpression");
      }
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false))
        return expr;
      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        const node2 = this.startNodeAt(startPos, startLoc);
        node2.operator = this.state.value;
        node2.prefix = false;
        node2.argument = expr;
        this.checkLVal(expr, "postfix operation");
        this.next();
        expr = this.finishNode(node2, "UpdateExpression");
      }
      return expr;
    }
    parseExprSubscripts(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprAtom(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseSubscripts(expr, startPos, startLoc);
    }
    parseSubscripts(base, startPos, startLoc, noCalls) {
      const state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };
      do {
        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);
      return base;
    }
    parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types$1.doubleColon)) {
        return this.parseBind(base, startPos, startLoc, noCalls, state);
      } else if (this.match(types$1.backQuote)) {
        return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
      }
      let optional = false;
      if (this.match(types$1.questionDot)) {
        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }
        state.optionalChainMember = optional = true;
        this.next();
      }
      if (!noCalls && this.match(types$1.parenL)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
      } else if (optional || this.match(types$1.bracketL) || this.eat(types$1.dot)) {
        return this.parseMember(base, startPos, startLoc, state, optional);
      } else {
        state.stop = true;
        return base;
      }
    }
    parseMember(base, startPos, startLoc, state, optional) {
      const node = this.startNodeAt(startPos, startLoc);
      const computed2 = this.eat(types$1.bracketL);
      node.object = base;
      node.computed = computed2;
      const privateName = !computed2 && this.match(types$1.privateName) && this.state.value;
      const property = computed2 ? this.parseExpression() : privateName ? this.parsePrivateName() : this.parseIdentifier(true);
      if (privateName !== false) {
        if (node.object.type === "Super") {
          this.raise(startPos, ErrorMessages.SuperPrivateField);
        }
        this.classScope.usePrivateName(privateName, property.start);
      }
      node.property = property;
      if (computed2) {
        this.expect(types$1.bracketR);
      }
      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    }
    parseBind(base, startPos, startLoc, noCalls, state) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    }
    parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      let refExpressionErrors = null;
      this.state.maybeInArrowParameters = true;
      this.next();
      let node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      if (state.maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
        refExpressionErrors = new ExpressionErrors();
      }
      if (state.optionalChainMember) {
        node.optional = optional;
      }
      if (optional) {
        node.arguments = this.parseCallExpressionArguments(types$1.parenR);
      } else {
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
      }
      this.finishCallExpression(node, state.optionalChainMember);
      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
      } else {
        if (state.maybeAsyncArrow) {
          this.checkExpressionErrors(refExpressionErrors, true);
          this.expressionScope.exit();
        }
        this.toReferencedArguments(node);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }
    toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }
    parseTaggedTemplateExpression(base, startPos, startLoc, state) {
      const node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);
      if (state.optionalChainMember) {
        this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
      }
      return this.finishNode(node, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    }
    finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length === 2) {
          {
            if (!this.hasPlugin("moduleAttributes")) {
              this.expectPlugin("importAssertions");
            }
          }
        }
        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
        } else {
          for (const arg of node.arguments) {
            if (arg.type === "SpreadElement") {
              this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
            }
          }
        }
      }
      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
      const elts = [];
      let first = true;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
          if (this.match(close)) {
            if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
              this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
            }
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
      }
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }
    shouldParseAsyncArrow() {
      return this.match(types$1.arrow) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;
      this.resetPreviousNodeTrailingComments(call);
      this.expect(types$1.arrow);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
      setInnerComments(node, call.innerComments);
      setInnerComments(node, call.callee.trailingComments);
      return node;
    }
    parseNoCallExpr() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    }
    parseExprAtom(refExpressionErrors) {
      let node;
      switch (this.state.type) {
        case types$1._super:
          return this.parseSuper();
        case types$1._import:
          node = this.startNode();
          this.next();
          if (this.match(types$1.dot)) {
            return this.parseImportMetaProperty(node);
          }
          if (!this.match(types$1.parenL)) {
            this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
          }
          return this.finishNode(node, "Import");
        case types$1._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types$1.name: {
          if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
            return this.parseModuleExpression();
          }
          const canBeArrow = this.state.potentialArrowAt === this.state.start;
          const containsEsc = this.state.containsEsc;
          const id = this.parseIdentifier();
          if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
            if (this.match(types$1._function)) {
              this.resetPreviousNodeTrailingComments(id);
              this.next();
              return this.parseFunction(this.startNodeAtNode(id), void 0, true);
            } else if (this.match(types$1.name)) {
              if (this.lookaheadCharCode() === 61) {
                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
              } else {
                return id;
              }
            } else if (this.match(types$1._do)) {
              this.resetPreviousNodeTrailingComments(id);
              return this.parseDo(this.startNodeAtNode(id), true);
            }
          }
          if (canBeArrow && this.match(types$1.arrow) && !this.canInsertSemicolon()) {
            this.next();
            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
          }
          return id;
        }
        case types$1._do: {
          return this.parseDo(this.startNode(), false);
        }
        case types$1.slash:
        case types$1.slashAssign: {
          this.readRegexp();
          return this.parseRegExpLiteral(this.state.value);
        }
        case types$1.num:
          return this.parseNumericLiteral(this.state.value);
        case types$1.bigint:
          return this.parseBigIntLiteral(this.state.value);
        case types$1.decimal:
          return this.parseDecimalLiteral(this.state.value);
        case types$1.string:
          return this.parseStringLiteral(this.state.value);
        case types$1._null:
          return this.parseNullLiteral();
        case types$1._true:
          return this.parseBooleanLiteral(true);
        case types$1._false:
          return this.parseBooleanLiteral(false);
        case types$1.parenL: {
          const canBeArrow = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(canBeArrow);
        }
        case types$1.bracketBarL:
        case types$1.bracketHashL: {
          return this.parseArrayLike(this.state.type === types$1.bracketBarL ? types$1.bracketBarR : types$1.bracketR, false, true, refExpressionErrors);
        }
        case types$1.bracketL: {
          return this.parseArrayLike(types$1.bracketR, true, false, refExpressionErrors);
        }
        case types$1.braceBarL:
        case types$1.braceHashL: {
          return this.parseObjectLike(this.state.type === types$1.braceBarL ? types$1.braceBarR : types$1.braceR, false, true, refExpressionErrors);
        }
        case types$1.braceL: {
          return this.parseObjectLike(types$1.braceR, false, false, refExpressionErrors);
        }
        case types$1._function:
          return this.parseFunctionOrFunctionSent();
        case types$1.at:
          this.parseDecorators();
        case types$1._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);
        case types$1._new:
          return this.parseNewOrNewTarget();
        case types$1.backQuote:
          return this.parseTemplate(false);
        case types$1.doubleColon: {
          node = this.startNode();
          this.next();
          node.object = null;
          const callee = node.callee = this.parseNoCallExpr();
          if (callee.type === "MemberExpression") {
            return this.finishNode(node, "BindExpression");
          } else {
            throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
          }
        }
        case types$1.privateName: {
          const {
            value,
            start
          } = this.state;
          node = this.parsePrivateName();
          if (this.match(types$1._in)) {
            this.classScope.usePrivateName(value, start);
          } else {
            this.raise(start, ErrorMessages.PrivateInExpectedIn, value);
          }
          return node;
        }
        case types$1.moduloAssign:
          if (this.getPluginOption("pipelineOperator", "proposal") === "hack" && this.getPluginOption("pipelineOperator", "topicToken") === "%") {
            this.state.value = "%";
            this.state.type = types$1.modulo;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc.column--;
          } else {
            throw this.unexpected();
          }
        case types$1.modulo:
        case types$1.hash: {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            node = this.startNode();
            const start = this.state.start;
            const tokenType = this.state.type;
            this.next();
            return this.finishTopicReference(node, start, pipeProposal, tokenType);
          }
        }
        case types$1.relational: {
          if (this.state.value === "<") {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
            }
          }
        }
        default:
          throw this.unexpected();
      }
    }
    finishTopicReference(node, start, pipeProposal, tokenType) {
      if (this.testTopicReferenceConfiguration(pipeProposal, start, tokenType)) {
        let nodeType;
        if (pipeProposal === "smart") {
          nodeType = "PipelinePrimaryTopicReference";
        } else {
          nodeType = "TopicReference";
        }
        if (!this.topicReferenceIsAllowedInCurrentContext()) {
          if (pipeProposal === "smart") {
            this.raise(start, ErrorMessages.PrimaryTopicNotAllowed);
          } else {
            this.raise(start, ErrorMessages.PipeTopicUnbound);
          }
        }
        this.registerTopicReference();
        return this.finishNode(node, nodeType);
      } else {
        throw this.raise(start, ErrorMessages.PipeTopicUnconfiguredToken, tokenType.label);
      }
    }
    testTopicReferenceConfiguration(pipeProposal, start, tokenType) {
      switch (pipeProposal) {
        case "hack": {
          const pluginTopicToken = this.getPluginOption("pipelineOperator", "topicToken");
          return tokenType.label === pluginTopicToken;
        }
        case "smart":
          return tokenType === types$1.hash;
        default:
          throw this.raise(start, ErrorMessages.PipeTopicRequiresHackPipes);
      }
    }
    parseAsyncArrowUnaryFunction(node) {
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      const params = [this.parseIdentifier()];
      this.prodParam.exit();
      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
      }
      this.expect(types$1.arrow);
      this.parseArrowExpression(node, params, true);
      return node;
    }
    parseDo(node, isAsync) {
      this.expectPlugin("doExpressions");
      if (isAsync) {
        this.expectPlugin("asyncDoExpressions");
      }
      node.async = isAsync;
      this.next();
      const oldLabels = this.state.labels;
      this.state.labels = [];
      if (isAsync) {
        this.prodParam.enter(PARAM_AWAIT);
        node.body = this.parseBlock();
        this.prodParam.exit();
      } else {
        node.body = this.parseBlock();
      }
      this.state.labels = oldLabels;
      return this.finishNode(node, "DoExpression");
    }
    parseSuper() {
      const node = this.startNode();
      this.next();
      if (this.match(types$1.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.SuperNotAllowed);
      } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.UnexpectedSuper);
      }
      if (!this.match(types$1.parenL) && !this.match(types$1.bracketL) && !this.match(types$1.dot)) {
        this.raise(node.start, ErrorMessages.UnsupportedSuper);
      }
      return this.finishNode(node, "Super");
    }
    parseMaybePrivateName(isPrivateNameAllowed) {
      const isPrivate = this.match(types$1.privateName);
      if (isPrivate) {
        if (!isPrivateNameAllowed) {
          this.raise(this.state.start + 1, ErrorMessages.UnexpectedPrivateField);
        }
        return this.parsePrivateName();
      } else {
        return this.parseIdentifier(true);
      }
    }
    parsePrivateName() {
      const node = this.startNode();
      const id = this.startNodeAt(this.state.start + 1, new Position8(this.state.curLine, this.state.start + 1 - this.state.lineStart));
      const name = this.state.value;
      this.next();
      node.id = this.createIdentifier(id, name);
      return this.finishNode(node, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const node = this.startNode();
      this.next();
      if (this.prodParam.hasYield && this.match(types$1.dot)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        this.next();
        return this.parseMetaProperty(node, meta, "sent");
      }
      return this.parseFunction(node);
    }
    parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;
      if (meta.name === "function" && propertyName === "sent") {
        if (this.isContextual(propertyName)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
      }
      const containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);
      if (node.property.name !== propertyName || containsEsc) {
        this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
      }
      return this.finishNode(node, "MetaProperty");
    }
    parseImportMetaProperty(node) {
      const id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.next();
      if (this.isContextual("meta")) {
        if (!this.inModule) {
          this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);
        }
        this.sawUnambiguousESM = true;
      }
      return this.parseMetaProperty(node, id, "meta");
    }
    parseLiteralAtNode(value, type, node) {
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    }
    parseLiteral(value, type) {
      const node = this.startNode();
      return this.parseLiteralAtNode(value, type, node);
    }
    parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    }
    parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    }
    parseBigIntLiteral(value) {
      return this.parseLiteral(value, "BigIntLiteral");
    }
    parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    }
    parseRegExpLiteral(value) {
      const node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;
    }
    parseBooleanLiteral(value) {
      const node = this.startNode();
      node.value = value;
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    }
    parseNullLiteral() {
      const node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      const innerStartPos = this.state.start;
      const innerStartLoc = this.state.startLoc;
      const exprList = [];
      const refExpressionErrors = new ExpressionErrors();
      let first = true;
      let spreadStart;
      let optionalCommaStart;
      while (!this.match(types$1.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma, refExpressionErrors.optionalParameters === -1 ? null : refExpressionErrors.optionalParameters);
          if (this.match(types$1.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }
        if (this.match(types$1.ellipsis)) {
          const spreadNodeStartPos = this.state.start;
          const spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
        }
      }
      const innerEndPos = this.state.lastTokEnd;
      const innerEndLoc = this.state.lastTokEndLoc;
      this.expect(types$1.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startPos, startLoc);
      if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }
      this.expressionScope.exit();
      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }
      if (optionalCommaStart)
        this.unexpected(optionalCommaStart);
      if (spreadStart)
        this.unexpected(spreadStart);
      this.checkExpressionErrors(refExpressionErrors, true);
      this.toReferencedListDeep(exprList, true);
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNode(val, "SequenceExpression");
        val.end = innerEndPos;
        val.loc.end = innerEndLoc;
      } else {
        val = exprList[0];
      }
      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, "parenthesized", true);
        this.addExtra(val, "parenStart", startPos);
        return val;
      }
      const parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, "ParenthesizedExpression");
      return parenExpression;
    }
    shouldParseArrow(params) {
      return !this.canInsertSemicolon();
    }
    parseArrow(node) {
      if (this.eat(types$1.arrow)) {
        return node;
      }
    }
    parseParenItem(node, startPos, startLoc) {
      return node;
    }
    parseNewOrNewTarget() {
      const node = this.startNode();
      this.next();
      if (this.match(types$1.dot)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        const metaProp = this.parseMetaProperty(node, meta, "target");
        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);
        }
        return metaProp;
      }
      return this.parseNew(node);
    }
    parseNew(node) {
      node.callee = this.parseNoCallExpr();
      if (node.callee.type === "Import") {
        this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
      } else if (this.isOptionalChain(node.callee)) {
        this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
      } else if (this.eat(types$1.questionDot)) {
        this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
      }
      this.parseNewArguments(node);
      return this.finishNode(node, "NewExpression");
    }
    parseNewArguments(node) {
      if (this.eat(types$1.parenL)) {
        const args = this.parseExprList(types$1.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    }
    parseTemplateElement(isTagged) {
      const elem = this.startNode();
      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
        }
      }
      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types$1.backQuote);
      return this.finishNode(elem, "TemplateElement");
    }
    parseTemplate(isTagged) {
      const node = this.startNode();
      this.next();
      node.expressions = [];
      let curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];
      while (!curElt.tail) {
        this.expect(types$1.dollarBraceL);
        node.expressions.push(this.parseTemplateSubstitution());
        this.expect(types$1.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const propHash = Object.create(null);
      let first = true;
      const node = this.startNode();
      node.properties = [];
      this.next();
      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
          if (this.match(close)) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart);
            break;
          }
        }
        const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);
        if (!isPattern) {
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }
        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
        }
        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }
        node.properties.push(prop);
      }
      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let type = "ObjectExpression";
      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }
      return this.finishNode(node, type);
    }
    maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(types$1.bracketL) || this.match(types$1.star));
    }
    parsePropertyDefinition(isPattern, refExpressionErrors) {
      let decorators = [];
      if (this.match(types$1.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
        }
        while (this.match(types$1.at)) {
          decorators.push(this.parseDecorator());
        }
      }
      const prop = this.startNode();
      let isGenerator = false;
      let isAsync = false;
      let isAccessor = false;
      let startPos;
      let startLoc;
      if (this.match(types$1.ellipsis)) {
        if (decorators.length)
          this.unexpected();
        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }
        return this.parseSpread();
      }
      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }
      prop.method = false;
      if (isPattern || refExpressionErrors) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }
      if (!isPattern) {
        isGenerator = this.eat(types$1.star);
      }
      const containsEsc = this.state.containsEsc;
      const key = this.parsePropertyName(prop, false);
      if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        const keyName = key.name;
        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          this.resetPreviousNodeTrailingComments(key);
          isGenerator = this.eat(types$1.star);
          this.parsePropertyName(prop, false);
        }
        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          this.resetPreviousNodeTrailingComments(key);
          prop.kind = keyName;
          if (this.match(types$1.star)) {
            isGenerator = true;
            this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
            this.next();
          }
          this.parsePropertyName(prop, false);
        }
      }
      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      return prop;
    }
    getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(method) {
      return method.params;
    }
    checkGetterSetterParams(method) {
      var _params;
      const paramCount = this.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      const start = method.start;
      if (params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }
      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(prop);
        return prop;
      }
      if (isAsync || isGenerator || this.match(types$1.parenL)) {
        if (isPattern)
          this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    }
    parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;
      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }
      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, false);
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
        } else if (this.match(types$1.eq) && refExpressionErrors) {
          if (refExpressionErrors.shorthandAssign === -1) {
            refExpressionErrors.shorthandAssign = this.state.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
        } else {
          prop.value = cloneIdentifier(prop.key);
        }
        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    }
    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      if (!node)
        this.unexpected();
      return node;
    }
    parsePropertyName(prop, isPrivateNameAllowed) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(types$1.bracketR);
      } else {
        const oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        const type = this.state.type;
        prop.key = type === types$1.num || type === types$1.string || type === types$1.bigint || type === types$1.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);
        if (type !== types$1.privateName) {
          prop.computed = false;
        }
        this.state.inPropertyName = oldInPropertyName;
      }
      return prop.key;
    }
    initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      const allowModifiers = isConstructor;
      this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, allowModifiers);
      this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return node;
    }
    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const node = this.startNode();
      this.next();
      node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      let flags = functionFlags(isAsync, false);
      if (!this.match(types$1.bracketL) && this.prodParam.hasIn) {
        flags |= PARAM_IN;
      }
      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaPos);
      }
      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, trailingCommaPos, false);
    }
    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    }
    parseFunctionBody(node, allowExpression, isMethod = false) {
      const isExpression = allowExpression && !this.match(types$1.braceL);
      this.expressionScope.enter(newExpressionScope());
      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        const oldStrict = this.state.strict;
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
        node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
          const nonSimple = !this.isSimpleParamList(node.params);
          if (hasStrictModeDirective && nonSimple) {
            const errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;
            this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
          }
          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
          if (this.state.strict && node.id) {
            this.checkLVal(node.id, "function name", BIND_OUTSIDE, void 0, void 0, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.expressionScope.exit();
        this.state.labels = oldLabels;
      }
    }
    isSimpleParamList(params) {
      for (let i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== "Identifier")
          return false;
      }
      return true;
    }
    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
      const checkClashes = new Set();
      for (const param of node.params) {
        this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, void 0, strictModeChanged);
      }
    }
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }
      return elts;
    }
    parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
      let elt;
      if (this.match(types$1.comma)) {
        if (!allowEmpty) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
        }
        elt = null;
      } else if (this.match(types$1.ellipsis)) {
        const spreadNodeStartPos = this.state.start;
        const spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types$1.question)) {
        this.expectPlugin("partialApplication");
        if (!allowPlaceholder) {
          this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
        }
        const node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
      }
      return elt;
    }
    parseIdentifier(liberal) {
      const node = this.startNode();
      const name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    }
    createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    }
    parseIdentifierName(pos, liberal) {
      let name;
      const {
        start,
        type
      } = this.state;
      if (type === types$1.name) {
        name = this.state.value;
      } else if (type.keyword) {
        name = type.keyword;
      } else {
        throw this.unexpected();
      }
      if (liberal) {
        this.state.type = types$1.name;
      } else {
        this.checkReservedWord(name, start, !!type.keyword, false);
      }
      this.next();
      return name;
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10) {
        return;
      }
      if (!canBeReservedWord(word)) {
        return;
      }
      if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
          return;
        } else if (this.scope.inStaticBlock) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);
          return;
        } else {
          this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);
        }
      } else if (word === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(startLoc, ErrorMessages.ArgumentsInClass);
          return;
        }
      }
      if (checkKeywords && isKeyword(word)) {
        this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
        return;
      }
      const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
      if (reservedTest(word, this.inModule)) {
        this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
      }
    }
    isAwaitAllowed() {
      if (this.prodParam.hasAwait)
        return true;
      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
        return true;
      }
      return false;
    }
    parseAwait(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);
      if (this.eat(types$1.star)) {
        this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
      }
      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.isAmbiguousAwait()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }
      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary(null, true);
      }
      return this.finishNode(node, "AwaitExpression");
    }
    isAmbiguousAwait() {
      return this.hasPrecedingLineBreak() || this.match(types$1.plusMin) || this.match(types$1.parenL) || this.match(types$1.bracketL) || this.match(types$1.backQuote) || this.match(types$1.regexp) || this.match(types$1.slash) || this.hasPlugin("v8intrinsic") && this.match(types$1.modulo);
    }
    parseYield() {
      const node = this.startNode();
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);
      this.next();
      let delegating = false;
      let argument = null;
      if (!this.hasPrecedingLineBreak()) {
        delegating = this.eat(types$1.star);
        switch (this.state.type) {
          case types$1.semi:
          case types$1.eof:
          case types$1.braceR:
          case types$1.parenR:
          case types$1.bracketR:
          case types$1.braceBarR:
          case types$1.colon:
          case types$1.comma:
            if (!delegating)
              break;
          default:
            argument = this.parseMaybeAssign();
        }
      }
      node.delegate = delegating;
      node.argument = argument;
      return this.finishNode(node, "YieldExpression");
    }
    checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        if (left.type === "SequenceExpression") {
          this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
        }
      }
    }
    checkHackPipeBodyEarlyErrors(startPos) {
      if (this.match(types$1.arrow)) {
        throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, types$1.arrow.label);
      } else if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(startPos, ErrorMessages.PipeTopicUnused);
      }
    }
    parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
      const bodyNode = this.startNodeAt(startPos, startLoc);
      if (this.isSimpleReference(childExpr)) {
        bodyNode.callee = childExpr;
        return this.finishNode(bodyNode, "PipelineBareFunction");
      } else {
        this.checkSmartPipeTopicBodyEarlyErrors(startPos);
        bodyNode.expression = childExpr;
        return this.finishNode(bodyNode, "PipelineTopicExpression");
      }
    }
    isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(startPos) {
      if (this.match(types$1.arrow)) {
        throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
      } else if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(startPos, ErrorMessages.PipelineTopicUnused);
      }
    }
    withTopicBindingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
    withSmartMixTopicForbiddingContext(callback) {
      const proposal = this.getPluginOption("pipelineOperator", "proposal");
      if (proposal === "smart") {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      } else {
        return callback();
      }
    }
    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
    allowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToSet = PARAM_IN & ~flags;
      if (prodParamToSet) {
        this.prodParam.enter(flags | PARAM_IN);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    disallowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToClear = PARAM_IN & flags;
      if (prodParamToClear) {
        this.prodParam.enter(flags & ~PARAM_IN);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const node = this.startNode();
      this.next();
      this.eat(types$1.braceL);
      const revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      const program = this.startNode();
      try {
        node.body = this.parseProgram(program, types$1.braceR, "module");
      } finally {
        revertScopes();
      }
      this.eat(types$1.braceR);
      return this.finishNode(node, "ModuleExpression");
    }
  };
  var loopLabel = {
    kind: "loop"
  };
  var switchLabel = {
    kind: "switch"
  };
  var FUNC_NO_FLAGS = 0;
  var FUNC_STATEMENT = 1;
  var FUNC_HANGING_STATEMENT = 2;
  var FUNC_NULLABLE_ID = 4;
  var loneSurrogate = /[\uD800-\uDFFF]/u;
  var keywordRelationalOperator = /in(?:stanceof)?/y;
  function babel7CompatTokens(tokens) {
    {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.type === types$1.privateName) {
          const {
            loc,
            start,
            value,
            end
          } = token;
          const hashEndPos = start + 1;
          const hashEndLoc = new Position8(loc.start.line, loc.start.column + 1);
          tokens.splice(i, 1, new Token({
            type: types$1.hash,
            value: "#",
            start,
            end: hashEndPos,
            startLoc: loc.start,
            endLoc: hashEndLoc
          }), new Token({
            type: types$1.name,
            value,
            start: hashEndPos,
            end,
            startLoc: hashEndLoc,
            endLoc: loc.end
          }));
        }
      }
    }
    return tokens;
  }
  var StatementParser = class extends ExpressionParser {
    parseTopLevel(file, program) {
      file.program = this.parseProgram(program);
      file.comments = this.state.comments;
      if (this.options.tokens)
        file.tokens = babel7CompatTokens(this.tokens);
      return this.finishNode(file, "File");
    }
    parseProgram(program, end = types$1.eof, sourceType = this.options.sourceType) {
      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);
      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (const [name] of Array.from(this.scope.undefinedExports)) {
          const pos = this.scope.undefinedExports.get(name);
          this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
        }
      }
      return this.finishNode(program, "Program");
    }
    stmtToDirective(stmt) {
      const directive = stmt;
      directive.type = "Directive";
      directive.value = directive.expression;
      delete directive.expression;
      const directiveLiteral = directive.value;
      const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
      const val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directiveLiteral.type = "DirectiveLiteral";
      return directive;
    }
    parseInterpreterDirective() {
      if (!this.match(types$1.interpreterDirective)) {
        return null;
      }
      const node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    }
    isLet(context) {
      if (!this.isContextual("let")) {
        return false;
      }
      return this.isLetKeyword(context);
    }
    isLetKeyword(context) {
      const next = this.nextTokenStart();
      const nextCh = this.codePointAtPos(next);
      if (nextCh === 92 || nextCh === 91) {
        return true;
      }
      if (context)
        return false;
      if (nextCh === 123)
        return true;
      if (isIdentifierStart(nextCh)) {
        keywordRelationalOperator.lastIndex = next;
        if (keywordRelationalOperator.test(this.input)) {
          const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
          if (!isIdentifierChar(endCh) && endCh !== 92) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    parseStatement(context, topLevel) {
      if (this.match(types$1.at)) {
        this.parseDecorators(true);
      }
      return this.parseStatementContent(context, topLevel);
    }
    parseStatementContent(context, topLevel) {
      let starttype = this.state.type;
      const node = this.startNode();
      let kind;
      if (this.isLet(context)) {
        starttype = types$1._var;
        kind = "let";
      }
      switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types$1._debugger:
          return this.parseDebuggerStatement(node);
        case types$1._do:
          return this.parseDoStatement(node);
        case types$1._for:
          return this.parseForStatement(node);
        case types$1._function:
          if (this.lookaheadCharCode() === 46)
            break;
          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, ErrorMessages.StrictFunction);
            } else if (context !== "if" && context !== "label") {
              this.raise(this.state.start, ErrorMessages.SloppyFunction);
            }
          }
          return this.parseFunctionStatement(node, false, !context);
        case types$1._class:
          if (context)
            this.unexpected();
          return this.parseClass(node, true);
        case types$1._if:
          return this.parseIfStatement(node);
        case types$1._return:
          return this.parseReturnStatement(node);
        case types$1._switch:
          return this.parseSwitchStatement(node);
        case types$1._throw:
          return this.parseThrowStatement(node);
        case types$1._try:
          return this.parseTryStatement(node);
        case types$1._const:
        case types$1._var:
          kind = kind || this.state.value;
          if (context && kind !== "var") {
            this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
          }
          return this.parseVarStatement(node, kind);
        case types$1._while:
          return this.parseWhileStatement(node);
        case types$1._with:
          return this.parseWithStatement(node);
        case types$1.braceL:
          return this.parseBlock();
        case types$1.semi:
          return this.parseEmptyStatement(node);
        case types$1._import: {
          const nextTokenCharCode = this.lookaheadCharCode();
          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
            break;
          }
        }
        case types$1._export: {
          if (!this.options.allowImportExportEverywhere && !topLevel) {
            this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
          }
          this.next();
          let result;
          if (starttype === types$1._import) {
            result = this.parseImport(node);
            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
              this.sawUnambiguousESM = true;
            }
          } else {
            result = this.parseExport(node);
            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
              this.sawUnambiguousESM = true;
            }
          }
          this.assertModuleNodeAllowed(node);
          return result;
        }
        default: {
          if (this.isAsyncFunction()) {
            if (context) {
              this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
            }
            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
        }
      }
      const maybeName = this.state.value;
      const expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    }
    assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(node.start, SourceTypeModuleErrorMessages.ImportOutsideModule);
      }
    }
    takeDecorators(node) {
      const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    }
    canHaveLeadingDecorator() {
      return this.match(types$1._class);
    }
    parseDecorators(allowExport) {
      const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      while (this.match(types$1.at)) {
        const decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }
      if (this.match(types$1._export)) {
        if (!allowExport) {
          this.unexpected();
        }
        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
      }
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      const node = this.startNode();
      this.next();
      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let expr;
        if (this.eat(types$1.parenL)) {
          expr = this.parseExpression();
          this.expect(types$1.parenR);
        } else {
          expr = this.parseIdentifier(false);
          while (this.eat(types$1.dot)) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.object = expr;
            node2.property = this.parseIdentifier(true);
            node2.computed = false;
            expr = this.finishNode(node2, "MemberExpression");
          }
        }
        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }
      return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(types$1.parenL)) {
        const node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }
      return expr;
    }
    parseBreakContinueStatement(node, keyword) {
      const isBreak = keyword === "break";
      this.next();
      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }
      this.verifyBreakContinue(node, keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(node, keyword) {
      const isBreak = keyword === "break";
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        const lab = this.state.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop"))
            break;
          if (node.label && isBreak)
            break;
        }
      }
      if (i === this.state.labels.length) {
        this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
      }
    }
    parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(types$1.parenL);
      const val = this.parseExpression();
      this.expect(types$1.parenR);
      return val;
    }
    parseDoStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do"));
      this.state.labels.pop();
      this.expect(types$1._while);
      node.test = this.parseHeaderExpression();
      this.eat(types$1.semi);
      return this.finishNode(node, "DoWhileStatement");
    }
    parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      let awaitAt = -1;
      if (this.isAwaitAllowed() && this.eatContextual("await")) {
        awaitAt = this.state.lastTokStart;
      }
      this.scope.enter(SCOPE_OTHER);
      this.expect(types$1.parenL);
      if (this.match(types$1.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, null);
      }
      const startsWithLet = this.isContextual("let");
      const isLet = startsWithLet && this.isLetKeyword();
      if (this.match(types$1._var) || this.match(types$1._const) || isLet) {
        const init2 = this.startNode();
        const kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(init2, true, kind);
        this.finishNode(init2, "VariableDeclaration");
        if ((this.match(types$1._in) || this.isContextual("of")) && init2.declarations.length === 1) {
          return this.parseForIn(node, init2, awaitAt);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init2);
      }
      const startsWithUnescapedName = this.match(types$1.name) && !this.state.containsEsc;
      const refExpressionErrors = new ExpressionErrors();
      const init = this.parseExpression(true, refExpressionErrors);
      const isForOf = this.isContextual("of");
      if (isForOf) {
        if (startsWithLet) {
          this.raise(init.start, ErrorMessages.ForOfLet);
        } else if (awaitAt === -1 && startsWithUnescapedName && init.type === "Identifier" && init.name === "async") {
          this.raise(init.start, ErrorMessages.ForOfAsync);
        }
      }
      if (isForOf || this.match(types$1._in)) {
        this.toAssignable(init, true);
        const description = isForOf ? "for-of statement" : "for-in statement";
        this.checkLVal(init, description);
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, init);
    }
    parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    }
    parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    }
    parseReturnStatement(node) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, ErrorMessages.IllegalReturn);
      }
      this.next();
      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    }
    parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      const cases = node.cases = [];
      this.expect(types$1.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      let cur;
      for (let sawDefault; !this.match(types$1.braceR); ) {
        if (this.match(types$1._case) || this.match(types$1._default)) {
          const isCase = this.match(types$1._case);
          if (cur)
            this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$1.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }
      this.scope.exit();
      if (cur)
        this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    }
    parseThrowStatement(node) {
      this.next();
      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
      }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const param = this.parseBindingAtom();
      const simple = param.type === "Identifier";
      this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(param, "catch clause", BIND_LEXICAL);
      return param;
    }
    parseTryStatement(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.match(types$1._catch)) {
        const clause = this.startNode();
        this.next();
        if (this.match(types$1.parenL)) {
          this.expect(types$1.parenL);
          clause.param = this.parseCatchClauseParam();
          this.expect(types$1.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }
        clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) {
        this.raise(node.start, ErrorMessages.NoCatchOrFinally);
      }
      return this.finishNode(node, "TryStatement");
    }
    parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    }
    parseWhileStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while"));
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    }
    parseWithStatement(node) {
      if (this.state.strict) {
        this.raise(this.state.start, ErrorMessages.StrictWith);
      }
      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with"));
      return this.finishNode(node, "WithStatement");
    }
    parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    }
    parseLabeledStatement(node, maybeName, expr, context) {
      for (const label of this.state.labels) {
        if (label.name === maybeName) {
          this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
        }
      }
      const kind = this.state.type.isLoop ? "loop" : this.match(types$1._switch) ? "switch" : null;
      for (let i = this.state.labels.length - 1; i >= 0; i--) {
        const label = this.state.labels[i];
        if (label.statementStart === node.start) {
          label.statementStart = this.state.start;
          label.kind = kind;
        } else {
          break;
        }
      }
      this.state.labels.push({
        name: maybeName,
        kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    }
    parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    }
    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
      const node = this.startNode();
      if (allowDirectives) {
        this.state.strictErrors.clear();
      }
      this.expect(types$1.braceL);
      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }
      this.parseBlockBody(node, allowDirectives, false, types$1.braceR, afterBlockParse);
      if (createNewLexicalScope) {
        this.scope.exit();
      }
      return this.finishNode(node, "BlockStatement");
    }
    isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      const body = node.body = [];
      const directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
    }
    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      const oldStrict = this.state.strict;
      let hasStrictModeDirective = false;
      let parsedNonDirective = false;
      while (!this.match(end)) {
        const stmt = this.parseStatement(null, topLevel);
        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            const directive = this.stmtToDirective(stmt);
            directives.push(directive);
            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }
            continue;
          }
          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }
        body.push(stmt);
      }
      if (afterBlockParse) {
        afterBlockParse.call(this, hasStrictModeDirective);
      }
      if (!oldStrict) {
        this.setStrict(false);
      }
      this.next();
    }
    parseFor(node, init) {
      node.init = init;
      this.semicolon(false);
      node.test = this.match(types$1.semi) ? null : this.parseExpression();
      this.semicolon(false);
      node.update = this.match(types$1.parenR) ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    }
    parseForIn(node, init, awaitAt) {
      const isForIn = this.match(types$1._in);
      this.next();
      if (isForIn) {
        if (awaitAt > -1)
          this.unexpected(awaitAt);
      } else {
        node.await = awaitAt > -1;
      }
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop");
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(types$1.parenR);
      node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(node, isFor, kind) {
      const declarations = node.declarations = [];
      const isTypescript = this.hasPlugin("typescript");
      node.kind = kind;
      for (; ; ) {
        const decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$1.eq)) {
          decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        } else {
          if (kind === "const" && !(this.match(types$1._in) || this.isContextual("of"))) {
            if (!isTypescript) {
              this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
            }
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types$1._in) || this.isContextual("of")))) {
            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
          }
          decl.init = null;
        }
        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma))
          break;
      }
      return node;
    }
    parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, void 0, kind !== "var");
    }
    parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
      const isStatement = statement & FUNC_STATEMENT;
      const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);
      if (this.match(types$1.star) && isHangingStatement) {
        this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
      }
      node.generator = this.eat(types$1.star);
      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(SCOPE_FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      if (!isStatement) {
        node.id = this.parseFunctionId();
      }
      this.parseFunctionParams(node, false);
      this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();
      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }
    parseFunctionId(requireId) {
      return requireId || this.match(types$1.name) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(node, allowModifiers) {
      this.expect(types$1.parenL);
      this.expressionScope.enter(newParameterDeclarationScope());
      node.params = this.parseBindingList(types$1.parenR, 41, false, allowModifiers);
      this.expressionScope.exit();
    }
    registerFunctionStatementId(node) {
      if (!node.id)
        return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
    }
    parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      const oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(types$1.eq) || this.match(types$1.semi) || this.match(types$1.braceR);
    }
    isClassMethod() {
      return this.match(types$1.parenL);
    }
    isNonstaticConstructor(method) {
      return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    }
    parseClassBody(hadSuperClass, oldStrict) {
      this.classScope.enter();
      const state = {
        hadConstructor: false,
        hadSuperClass
      };
      let decorators = [];
      const classBody = this.startNode();
      classBody.body = [];
      this.expect(types$1.braceL);
      this.withSmartMixTopicForbiddingContext(() => {
        while (!this.match(types$1.braceR)) {
          if (this.eat(types$1.semi)) {
            if (decorators.length > 0) {
              throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
            }
            continue;
          }
          if (this.match(types$1.at)) {
            decorators.push(this.parseDecorator());
            continue;
          }
          const member = this.startNode();
          if (decorators.length) {
            member.decorators = decorators;
            this.resetStartLocationFromNode(member, decorators[0]);
            decorators = [];
          }
          this.parseClassMember(classBody, member, state);
          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            this.raise(member.start, ErrorMessages.DecoratorConstructor);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();
      if (decorators.length) {
        throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
      }
      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    }
    parseClassMemberFromModifier(classBody, member) {
      const key = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method.static = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        const prop = member;
        prop.computed = false;
        prop.key = key;
        prop.static = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }
      this.resetPreviousNodeTrailingComments(key);
      return false;
    }
    parseClassMember(classBody, member, state) {
      const isStatic = this.isContextual("static");
      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }
        if (this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const publicMethod = member;
      const privateMethod = member;
      const publicProp = member;
      const privateProp = member;
      const method = publicMethod;
      const publicMember = publicMethod;
      member.static = isStatic;
      if (this.eat(types$1.star)) {
        method.kind = "method";
        const isPrivateName = this.match(types$1.privateName);
        this.parseClassElementName(method);
        if (isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
        }
        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }
      const isContextual = this.match(types$1.name) && !this.state.containsEsc;
      const isPrivate = this.match(types$1.privateName);
      const key = this.parseClassElementName(member);
      const maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);
      if (this.isClassMethod()) {
        method.kind = "method";
        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }
        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = false;
        if (isConstructor) {
          publicMethod.kind = "constructor";
          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(key.start, ErrorMessages.DuplicateConstructor);
          }
          if (isConstructor && this.hasPlugin("typescript") && member.override) {
            this.raise(key.start, ErrorMessages.OverrideOnConstructor);
          }
          state.hadConstructor = true;
          allowsDirectSuper = state.hadSuperClass;
        }
        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(key);
        const isGenerator = this.eat(types$1.star);
        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }
        method.kind = "method";
        const isPrivate2 = this.match(types$1.privateName);
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);
        if (isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
          }
          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(types$1.star) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(key);
        method.kind = key.name;
        const isPrivate2 = this.match(types$1.privateName);
        this.parseClassElementName(publicMethod);
        if (isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
          }
          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }
        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }
    parseClassElementName(member) {
      const {
        type,
        value,
        start
      } = this.state;
      if ((type === types$1.name || type === types$1.string) && member.static && value === "prototype") {
        this.raise(start, ErrorMessages.StaticPrototype);
      }
      if (type === types$1.privateName && value === "constructor") {
        this.raise(start, ErrorMessages.ConstructorClassPrivateField);
      }
      return this.parsePropertyName(member, true);
    }
    parseClassStaticBlock(classBody, member) {
      var _member$decorators;
      this.expectPlugin("classStaticBlock", member.start);
      this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(PARAM);
      const body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, void 0, false, types$1.braceR);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));
      if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
        this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
      }
    }
    pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
      }
      classBody.body.push(this.parseClassProperty(prop));
    }
    pushClassPrivateProperty(classBody, prop) {
      const node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);
    }
    parsePostMemberNameModifiers(methodOrProp) {
    }
    parseClassPrivateProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassPrivateProperty");
    }
    parseClassProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassProperty");
    }
    parseInitializer(node) {
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(PARAM);
      node.value = this.eat(types$1.eq) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    }
    parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
      if (this.match(types$1.name)) {
        node.id = this.parseIdentifier();
        if (isStatement) {
          this.checkLVal(node.id, "class name", bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, ErrorMessages.MissingClassName);
        }
      }
    }
    parseClassSuper(node) {
      node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts() : null;
    }
    parseExport(node) {
      const hasDefault = this.maybeParseExportDefaultSpecifier(node);
      const parseAfterDefault = !hasDefault || this.eat(types$1.comma);
      const hasStar = parseAfterDefault && this.eatExportStar(node);
      const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types$1.comma));
      const isFromRequired = hasDefault || hasStar;
      if (hasStar && !hasNamespace) {
        if (hasDefault)
          this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }
      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, types$1.braceL);
      }
      let hasDeclaration;
      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }
      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }
      if (this.eat(types$1._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }
      throw this.unexpected(null, types$1.braceL);
    }
    eatExportStar(node) {
      return this.eat(types$1.star);
    }
    maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        if (!node.specifiers)
          node.specifiers = [];
        const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(node) {
      if (this.match(types$1.braceL)) {
        if (!node.specifiers)
          node.specifiers = [];
        node.specifiers.push(...this.parseExportSpecifiers());
        node.source = null;
        node.declaration = null;
        return true;
      }
      return false;
    }
    maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }
      return false;
    }
    isAsyncFunction() {
      if (!this.isContextual("async"))
        return false;
      const next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    }
    parseExportDefaultExpression() {
      const expr = this.startNode();
      const isAsync = this.isAsyncFunction();
      if (this.match(types$1._function) || isAsync) {
        this.next();
        if (isAsync) {
          this.next();
        }
        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      } else if (this.match(types$1._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types$1.at)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
        }
        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (this.match(types$1._const) || this.match(types$1._var) || this.isLet()) {
        throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
      } else {
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
    }
    parseExportDeclaration(node) {
      return this.parseStatement(null);
    }
    isExportDefaultSpecifier() {
      if (this.match(types$1.name)) {
        const value = this.state.value;
        if (value === "async" && !this.state.containsEsc || value === "let") {
          return false;
        }
        if ((value === "type" || value === "interface") && !this.state.containsEsc) {
          const l = this.lookahead();
          if (l.type === types$1.name && l.value !== "from" || l.type === types$1.braceL) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(types$1._default)) {
        return false;
      }
      const next = this.nextTokenStart();
      const hasFrom = this.isUnparsedContextual(next, "from");
      if (this.input.charCodeAt(next) === 44 || this.match(types$1.name) && hasFrom) {
        return true;
      }
      if (this.match(types$1._default) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }
      return false;
    }
    parseExportFrom(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.parseImportSource();
        this.checkExport(node);
        const assertions = this.maybeParseImportAssertions();
        if (assertions) {
          node.assertions = assertions;
        }
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      if (this.match(types$1.at)) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
          } else {
            return true;
          }
        }
      }
      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    }
    checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");
          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;
            const declaration = node.declaration;
            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
              this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
            }
          }
        } else if (node.specifiers && node.specifiers.length) {
          for (const specifier of node.specifiers) {
            const {
              exported
            } = specifier;
            const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
            this.checkDuplicateExports(specifier, exportedName);
            if (!isFrom && specifier.local) {
              const {
                local
              } = specifier;
              if (local.type !== "Identifier") {
                this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
              } else {
                this.checkReservedWord(local.name, local.start, true, false);
                this.scope.checkLocalExport(local);
              }
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            const id = node.declaration.id;
            if (!id)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (const declaration of node.declaration.declarations) {
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }
      const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      if (currentContextDecorators.length) {
        throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
      }
    }
    checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (const prop of node.properties) {
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (const elem of node.elements) {
          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    }
    checkDuplicateExports(node, name) {
      if (this.exportedIdentifiers.has(name)) {
        this.raise(node.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
      }
      this.exportedIdentifiers.add(name);
    }
    parseExportSpecifiers() {
      const nodes = [];
      let first = true;
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
          if (this.eat(types$1.braceR))
            break;
        }
        const node = this.startNode();
        const isString = this.match(types$1.string);
        const local = this.parseModuleExportName();
        node.local = local;
        if (this.eatContextual("as")) {
          node.exported = this.parseModuleExportName();
        } else if (isString) {
          node.exported = cloneStringLiteral(local);
        } else {
          node.exported = cloneIdentifier(local);
        }
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      return nodes;
    }
    parseModuleExportName() {
      if (this.match(types$1.string)) {
        const result = this.parseStringLiteral(this.state.value);
        const surrogate = result.value.match(loneSurrogate);
        if (surrogate) {
          this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
        }
        return result;
      }
      return this.parseIdentifier(true);
    }
    parseImport(node) {
      node.specifiers = [];
      if (!this.match(types$1.string)) {
        const hasDefault = this.maybeParseDefaultImportSpecifier(node);
        const parseNext = !hasDefault || this.eat(types$1.comma);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar)
          this.parseNamedImportSpecifiers(node);
        this.expectContextual("from");
      }
      node.source = this.parseImportSource();
      const assertions = this.maybeParseImportAssertions();
      if (assertions) {
        node.assertions = assertions;
      } else {
        const attributes = this.maybeParseModuleAttributes();
        if (attributes) {
          node.attributes = attributes;
        }
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }
    parseImportSource() {
      if (!this.match(types$1.string))
        this.unexpected();
      return this.parseExprAtom();
    }
    shouldParseDefaultImport(node) {
      return this.match(types$1.name);
    }
    parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, type));
    }
    parseAssertEntries() {
      const attrs = [];
      const attrNames = new Set();
      do {
        if (this.match(types$1.braceR)) {
          break;
        }
        const node = this.startNode();
        const keyName = this.state.value;
        if (attrNames.has(keyName)) {
          this.raise(this.state.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
        }
        attrNames.add(keyName);
        if (this.match(types$1.string)) {
          node.key = this.parseStringLiteral(keyName);
        } else {
          node.key = this.parseIdentifier(true);
        }
        this.expect(types$1.colon);
        if (!this.match(types$1.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }
        node.value = this.parseStringLiteral(this.state.value);
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types$1.comma));
      return attrs;
    }
    maybeParseModuleAttributes() {
      if (this.match(types$1._with) && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("moduleAttributes");
        this.next();
      } else {
        if (this.hasPlugin("moduleAttributes"))
          return [];
        return null;
      }
      const attrs = [];
      const attributes = new Set();
      do {
        const node = this.startNode();
        node.key = this.parseIdentifier(true);
        if (node.key.name !== "type") {
          this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
        }
        if (attributes.has(node.key.name)) {
          this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
        }
        attributes.add(node.key.name);
        this.expect(types$1.colon);
        if (!this.match(types$1.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }
        node.value = this.parseStringLiteral(this.state.value);
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types$1.comma));
      return attrs;
    }
    maybeParseImportAssertions() {
      if (this.isContextual("assert") && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("importAssertions");
        this.next();
      } else {
        if (this.hasPlugin("importAssertions"))
          return [];
        return null;
      }
      this.eat(types$1.braceL);
      const attrs = this.parseAssertEntries();
      this.eat(types$1.braceR);
      return attrs;
    }
    maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
        return true;
      }
      return false;
    }
    maybeParseStarImportSpecifier(node) {
      if (this.match(types$1.star)) {
        const specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
        return true;
      }
      return false;
    }
    parseNamedImportSpecifiers(node) {
      let first = true;
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types$1.colon)) {
            throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
          }
          this.expect(types$1.comma);
          if (this.eat(types$1.braceR))
            break;
        }
        this.parseImportSpecifier(node);
      }
    }
    parseImportSpecifier(node) {
      const specifier = this.startNode();
      const importedIsString = this.match(types$1.string);
      specifier.imported = this.parseModuleExportName();
      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        const {
          imported
        } = specifier;
        if (importedIsString) {
          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);
        }
        this.checkReservedWord(imported.name, specifier.start, true, true);
        specifier.local = cloneIdentifier(imported);
      }
      this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }
    isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    }
  };
  var Parser = class extends StatementParser {
    constructor(options, input) {
      options = getOptions(options);
      super(options, input);
      this.options = options;
      this.initializeScopes();
      this.plugins = pluginsMap(this.options.plugins);
      this.filename = options.sourceFilename;
    }
    getScopeHandler() {
      return ScopeHandler;
    }
    parse() {
      this.enterInitialScopes();
      const file = this.startNode();
      const program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    }
  };
  function pluginsMap(plugins) {
    const pluginMap = new Map();
    for (const plugin of plugins) {
      const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
      if (!pluginMap.has(name))
        pluginMap.set(name, options || {});
    }
    return pluginMap;
  }
  function parse2(input, options) {
    var _options;
    if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
      options = Object.assign({}, options);
      try {
        options.sourceType = "module";
        const parser = getParser(options, input);
        const ast = parser.parse();
        if (parser.sawUnambiguousESM) {
          return ast;
        }
        if (parser.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused) {
          }
        } else {
          ast.program.sourceType = "script";
        }
        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused2) {
        }
        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  }
  function parseExpression(input, options) {
    const parser = getParser(options, input);
    if (parser.options.strictMode) {
      parser.state.strict = true;
    }
    return parser.getExpression();
  }
  function getParser(options, input) {
    let cls = Parser;
    if (options != null && options.plugins) {
      validatePlugins(options.plugins);
      cls = getParserClass(options.plugins);
    }
    return new cls(options, input);
  }
  var parserClassCache = {};
  function getParserClass(pluginsFromOptions) {
    const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
    const key = pluginList.join("/");
    let cls = parserClassCache[key];
    if (!cls) {
      cls = Parser;
      for (const plugin of pluginList) {
        cls = mixinPlugins[plugin](cls);
      }
      parserClassCache[key] = cls;
    }
    return cls;
  }
  exports2.parse = parse2;
  exports2.parseExpression = parseExpression;
  exports2.tokTypes = types$1;
});

// node_modules/estree-walker/dist/esm/estree-walker.js
var require_estree_walker = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    asyncWalk: () => asyncWalk,
    walk: () => walk
  });
  var WalkerBase = class {
    constructor() {
      this.should_skip = false;
      this.should_remove = false;
      this.replacement = null;
      this.context = {
        skip: () => this.should_skip = true,
        remove: () => this.should_remove = true,
        replace: (node) => this.replacement = node
      };
    }
    replace(parent, prop, index, node) {
      if (parent) {
        if (index !== null) {
          parent[prop][index] = node;
        } else {
          parent[prop] = node;
        }
      }
    }
    remove(parent, prop, index) {
      if (parent) {
        if (index !== null) {
          parent[prop].splice(index, 1);
        } else {
          delete parent[prop];
        }
      }
    }
  };
  var SyncWalker = class extends WalkerBase {
    constructor(enter, leave) {
      super();
      this.enter = enter;
      this.leave = leave;
    }
    visit(node, parent, prop, index) {
      if (node) {
        if (this.enter) {
          const _should_skip = this.should_skip;
          const _should_remove = this.should_remove;
          const _replacement = this.replacement;
          this.should_skip = false;
          this.should_remove = false;
          this.replacement = null;
          this.enter.call(this.context, node, parent, prop, index);
          if (this.replacement) {
            node = this.replacement;
            this.replace(parent, prop, index, node);
          }
          if (this.should_remove) {
            this.remove(parent, prop, index);
          }
          const skipped = this.should_skip;
          const removed = this.should_remove;
          this.should_skip = _should_skip;
          this.should_remove = _should_remove;
          this.replacement = _replacement;
          if (skipped)
            return node;
          if (removed)
            return null;
        }
        for (const key in node) {
          const value = node[key];
          if (typeof value !== "object") {
            continue;
          } else if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i += 1) {
              if (value[i] !== null && typeof value[i].type === "string") {
                if (!this.visit(value[i], node, key, i)) {
                  i--;
                }
              }
            }
          } else if (value !== null && typeof value.type === "string") {
            this.visit(value, node, key, null);
          }
        }
        if (this.leave) {
          const _replacement = this.replacement;
          const _should_remove = this.should_remove;
          this.replacement = null;
          this.should_remove = false;
          this.leave.call(this.context, node, parent, prop, index);
          if (this.replacement) {
            node = this.replacement;
            this.replace(parent, prop, index, node);
          }
          if (this.should_remove) {
            this.remove(parent, prop, index);
          }
          const removed = this.should_remove;
          this.replacement = _replacement;
          this.should_remove = _should_remove;
          if (removed)
            return null;
        }
      }
      return node;
    }
  };
  var AsyncWalker = class extends WalkerBase {
    constructor(enter, leave) {
      super();
      this.enter = enter;
      this.leave = leave;
    }
    async visit(node, parent, prop, index) {
      if (node) {
        if (this.enter) {
          const _should_skip = this.should_skip;
          const _should_remove = this.should_remove;
          const _replacement = this.replacement;
          this.should_skip = false;
          this.should_remove = false;
          this.replacement = null;
          await this.enter.call(this.context, node, parent, prop, index);
          if (this.replacement) {
            node = this.replacement;
            this.replace(parent, prop, index, node);
          }
          if (this.should_remove) {
            this.remove(parent, prop, index);
          }
          const skipped = this.should_skip;
          const removed = this.should_remove;
          this.should_skip = _should_skip;
          this.should_remove = _should_remove;
          this.replacement = _replacement;
          if (skipped)
            return node;
          if (removed)
            return null;
        }
        for (const key in node) {
          const value = node[key];
          if (typeof value !== "object") {
            continue;
          } else if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i += 1) {
              if (value[i] !== null && typeof value[i].type === "string") {
                if (!await this.visit(value[i], node, key, i)) {
                  i--;
                }
              }
            }
          } else if (value !== null && typeof value.type === "string") {
            await this.visit(value, node, key, null);
          }
        }
        if (this.leave) {
          const _replacement = this.replacement;
          const _should_remove = this.should_remove;
          this.replacement = null;
          this.should_remove = false;
          await this.leave.call(this.context, node, parent, prop, index);
          if (this.replacement) {
            node = this.replacement;
            this.replace(parent, prop, index, node);
          }
          if (this.should_remove) {
            this.remove(parent, prop, index);
          }
          const removed = this.should_remove;
          this.replacement = _replacement;
          this.should_remove = _should_remove;
          if (removed)
            return null;
        }
      }
      return node;
    }
  };
  function walk(ast, {enter, leave}) {
    const instance = new SyncWalker(enter, leave);
    return instance.visit(ast, null);
  }
  async function asyncWalk(ast, {enter, leave}) {
    const instance = new AsyncWalker(enter, leave);
    return await instance.visit(ast, null);
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist();
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 2; i < arguments.length; i++) {
      walker = insert(this, walker, arguments[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports2, module2) => {
  "use strict";
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;
  var LRUCache = class {
    constructor(options) {
      if (typeof options === "number")
        options = {max: options};
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail; walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head; walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get2(this, key, true);
    }
    peek(key) {
      return get2(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1; l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get2(this, key, false));
    }
  };
  var get2 = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          return void 0;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };
  var Entry = class {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  };
  var forEachStep = (self2, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        hit = void 0;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module2.exports = LRUCache;
});

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS((exports2, module2) => {
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsDingbatRange = "\\u2700-\\u27bf";
  var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
  var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
  var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
  var rsPunctuationRange = "\\u2000-\\u206f";
  var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
  var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['\u2019]";
  var rsAstral = "[" + rsAstralRange + "]";
  var rsBreak = "[" + rsBreakRange + "]";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var rsDigits = "\\d+";
  var rsDingbat = "[" + rsDingbatRange + "]";
  var rsLower = "[" + rsLowerRange + "]";
  var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsUpper = "[" + rsUpperRange + "]";
  var rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
  var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
  var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
  var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    \u00C0: "A",
    \u00C1: "A",
    \u00C2: "A",
    \u00C3: "A",
    \u00C4: "A",
    \u00C5: "A",
    \u00E0: "a",
    \u00E1: "a",
    \u00E2: "a",
    \u00E3: "a",
    \u00E4: "a",
    \u00E5: "a",
    \u00C7: "C",
    \u00E7: "c",
    \u00D0: "D",
    \u00F0: "d",
    \u00C8: "E",
    \u00C9: "E",
    \u00CA: "E",
    \u00CB: "E",
    \u00E8: "e",
    \u00E9: "e",
    \u00EA: "e",
    \u00EB: "e",
    \u00CC: "I",
    \u00CD: "I",
    \u00CE: "I",
    \u00CF: "I",
    \u00EC: "i",
    \u00ED: "i",
    \u00EE: "i",
    \u00EF: "i",
    \u00D1: "N",
    \u00F1: "n",
    \u00D2: "O",
    \u00D3: "O",
    \u00D4: "O",
    \u00D5: "O",
    \u00D6: "O",
    \u00D8: "O",
    \u00F2: "o",
    \u00F3: "o",
    \u00F4: "o",
    \u00F5: "o",
    \u00F6: "o",
    \u00F8: "o",
    \u00D9: "U",
    \u00DA: "U",
    \u00DB: "U",
    \u00DC: "U",
    \u00F9: "u",
    \u00FA: "u",
    \u00FB: "u",
    \u00FC: "u",
    \u00DD: "Y",
    \u00FD: "y",
    \u00FF: "y",
    \u00C6: "Ae",
    \u00E6: "ae",
    \u00DE: "Th",
    \u00FE: "th",
    \u00DF: "ss",
    \u0100: "A",
    \u0102: "A",
    \u0104: "A",
    \u0101: "a",
    \u0103: "a",
    \u0105: "a",
    \u0106: "C",
    \u0108: "C",
    \u010A: "C",
    \u010C: "C",
    \u0107: "c",
    \u0109: "c",
    \u010B: "c",
    \u010D: "c",
    \u010E: "D",
    \u0110: "D",
    \u010F: "d",
    \u0111: "d",
    \u0112: "E",
    \u0114: "E",
    \u0116: "E",
    \u0118: "E",
    \u011A: "E",
    \u0113: "e",
    \u0115: "e",
    \u0117: "e",
    \u0119: "e",
    \u011B: "e",
    \u011C: "G",
    \u011E: "G",
    \u0120: "G",
    \u0122: "G",
    \u011D: "g",
    \u011F: "g",
    \u0121: "g",
    \u0123: "g",
    \u0124: "H",
    \u0126: "H",
    \u0125: "h",
    \u0127: "h",
    \u0128: "I",
    \u012A: "I",
    \u012C: "I",
    \u012E: "I",
    \u0130: "I",
    \u0129: "i",
    \u012B: "i",
    \u012D: "i",
    \u012F: "i",
    \u0131: "i",
    \u0134: "J",
    \u0135: "j",
    \u0136: "K",
    \u0137: "k",
    \u0138: "k",
    \u0139: "L",
    \u013B: "L",
    \u013D: "L",
    \u013F: "L",
    \u0141: "L",
    \u013A: "l",
    \u013C: "l",
    \u013E: "l",
    \u0140: "l",
    \u0142: "l",
    \u0143: "N",
    \u0145: "N",
    \u0147: "N",
    \u014A: "N",
    \u0144: "n",
    \u0146: "n",
    \u0148: "n",
    \u014B: "n",
    \u014C: "O",
    \u014E: "O",
    \u0150: "O",
    \u014D: "o",
    \u014F: "o",
    \u0151: "o",
    \u0154: "R",
    \u0156: "R",
    \u0158: "R",
    \u0155: "r",
    \u0157: "r",
    \u0159: "r",
    \u015A: "S",
    \u015C: "S",
    \u015E: "S",
    \u0160: "S",
    \u015B: "s",
    \u015D: "s",
    \u015F: "s",
    \u0161: "s",
    \u0162: "T",
    \u0164: "T",
    \u0166: "T",
    \u0163: "t",
    \u0165: "t",
    \u0167: "t",
    \u0168: "U",
    \u016A: "U",
    \u016C: "U",
    \u016E: "U",
    \u0170: "U",
    \u0172: "U",
    \u0169: "u",
    \u016B: "u",
    \u016D: "u",
    \u016F: "u",
    \u0171: "u",
    \u0173: "u",
    \u0174: "W",
    \u0175: "w",
    \u0176: "Y",
    \u0177: "y",
    \u0178: "Y",
    \u0179: "Z",
    \u017B: "Z",
    \u017D: "Z",
    \u017A: "z",
    \u017C: "z",
    \u017E: "z",
    \u0132: "IJ",
    \u0133: "ij",
    \u0152: "Oe",
    \u0153: "oe",
    \u0149: "'n",
    \u017F: "ss"
  };
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function asciiToArray(string) {
    return string.split("");
  }
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol2(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === void 0 ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol2(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  var camelCase = createCompounder(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize2(word) : word);
  });
  function capitalize2(string) {
    return upperFirst(toString(string).toLowerCase());
  }
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  var upperFirst = createCaseFirst("toUpperCase");
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? void 0 : pattern;
    if (pattern === void 0) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  module2.exports = camelCase;
});

// node_modules/json5/lib/unicode.js
var require_unicode = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Space_Separator = exports2.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  var ID_Start = exports2.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/;
  var ID_Continue = exports2.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});

// node_modules/json5/lib/util.js
var require_util4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isSpaceSeparator = isSpaceSeparator;
  exports2.isIdStartChar = isIdStartChar;
  exports2.isIdContinueChar = isIdContinueChar;
  exports2.isDigit = isDigit;
  exports2.isHexDigit = isHexDigit;
  var _unicode = require_unicode();
  var unicode = _interopRequireWildcard(_unicode);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function isSpaceSeparator(c) {
    return unicode.Space_Separator.test(c);
  }
  function isIdStartChar(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c);
  }
  function isIdContinueChar(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c);
  }
  function isDigit(c) {
    return /[0-9]/.test(c);
  }
  function isHexDigit(c) {
    return /[0-9A-Fa-f]/.test(c);
  }
});

// node_modules/json5/lib/parse.js
var require_parse2 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports2.default = parse2;
  var _util = require_util4();
  var util = _interopRequireWildcard(_util);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key2))
            newObj[key2] = obj[key2];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  var source = void 0;
  var parseState = void 0;
  var stack = void 0;
  var pos = void 0;
  var line = void 0;
  var column = void 0;
  var token = void 0;
  var key = void 0;
  var root = void 0;
  function parse2(text, reviver) {
    source = String(text);
    parseState = "start";
    stack = [];
    pos = 0;
    line = 1;
    column = 0;
    token = void 0;
    key = void 0;
    root = void 0;
    do {
      token = lex();
      parseStates[parseState]();
    } while (token.type !== "eof");
    if (typeof reviver === "function") {
      return internalize({"": root}, "", reviver);
    }
    return root;
  }
  function internalize(holder, name, reviver) {
    var value = holder[name];
    if (value != null && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
      for (var _key in value) {
        var replacement = internalize(value, _key, reviver);
        if (replacement === void 0) {
          delete value[_key];
        } else {
          value[_key] = replacement;
        }
      }
    }
    return reviver.call(holder, name, value);
  }
  var lexState = void 0;
  var buffer = void 0;
  var doubleQuote = void 0;
  var _sign = void 0;
  var c = void 0;
  function lex() {
    lexState = "default";
    buffer = "";
    doubleQuote = false;
    _sign = 1;
    for (; ; ) {
      c = peek();
      var _token = lexStates[lexState]();
      if (_token) {
        return _token;
      }
    }
  }
  function peek() {
    if (source[pos]) {
      return String.fromCodePoint(source.codePointAt(pos));
    }
  }
  function read() {
    var c2 = peek();
    if (c2 === "\n") {
      line++;
      column = 0;
    } else if (c2) {
      column += c2.length;
    } else {
      column++;
    }
    if (c2) {
      pos += c2.length;
    }
    return c2;
  }
  var lexStates = {default: function _default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "\xA0":
      case "\uFEFF":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read();
        lexState = "comment";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  }, comment: function comment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineComment";
        return;
      case "/":
        read();
        lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  }, multiLineComment: function multiLineComment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  }, multiLineCommentAsterisk: function multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read();
        lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
    lexState = "multiLineComment";
  }, singleLineComment: function singleLineComment() {
    switch (c) {
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        lexState = "default";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    read();
  }, value: function value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        read();
        literal("ull");
        return newToken("null", null);
      case "t":
        read();
        literal("rue");
        return newToken("boolean", true);
      case "f":
        read();
        literal("alse");
        return newToken("boolean", false);
      case "-":
      case "+":
        if (read() === "-") {
          _sign = -1;
        }
        lexState = "sign";
        return;
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"';
        buffer = "";
        lexState = "string";
        return;
    }
    throw invalidChar(read());
  }, identifierNameStartEscape: function identifierNameStartEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    var u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util.isIdStartChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  }, identifierName: function identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        buffer += read();
        return;
      case "\\":
        read();
        lexState = "identifierNameEscape";
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  }, identifierNameEscape: function identifierNameEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    var u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        break;
      default:
        if (!util.isIdContinueChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  }, sign: function sign() {
    switch (c) {
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", _sign * Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
    }
    throw invalidChar(read());
  }, zero: function zero() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read();
        lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", _sign * 0);
  }, decimalInteger: function decimalInteger() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  }, decimalPointLeading: function decimalPointLeading() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  }, decimalPoint: function decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  }, decimalFraction: function decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  }, decimalExponent: function decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer += read();
        lexState = "decimalExponentSign";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  }, decimalExponentSign: function decimalExponentSign() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  }, decimalExponentInteger: function decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  }, hexadecimal: function hexadecimal() {
    if (util.isHexDigit(c)) {
      buffer += read();
      lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  }, hexadecimalInteger: function hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  }, string: function string() {
    switch (c) {
      case "\\":
        read();
        buffer += escape();
        return;
      case '"':
        if (doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "'":
        if (!doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "\n":
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  }, start: function start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  }, beforePropertyName: function beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer = read();
        lexState = "identifierName";
        return;
      case "\\":
        read();
        lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"';
        lexState = "string";
        return;
    }
    if (util.isIdStartChar(c)) {
      buffer += read();
      lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  }, afterPropertyName: function afterPropertyName() {
    if (c === ":") {
      return newToken("punctuator", read());
    }
    throw invalidChar(read());
  }, beforePropertyValue: function beforePropertyValue() {
    lexState = "value";
  }, afterPropertyValue: function afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  }, beforeArrayValue: function beforeArrayValue() {
    if (c === "]") {
      return newToken("punctuator", read());
    }
    lexState = "value";
  }, afterArrayValue: function afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  }, end: function end() {
    throw invalidChar(read());
  }};
  function newToken(type, value) {
    return {type, value, line, column};
  }
  function literal(s) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = s[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _c = _step.value;
        var p = peek();
        if (p !== _c) {
          throw invalidChar(read());
        }
        read();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  function escape() {
    var c2 = peek();
    switch (c2) {
      case "b":
        read();
        return "\b";
      case "f":
        read();
        return "\f";
      case "n":
        read();
        return "\n";
      case "r":
        read();
        return "\r";
      case "t":
        read();
        return "	";
      case "v":
        read();
        return "\v";
      case "0":
        read();
        if (util.isDigit(peek())) {
          throw invalidChar(read());
        }
        return "\0";
      case "x":
        read();
        return hexEscape();
      case "u":
        read();
        return unicodeEscape();
      case "\n":
      case "\u2028":
      case "\u2029":
        read();
        return "";
      case "\r":
        read();
        if (peek() === "\n") {
          read();
        }
        return "";
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw invalidChar(read());
      case void 0:
        throw invalidChar(read());
    }
    return read();
  }
  function hexEscape() {
    var buffer2 = "";
    var c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
    c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
    return String.fromCodePoint(parseInt(buffer2, 16));
  }
  function unicodeEscape() {
    var buffer2 = "";
    var count = 4;
    while (count-- > 0) {
      var _c2 = peek();
      if (!util.isHexDigit(_c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
    }
    return String.fromCodePoint(parseInt(buffer2, 16));
  }
  var parseStates = {start: function start() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  }, beforePropertyName: function beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value;
        parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  }, afterPropertyName: function afterPropertyName() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    parseState = "beforePropertyValue";
  }, beforePropertyValue: function beforePropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  }, beforeArrayValue: function beforeArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  }, afterPropertyValue: function afterPropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  }, afterArrayValue: function afterArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  }, end: function end() {
  }};
  function push() {
    var value = void 0;
    switch (token.type) {
      case "punctuator":
        switch (token.value) {
          case "{":
            value = {};
            break;
          case "[":
            value = [];
            break;
        }
        break;
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        value = token.value;
        break;
    }
    if (root === void 0) {
      root = value;
    } else {
      var parent = stack[stack.length - 1];
      if (Array.isArray(parent)) {
        parent.push(value);
      } else {
        parent[key] = value;
      }
    }
    if (value !== null && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
      stack.push(value);
      if (Array.isArray(value)) {
        parseState = "beforeArrayValue";
      } else {
        parseState = "beforePropertyName";
      }
    } else {
      var current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }
  }
  function pop() {
    stack.pop();
    var current = stack[stack.length - 1];
    if (current == null) {
      parseState = "end";
    } else if (Array.isArray(current)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
  function invalidChar(c2) {
    if (c2 === void 0) {
      return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
    }
    return syntaxError("JSON5: invalid character '" + formatChar(c2) + "' at " + line + ":" + column);
  }
  function invalidEOF() {
    return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
  }
  function invalidIdentifier() {
    column -= 5;
    return syntaxError("JSON5: invalid identifier character at " + line + ":" + column);
  }
  function separatorChar(c2) {
    console.warn("JSON5: '" + c2 + "' is not valid ECMAScript; consider escaping");
  }
  function formatChar(c2) {
    var replacements = {"'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029"};
    if (replacements[c2]) {
      return replacements[c2];
    }
    if (c2 < " ") {
      var hexString = c2.charCodeAt(0).toString(16);
      return "\\x" + ("00" + hexString).substring(hexString.length);
    }
    return c2;
  }
  function syntaxError(message) {
    var err = new SyntaxError(message);
    err.lineNumber = line;
    err.columnNumber = column;
    return err;
  }
  module2.exports = exports2["default"];
});

// node_modules/json5/lib/stringify.js
var require_stringify2 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports2.default = stringify;
  var _util = require_util4();
  var util = _interopRequireWildcard(_util);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function stringify(value, replacer, space) {
    var stack = [];
    var indent = "";
    var propertyList = void 0;
    var replacerFunc = void 0;
    var gap = "";
    var quote = void 0;
    if (replacer != null && (typeof replacer === "undefined" ? "undefined" : _typeof(replacer)) === "object" && !Array.isArray(replacer)) {
      space = replacer.space;
      quote = replacer.quote;
      replacer = replacer.replacer;
    }
    if (typeof replacer === "function") {
      replacerFunc = replacer;
    } else if (Array.isArray(replacer)) {
      propertyList = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = replacer[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var v = _step.value;
          var item = void 0;
          if (typeof v === "string") {
            item = v;
          } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
            item = String(v);
          }
          if (item !== void 0 && propertyList.indexOf(item) < 0) {
            propertyList.push(item);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    if (space instanceof Number) {
      space = Number(space);
    } else if (space instanceof String) {
      space = String(space);
    }
    if (typeof space === "number") {
      if (space > 0) {
        space = Math.min(10, Math.floor(space));
        gap = "          ".substr(0, space);
      }
    } else if (typeof space === "string") {
      gap = space.substr(0, 10);
    }
    return serializeProperty("", {"": value});
    function serializeProperty(key, holder) {
      var value2 = holder[key];
      if (value2 != null) {
        if (typeof value2.toJSON5 === "function") {
          value2 = value2.toJSON5(key);
        } else if (typeof value2.toJSON === "function") {
          value2 = value2.toJSON(key);
        }
      }
      if (replacerFunc) {
        value2 = replacerFunc.call(holder, key, value2);
      }
      if (value2 instanceof Number) {
        value2 = Number(value2);
      } else if (value2 instanceof String) {
        value2 = String(value2);
      } else if (value2 instanceof Boolean) {
        value2 = value2.valueOf();
      }
      switch (value2) {
        case null:
          return "null";
        case true:
          return "true";
        case false:
          return "false";
      }
      if (typeof value2 === "string") {
        return quoteString(value2, false);
      }
      if (typeof value2 === "number") {
        return String(value2);
      }
      if ((typeof value2 === "undefined" ? "undefined" : _typeof(value2)) === "object") {
        return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
      }
      return void 0;
    }
    function quoteString(value2) {
      var quotes = {"'": 0.1, '"': 0.2};
      var replacements = {"'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029"};
      var product = "";
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = void 0;
      try {
        for (var _iterator2 = value2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var c = _step2.value;
          switch (c) {
            case "'":
            case '"':
              quotes[c]++;
              product += c;
              continue;
          }
          if (replacements[c]) {
            product += replacements[c];
            continue;
          }
          if (c < " ") {
            var hexString = c.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      var quoteChar = quote || Object.keys(quotes).reduce(function(a, b) {
        return quotes[a] < quotes[b] ? a : b;
      });
      product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
      return quoteChar + product + quoteChar;
    }
    function serializeObject(value2) {
      if (stack.indexOf(value2) >= 0) {
        throw TypeError("Converting circular structure to JSON5");
      }
      stack.push(value2);
      var stepback = indent;
      indent = indent + gap;
      var keys = propertyList || Object.keys(value2);
      var partial = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = void 0;
      try {
        for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var key = _step3.value;
          var propertyString = serializeProperty(key, value2);
          if (propertyString !== void 0) {
            var member = serializeKey(key) + ":";
            if (gap !== "") {
              member += " ";
            }
            member += propertyString;
            partial.push(member);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
      var final = void 0;
      if (partial.length === 0) {
        final = "{}";
      } else {
        var properties = void 0;
        if (gap === "") {
          properties = partial.join(",");
          final = "{" + properties + "}";
        } else {
          var separator = ",\n" + indent;
          properties = partial.join(separator);
          final = "{\n" + indent + properties + ",\n" + stepback + "}";
        }
      }
      stack.pop();
      indent = stepback;
      return final;
    }
    function serializeKey(key) {
      if (key.length === 0) {
        return quoteString(key, true);
      }
      var firstChar = String.fromCodePoint(key.codePointAt(0));
      if (!util.isIdStartChar(firstChar)) {
        return quoteString(key, true);
      }
      for (var i = firstChar.length; i < key.length; i++) {
        if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
          return quoteString(key, true);
        }
      }
      return key;
    }
    function serializeArray(value2) {
      if (stack.indexOf(value2) >= 0) {
        throw TypeError("Converting circular structure to JSON5");
      }
      stack.push(value2);
      var stepback = indent;
      indent = indent + gap;
      var partial = [];
      for (var i = 0; i < value2.length; i++) {
        var propertyString = serializeProperty(String(i), value2);
        partial.push(propertyString !== void 0 ? propertyString : "null");
      }
      var final = void 0;
      if (partial.length === 0) {
        final = "[]";
      } else {
        if (gap === "") {
          var properties = partial.join(",");
          final = "[" + properties + "]";
        } else {
          var separator = ",\n" + indent;
          var _properties = partial.join(separator);
          final = "[\n" + indent + _properties + ",\n" + stepback + "]";
        }
      }
      stack.pop();
      indent = stepback;
      return final;
    }
  }
  module2.exports = exports2["default"];
});

// node_modules/json5/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var _parse = require_parse2();
  var _parse2 = _interopRequireDefault(_parse);
  var _stringify = require_stringify2();
  var _stringify2 = _interopRequireDefault(_stringify);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  exports2.default = {parse: _parse2.default, stringify: _stringify2.default};
  module2.exports = exports2["default"];
});

// node_modules/loader-utils/lib/parseQuery.js
var require_parseQuery = __commonJS((exports2, module2) => {
  "use strict";
  var JSON5 = require_lib2();
  var specialValues = {
    null: null,
    true: true,
    false: false
  };
  function parseQuery(query) {
    if (query.substr(0, 1) !== "?") {
      throw new Error("A valid query string passed to parseQuery should begin with '?'");
    }
    query = query.substr(1);
    if (!query) {
      return {};
    }
    if (query.substr(0, 1) === "{" && query.substr(-1) === "}") {
      return JSON5.parse(query);
    }
    const queryArgs = query.split(/[,&]/g);
    const result = {};
    queryArgs.forEach((arg) => {
      const idx = arg.indexOf("=");
      if (idx >= 0) {
        let name = arg.substr(0, idx);
        let value = decodeURIComponent(arg.substr(idx + 1));
        if (specialValues.hasOwnProperty(value)) {
          value = specialValues[value];
        }
        if (name.substr(-2) === "[]") {
          name = decodeURIComponent(name.substr(0, name.length - 2));
          if (!Array.isArray(result[name])) {
            result[name] = [];
          }
          result[name].push(value);
        } else {
          name = decodeURIComponent(name);
          result[name] = value;
        }
      } else {
        if (arg.substr(0, 1) === "-") {
          result[decodeURIComponent(arg.substr(1))] = false;
        } else if (arg.substr(0, 1) === "+") {
          result[decodeURIComponent(arg.substr(1))] = true;
        } else {
          result[decodeURIComponent(arg)] = true;
        }
      }
    });
    return result;
  }
  module2.exports = parseQuery;
});

// node_modules/loader-utils/lib/getOptions.js
var require_getOptions = __commonJS((exports2, module2) => {
  "use strict";
  var parseQuery = require_parseQuery();
  function getOptions(loaderContext) {
    const query = loaderContext.query;
    if (typeof query === "string" && query !== "") {
      return parseQuery(loaderContext.query);
    }
    if (!query || typeof query !== "object") {
      return null;
    }
    return query;
  }
  module2.exports = getOptions;
});

// node_modules/loader-utils/lib/stringifyRequest.js
var require_stringifyRequest = __commonJS((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var matchRelativePath = /^\.\.?[/\\]/;
  function isAbsolutePath(str) {
    return path4.posix.isAbsolute(str) || path4.win32.isAbsolute(str);
  }
  function isRelativePath(str) {
    return matchRelativePath.test(str);
  }
  function stringifyRequest(loaderContext, request) {
    const splitted = request.split("!");
    const context = loaderContext.context || loaderContext.options && loaderContext.options.context;
    return JSON.stringify(splitted.map((part) => {
      const splittedPart = part.match(/^(.*?)(\?.*)/);
      const query = splittedPart ? splittedPart[2] : "";
      let singlePath = splittedPart ? splittedPart[1] : part;
      if (isAbsolutePath(singlePath) && context) {
        singlePath = path4.relative(context, singlePath);
        if (isAbsolutePath(singlePath)) {
          return singlePath + query;
        }
        if (isRelativePath(singlePath) === false) {
          singlePath = "./" + singlePath;
        }
      }
      return singlePath.replace(/\\/g, "/") + query;
    }).join("!"));
  }
  module2.exports = stringifyRequest;
});

// node_modules/loader-utils/lib/getRemainingRequest.js
var require_getRemainingRequest = __commonJS((exports2, module2) => {
  "use strict";
  function getRemainingRequest(loaderContext) {
    if (loaderContext.remainingRequest) {
      return loaderContext.remainingRequest;
    }
    const request = loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map((obj) => obj.request).concat([loaderContext.resource]);
    return request.join("!");
  }
  module2.exports = getRemainingRequest;
});

// node_modules/loader-utils/lib/getCurrentRequest.js
var require_getCurrentRequest = __commonJS((exports2, module2) => {
  "use strict";
  function getCurrentRequest(loaderContext) {
    if (loaderContext.currentRequest) {
      return loaderContext.currentRequest;
    }
    const request = loaderContext.loaders.slice(loaderContext.loaderIndex).map((obj) => obj.request).concat([loaderContext.resource]);
    return request.join("!");
  }
  module2.exports = getCurrentRequest;
});

// node_modules/loader-utils/lib/isUrlRequest.js
var require_isUrlRequest = __commonJS((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  function isUrlRequest(url, root) {
    if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !path4.win32.isAbsolute(url)) {
      return false;
    }
    if (/^\/\//.test(url)) {
      return false;
    }
    if (/^[{}[\]#*;,'§$%&(=?`´^°<>]/.test(url)) {
      return false;
    }
    if ((root === void 0 || root === false) && /^\//.test(url)) {
      return false;
    }
    return true;
  }
  module2.exports = isUrlRequest;
});

// node_modules/loader-utils/lib/urlToRequest.js
var require_urlToRequest = __commonJS((exports2, module2) => {
  "use strict";
  var matchNativeWin32Path = /^[A-Z]:[/\\]|^\\\\/i;
  function urlToRequest(url, root) {
    if (url === "") {
      return "";
    }
    const moduleRequestRegex = /^[^?]*~/;
    let request;
    if (matchNativeWin32Path.test(url)) {
      request = url;
    } else if (root !== void 0 && root !== false && /^\//.test(url)) {
      switch (typeof root) {
        case "string":
          if (moduleRequestRegex.test(root)) {
            request = root.replace(/([^~/])$/, "$1/") + url.slice(1);
          } else {
            request = root + url;
          }
          break;
        case "boolean":
          request = url;
          break;
        default:
          throw new Error("Unexpected parameters to loader-utils 'urlToRequest': url = " + url + ", root = " + root + ".");
      }
    } else if (/^\.\.?\//.test(url)) {
      request = url;
    } else {
      request = "./" + url;
    }
    if (moduleRequestRegex.test(request)) {
      request = request.replace(moduleRequestRegex, "");
    }
    return request;
  }
  module2.exports = urlToRequest;
});

// node_modules/loader-utils/lib/parseString.js
var require_parseString = __commonJS((exports2, module2) => {
  "use strict";
  function parseString(str) {
    try {
      if (str[0] === '"') {
        return JSON.parse(str);
      }
      if (str[0] === "'" && str.substr(str.length - 1) === "'") {
        return parseString(str.replace(/\\.|"/g, (x) => x === '"' ? '\\"' : x).replace(/^'|'$/g, '"'));
      }
      return JSON.parse('"' + str + '"');
    } catch (e) {
      return str;
    }
  }
  module2.exports = parseString;
});

// node_modules/big.js/big.mjs
var require_big = __commonJS((exports2) => {
  __markAsModule(exports2);
  __export(exports2, {
    Big: () => Big,
    default: () => big_default
  });
  var DP = 20;
  var RM = 1;
  var MAX_DP = 1e6;
  var MAX_POWER = 1e6;
  var NE = -7;
  var PE = 21;
  var NAME = "[big.js] ";
  var INVALID = NAME + "Invalid ";
  var INVALID_DP = INVALID + "decimal places";
  var INVALID_RM = INVALID + "rounding mode";
  var DIV_BY_ZERO = NAME + "Division by zero";
  var P = {};
  var UNDEFINED = void 0;
  var NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  function _Big_() {
    function Big2(n) {
      var x = this;
      if (!(x instanceof Big2))
        return n === UNDEFINED ? _Big_() : new Big2(n);
      if (n instanceof Big2) {
        x.s = n.s;
        x.e = n.e;
        x.c = n.c.slice();
      } else {
        parse2(x, n);
      }
      x.constructor = Big2;
    }
    Big2.prototype = P;
    Big2.DP = DP;
    Big2.RM = RM;
    Big2.NE = NE;
    Big2.PE = PE;
    Big2.version = "5.2.2";
    return Big2;
  }
  function parse2(x, n) {
    var e, i, nl;
    if (n === 0 && 1 / n < 0)
      n = "-0";
    else if (!NUMERIC.test(n += ""))
      throw Error(INVALID + "number");
    x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
    if ((e = n.indexOf(".")) > -1)
      n = n.replace(".", "");
    if ((i = n.search(/e/i)) > 0) {
      if (e < 0)
        e = i;
      e += +n.slice(i + 1);
      n = n.substring(0, i);
    } else if (e < 0) {
      e = n.length;
    }
    nl = n.length;
    for (i = 0; i < nl && n.charAt(i) == "0"; )
      ++i;
    if (i == nl) {
      x.c = [x.e = 0];
    } else {
      for (; nl > 0 && n.charAt(--nl) == "0"; )
        ;
      x.e = e - i - 1;
      x.c = [];
      for (e = 0; i <= nl; )
        x.c[e++] = +n.charAt(i++);
    }
    return x;
  }
  function round(x, dp, rm, more) {
    var xc = x.c, i = x.e + dp + 1;
    if (i < xc.length) {
      if (rm === 1) {
        more = xc[i] >= 5;
      } else if (rm === 2) {
        more = xc[i] > 5 || xc[i] == 5 && (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);
      } else if (rm === 3) {
        more = more || !!xc[0];
      } else {
        more = false;
        if (rm !== 0)
          throw Error(INVALID_RM);
      }
      if (i < 1) {
        xc.length = 1;
        if (more) {
          x.e = -dp;
          xc[0] = 1;
        } else {
          xc[0] = x.e = 0;
        }
      } else {
        xc.length = i--;
        if (more) {
          for (; ++xc[i] > 9; ) {
            xc[i] = 0;
            if (!i--) {
              ++x.e;
              xc.unshift(1);
            }
          }
        }
        for (i = xc.length; !xc[--i]; )
          xc.pop();
      }
    } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
      throw Error(INVALID_RM);
    }
    return x;
  }
  function stringify(x, id, n, k) {
    var e, s, Big2 = x.constructor, z = !x.c[0];
    if (n !== UNDEFINED) {
      if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
        throw Error(id == 3 ? INVALID + "precision" : INVALID_DP);
      }
      x = new Big2(x);
      n = k - x.e;
      if (x.c.length > ++k)
        round(x, n, Big2.RM);
      if (id == 2)
        k = x.e + n + 1;
      for (; x.c.length < k; )
        x.c.push(0);
    }
    e = x.e;
    s = x.c.join("");
    n = s.length;
    if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big2.NE || e >= Big2.PE)) {
      s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
    } else if (e < 0) {
      for (; ++e; )
        s = "0" + s;
      s = "0." + s;
    } else if (e > 0) {
      if (++e > n)
        for (e -= n; e--; )
          s += "0";
      else if (e < n)
        s = s.slice(0, e) + "." + s.slice(e);
    } else if (n > 1) {
      s = s.charAt(0) + "." + s.slice(1);
    }
    return x.s < 0 && (!z || id == 4) ? "-" + s : s;
  }
  P.abs = function() {
    var x = new this.constructor(this);
    x.s = 1;
    return x;
  };
  P.cmp = function(y) {
    var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
    if (!xc[0] || !yc[0])
      return !xc[0] ? !yc[0] ? 0 : -j : i;
    if (i != j)
      return i;
    isneg = i < 0;
    if (k != l)
      return k > l ^ isneg ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;
    for (i = -1; ++i < j; ) {
      if (xc[i] != yc[i])
        return xc[i] > yc[i] ^ isneg ? 1 : -1;
    }
    return k == l ? 0 : k > l ^ isneg ? 1 : -1;
  };
  P.div = function(y) {
    var x = this, Big2 = x.constructor, a = x.c, b = (y = new Big2(y)).c, k = x.s == y.s ? 1 : -1, dp = Big2.DP;
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP)
      throw Error(INVALID_DP);
    if (!b[0])
      throw Error(DIV_BY_ZERO);
    if (!a[0])
      return new Big2(k * 0);
    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1;
    q.s = k;
    k = d < 0 ? 0 : d;
    bz.unshift(0);
    for (; rl++ < bl; )
      r.push(0);
    do {
      for (n = 0; n < 10; n++) {
        if (bl != (rl = r.length)) {
          cmp = bl > rl ? 1 : -1;
        } else {
          for (ri = -1, cmp = 0; ++ri < bl; ) {
            if (b[ri] != r[ri]) {
              cmp = b[ri] > r[ri] ? 1 : -1;
              break;
            }
          }
        }
        if (cmp < 0) {
          for (bt = rl == bl ? b : bz; rl; ) {
            if (r[--rl] < bt[rl]) {
              ri = rl;
              for (; ri && !r[--ri]; )
                r[ri] = 9;
              --r[ri];
              r[rl] += 10;
            }
            r[rl] -= bt[rl];
          }
          for (; !r[0]; )
            r.shift();
        } else {
          break;
        }
      }
      qc[qi++] = cmp ? n : ++n;
      if (r[0] && cmp)
        r[rl] = a[ai] || 0;
      else
        r = [a[ai]];
    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
    if (!qc[0] && qi != 1) {
      qc.shift();
      q.e--;
    }
    if (qi > d)
      round(q, dp, Big2.RM, r[0] !== UNDEFINED);
    return q;
  };
  P.eq = function(y) {
    return !this.cmp(y);
  };
  P.gt = function(y) {
    return this.cmp(y) > 0;
  };
  P.gte = function(y) {
    return this.cmp(y) > -1;
  };
  P.lt = function(y) {
    return this.cmp(y) < 0;
  };
  P.lte = function(y) {
    return this.cmp(y) < 1;
  };
  P.minus = P.sub = function(y) {
    var i, j, t, xlty, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
    if (!xc[0] || !yc[0]) {
      return yc[0] ? (y.s = -b, y) : new Big2(xc[0] ? x : 0);
    }
    if (a = xe - ye) {
      if (xlty = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; )
        t.push(0);
      t.reverse();
    } else {
      j = ((xlty = xc.length < yc.length) ? xc : yc).length;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xlty = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xlty) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    if ((b = (j = yc.length) - (i = xc.length)) > 0)
      for (; b--; )
        xc[i++] = 0;
    for (b = i; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; )
          xc[i] = 9;
        --xc[i];
        xc[j] += 10;
      }
      xc[j] -= yc[j];
    }
    for (; xc[--b] === 0; )
      xc.pop();
    for (; xc[0] === 0; ) {
      xc.shift();
      --ye;
    }
    if (!xc[0]) {
      y.s = 1;
      xc = [ye = 0];
    }
    y.c = xc;
    y.e = ye;
    return y;
  };
  P.mod = function(y) {
    var ygtx, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
    if (!y.c[0])
      throw Error(DIV_BY_ZERO);
    x.s = y.s = 1;
    ygtx = y.cmp(x) == 1;
    x.s = a;
    y.s = b;
    if (ygtx)
      return new Big2(x);
    a = Big2.DP;
    b = Big2.RM;
    Big2.DP = Big2.RM = 0;
    x = x.div(y);
    Big2.DP = a;
    Big2.RM = b;
    return this.minus(x.times(y));
  };
  P.plus = P.add = function(y) {
    var t, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
    if (!xc[0] || !yc[0])
      return yc[0] ? y : new Big2(xc[0] ? x : a * 0);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; )
        t.push(0);
      t.reverse();
    }
    if (xc.length - yc.length < 0) {
      t = yc;
      yc = xc;
      xc = t;
    }
    a = yc.length;
    for (b = 0; a; xc[a] %= 10)
      b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;
    if (b) {
      xc.unshift(b);
      ++ye;
    }
    for (a = xc.length; xc[--a] === 0; )
      xc.pop();
    y.c = xc;
    y.e = ye;
    return y;
  };
  P.pow = function(n) {
    var x = this, one = new x.constructor(1), y = one, isneg = n < 0;
    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER)
      throw Error(INVALID + "exponent");
    if (isneg)
      n = -n;
    for (; ; ) {
      if (n & 1)
        y = y.times(x);
      n >>= 1;
      if (!n)
        break;
      x = x.times(x);
    }
    return isneg ? one.div(y) : y;
  };
  P.round = function(dp, rm) {
    var Big2 = this.constructor;
    if (dp === UNDEFINED)
      dp = 0;
    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP)
      throw Error(INVALID_DP);
    return round(new Big2(this), dp, rm === UNDEFINED ? Big2.RM : rm);
  };
  P.sqrt = function() {
    var r, c, t, x = this, Big2 = x.constructor, s = x.s, e = x.e, half = new Big2(0.5);
    if (!x.c[0])
      return new Big2(x);
    if (s < 0)
      throw Error(NAME + "No square root");
    s = Math.sqrt(x + "");
    if (s === 0 || s === 1 / 0) {
      c = x.c.join("");
      if (!(c.length + e & 1))
        c += "0";
      s = Math.sqrt(c);
      e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
      r = new Big2((s == 1 / 0 ? "1e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
    } else {
      r = new Big2(s);
    }
    e = r.e + (Big2.DP += 4);
    do {
      t = r;
      r = half.times(t.plus(x.div(t)));
    } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
    return round(r, Big2.DP -= 4, Big2.RM);
  };
  P.times = P.mul = function(y) {
    var c, x = this, Big2 = x.constructor, xc = x.c, yc = (y = new Big2(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
    y.s = x.s == y.s ? 1 : -1;
    if (!xc[0] || !yc[0])
      return new Big2(y.s * 0);
    y.e = i + j;
    if (a < b) {
      c = xc;
      xc = yc;
      yc = c;
      j = a;
      a = b;
      b = j;
    }
    for (c = new Array(j = a + b); j--; )
      c[j] = 0;
    for (i = b; i--; ) {
      b = 0;
      for (j = a + i; j > i; ) {
        b = c[j] + yc[i] * xc[j - i - 1] + b;
        c[j--] = b % 10;
        b = b / 10 | 0;
      }
      c[j] = (c[j] + b) % 10;
    }
    if (b)
      ++y.e;
    else
      c.shift();
    for (i = c.length; !c[--i]; )
      c.pop();
    y.c = c;
    return y;
  };
  P.toExponential = function(dp) {
    return stringify(this, 1, dp, dp);
  };
  P.toFixed = function(dp) {
    return stringify(this, 2, dp, this.e + dp);
  };
  P.toPrecision = function(sd) {
    return stringify(this, 3, sd, sd - 1);
  };
  P.toString = function() {
    return stringify(this);
  };
  P.valueOf = P.toJSON = function() {
    return stringify(this, 4);
  };
  var Big = _Big_();
  var big_default = Big;
});

// node_modules/loader-utils/lib/getHashDigest.js
var require_getHashDigest = __commonJS((exports2, module2) => {
  "use strict";
  var baseEncodeTables = {
    26: "abcdefghijklmnopqrstuvwxyz",
    32: "123456789abcdefghjkmnpqrstuvwxyz",
    36: "0123456789abcdefghijklmnopqrstuvwxyz",
    49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
    52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
    58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
    62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
    64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
  };
  function encodeBufferToBase(buffer, base) {
    const encodeTable = baseEncodeTables[base];
    if (!encodeTable) {
      throw new Error("Unknown encoding base" + base);
    }
    const readLength = buffer.length;
    const Big = require_big();
    Big.RM = Big.DP = 0;
    let b = new Big(0);
    for (let i = readLength - 1; i >= 0; i--) {
      b = b.times(256).plus(buffer[i]);
    }
    let output = "";
    while (b.gt(0)) {
      output = encodeTable[b.mod(base)] + output;
      b = b.div(base);
    }
    Big.DP = 20;
    Big.RM = 1;
    return output;
  }
  function getHashDigest(buffer, hashType, digestType, maxLength) {
    hashType = hashType || "md5";
    maxLength = maxLength || 9999;
    const hash = require("crypto").createHash(hashType);
    hash.update(buffer);
    if (digestType === "base26" || digestType === "base32" || digestType === "base36" || digestType === "base49" || digestType === "base52" || digestType === "base58" || digestType === "base62" || digestType === "base64") {
      return encodeBufferToBase(hash.digest(), digestType.substr(4)).substr(0, maxLength);
    } else {
      return hash.digest(digestType || "hex").substr(0, maxLength);
    }
  }
  module2.exports = getHashDigest;
});

// node_modules/emojis-list/index.js
var require_emojis_list = __commonJS((exports2, module2) => {
  module2.exports = [
    "\u{1F004}\uFE0F",
    "\u{1F0CF}",
    "\u{1F170}\uFE0F",
    "\u{1F171}\uFE0F",
    "\u{1F17E}\uFE0F",
    "\u{1F17F}\uFE0F",
    "\u{1F18E}",
    "\u{1F191}",
    "\u{1F192}",
    "\u{1F193}",
    "\u{1F194}",
    "\u{1F195}",
    "\u{1F196}",
    "\u{1F197}",
    "\u{1F198}",
    "\u{1F199}",
    "\u{1F19A}",
    "\u{1F1E6}\u{1F1E8}",
    "\u{1F1E6}\u{1F1E9}",
    "\u{1F1E6}\u{1F1EA}",
    "\u{1F1E6}\u{1F1EB}",
    "\u{1F1E6}\u{1F1EC}",
    "\u{1F1E6}\u{1F1EE}",
    "\u{1F1E6}\u{1F1F1}",
    "\u{1F1E6}\u{1F1F2}",
    "\u{1F1E6}\u{1F1F4}",
    "\u{1F1E6}\u{1F1F6}",
    "\u{1F1E6}\u{1F1F7}",
    "\u{1F1E6}\u{1F1F8}",
    "\u{1F1E6}\u{1F1F9}",
    "\u{1F1E6}\u{1F1FA}",
    "\u{1F1E6}\u{1F1FC}",
    "\u{1F1E6}\u{1F1FD}",
    "\u{1F1E6}\u{1F1FF}",
    "\u{1F1E6}",
    "\u{1F1E7}\u{1F1E6}",
    "\u{1F1E7}\u{1F1E7}",
    "\u{1F1E7}\u{1F1E9}",
    "\u{1F1E7}\u{1F1EA}",
    "\u{1F1E7}\u{1F1EB}",
    "\u{1F1E7}\u{1F1EC}",
    "\u{1F1E7}\u{1F1ED}",
    "\u{1F1E7}\u{1F1EE}",
    "\u{1F1E7}\u{1F1EF}",
    "\u{1F1E7}\u{1F1F1}",
    "\u{1F1E7}\u{1F1F2}",
    "\u{1F1E7}\u{1F1F3}",
    "\u{1F1E7}\u{1F1F4}",
    "\u{1F1E7}\u{1F1F6}",
    "\u{1F1E7}\u{1F1F7}",
    "\u{1F1E7}\u{1F1F8}",
    "\u{1F1E7}\u{1F1F9}",
    "\u{1F1E7}\u{1F1FB}",
    "\u{1F1E7}\u{1F1FC}",
    "\u{1F1E7}\u{1F1FE}",
    "\u{1F1E7}\u{1F1FF}",
    "\u{1F1E7}",
    "\u{1F1E8}\u{1F1E6}",
    "\u{1F1E8}\u{1F1E8}",
    "\u{1F1E8}\u{1F1E9}",
    "\u{1F1E8}\u{1F1EB}",
    "\u{1F1E8}\u{1F1EC}",
    "\u{1F1E8}\u{1F1ED}",
    "\u{1F1E8}\u{1F1EE}",
    "\u{1F1E8}\u{1F1F0}",
    "\u{1F1E8}\u{1F1F1}",
    "\u{1F1E8}\u{1F1F2}",
    "\u{1F1E8}\u{1F1F3}",
    "\u{1F1E8}\u{1F1F4}",
    "\u{1F1E8}\u{1F1F5}",
    "\u{1F1E8}\u{1F1F7}",
    "\u{1F1E8}\u{1F1FA}",
    "\u{1F1E8}\u{1F1FB}",
    "\u{1F1E8}\u{1F1FC}",
    "\u{1F1E8}\u{1F1FD}",
    "\u{1F1E8}\u{1F1FE}",
    "\u{1F1E8}\u{1F1FF}",
    "\u{1F1E8}",
    "\u{1F1E9}\u{1F1EA}",
    "\u{1F1E9}\u{1F1EC}",
    "\u{1F1E9}\u{1F1EF}",
    "\u{1F1E9}\u{1F1F0}",
    "\u{1F1E9}\u{1F1F2}",
    "\u{1F1E9}\u{1F1F4}",
    "\u{1F1E9}\u{1F1FF}",
    "\u{1F1E9}",
    "\u{1F1EA}\u{1F1E6}",
    "\u{1F1EA}\u{1F1E8}",
    "\u{1F1EA}\u{1F1EA}",
    "\u{1F1EA}\u{1F1EC}",
    "\u{1F1EA}\u{1F1ED}",
    "\u{1F1EA}\u{1F1F7}",
    "\u{1F1EA}\u{1F1F8}",
    "\u{1F1EA}\u{1F1F9}",
    "\u{1F1EA}\u{1F1FA}",
    "\u{1F1EA}",
    "\u{1F1EB}\u{1F1EE}",
    "\u{1F1EB}\u{1F1EF}",
    "\u{1F1EB}\u{1F1F0}",
    "\u{1F1EB}\u{1F1F2}",
    "\u{1F1EB}\u{1F1F4}",
    "\u{1F1EB}\u{1F1F7}",
    "\u{1F1EB}",
    "\u{1F1EC}\u{1F1E6}",
    "\u{1F1EC}\u{1F1E7}",
    "\u{1F1EC}\u{1F1E9}",
    "\u{1F1EC}\u{1F1EA}",
    "\u{1F1EC}\u{1F1EB}",
    "\u{1F1EC}\u{1F1EC}",
    "\u{1F1EC}\u{1F1ED}",
    "\u{1F1EC}\u{1F1EE}",
    "\u{1F1EC}\u{1F1F1}",
    "\u{1F1EC}\u{1F1F2}",
    "\u{1F1EC}\u{1F1F3}",
    "\u{1F1EC}\u{1F1F5}",
    "\u{1F1EC}\u{1F1F6}",
    "\u{1F1EC}\u{1F1F7}",
    "\u{1F1EC}\u{1F1F8}",
    "\u{1F1EC}\u{1F1F9}",
    "\u{1F1EC}\u{1F1FA}",
    "\u{1F1EC}\u{1F1FC}",
    "\u{1F1EC}\u{1F1FE}",
    "\u{1F1EC}",
    "\u{1F1ED}\u{1F1F0}",
    "\u{1F1ED}\u{1F1F2}",
    "\u{1F1ED}\u{1F1F3}",
    "\u{1F1ED}\u{1F1F7}",
    "\u{1F1ED}\u{1F1F9}",
    "\u{1F1ED}\u{1F1FA}",
    "\u{1F1ED}",
    "\u{1F1EE}\u{1F1E8}",
    "\u{1F1EE}\u{1F1E9}",
    "\u{1F1EE}\u{1F1EA}",
    "\u{1F1EE}\u{1F1F1}",
    "\u{1F1EE}\u{1F1F2}",
    "\u{1F1EE}\u{1F1F3}",
    "\u{1F1EE}\u{1F1F4}",
    "\u{1F1EE}\u{1F1F6}",
    "\u{1F1EE}\u{1F1F7}",
    "\u{1F1EE}\u{1F1F8}",
    "\u{1F1EE}\u{1F1F9}",
    "\u{1F1EE}",
    "\u{1F1EF}\u{1F1EA}",
    "\u{1F1EF}\u{1F1F2}",
    "\u{1F1EF}\u{1F1F4}",
    "\u{1F1EF}\u{1F1F5}",
    "\u{1F1EF}",
    "\u{1F1F0}\u{1F1EA}",
    "\u{1F1F0}\u{1F1EC}",
    "\u{1F1F0}\u{1F1ED}",
    "\u{1F1F0}\u{1F1EE}",
    "\u{1F1F0}\u{1F1F2}",
    "\u{1F1F0}\u{1F1F3}",
    "\u{1F1F0}\u{1F1F5}",
    "\u{1F1F0}\u{1F1F7}",
    "\u{1F1F0}\u{1F1FC}",
    "\u{1F1F0}\u{1F1FE}",
    "\u{1F1F0}\u{1F1FF}",
    "\u{1F1F0}",
    "\u{1F1F1}\u{1F1E6}",
    "\u{1F1F1}\u{1F1E7}",
    "\u{1F1F1}\u{1F1E8}",
    "\u{1F1F1}\u{1F1EE}",
    "\u{1F1F1}\u{1F1F0}",
    "\u{1F1F1}\u{1F1F7}",
    "\u{1F1F1}\u{1F1F8}",
    "\u{1F1F1}\u{1F1F9}",
    "\u{1F1F1}\u{1F1FA}",
    "\u{1F1F1}\u{1F1FB}",
    "\u{1F1F1}\u{1F1FE}",
    "\u{1F1F1}",
    "\u{1F1F2}\u{1F1E6}",
    "\u{1F1F2}\u{1F1E8}",
    "\u{1F1F2}\u{1F1E9}",
    "\u{1F1F2}\u{1F1EA}",
    "\u{1F1F2}\u{1F1EB}",
    "\u{1F1F2}\u{1F1EC}",
    "\u{1F1F2}\u{1F1ED}",
    "\u{1F1F2}\u{1F1F0}",
    "\u{1F1F2}\u{1F1F1}",
    "\u{1F1F2}\u{1F1F2}",
    "\u{1F1F2}\u{1F1F3}",
    "\u{1F1F2}\u{1F1F4}",
    "\u{1F1F2}\u{1F1F5}",
    "\u{1F1F2}\u{1F1F6}",
    "\u{1F1F2}\u{1F1F7}",
    "\u{1F1F2}\u{1F1F8}",
    "\u{1F1F2}\u{1F1F9}",
    "\u{1F1F2}\u{1F1FA}",
    "\u{1F1F2}\u{1F1FB}",
    "\u{1F1F2}\u{1F1FC}",
    "\u{1F1F2}\u{1F1FD}",
    "\u{1F1F2}\u{1F1FE}",
    "\u{1F1F2}\u{1F1FF}",
    "\u{1F1F2}",
    "\u{1F1F3}\u{1F1E6}",
    "\u{1F1F3}\u{1F1E8}",
    "\u{1F1F3}\u{1F1EA}",
    "\u{1F1F3}\u{1F1EB}",
    "\u{1F1F3}\u{1F1EC}",
    "\u{1F1F3}\u{1F1EE}",
    "\u{1F1F3}\u{1F1F1}",
    "\u{1F1F3}\u{1F1F4}",
    "\u{1F1F3}\u{1F1F5}",
    "\u{1F1F3}\u{1F1F7}",
    "\u{1F1F3}\u{1F1FA}",
    "\u{1F1F3}\u{1F1FF}",
    "\u{1F1F3}",
    "\u{1F1F4}\u{1F1F2}",
    "\u{1F1F4}",
    "\u{1F1F5}\u{1F1E6}",
    "\u{1F1F5}\u{1F1EA}",
    "\u{1F1F5}\u{1F1EB}",
    "\u{1F1F5}\u{1F1EC}",
    "\u{1F1F5}\u{1F1ED}",
    "\u{1F1F5}\u{1F1F0}",
    "\u{1F1F5}\u{1F1F1}",
    "\u{1F1F5}\u{1F1F2}",
    "\u{1F1F5}\u{1F1F3}",
    "\u{1F1F5}\u{1F1F7}",
    "\u{1F1F5}\u{1F1F8}",
    "\u{1F1F5}\u{1F1F9}",
    "\u{1F1F5}\u{1F1FC}",
    "\u{1F1F5}\u{1F1FE}",
    "\u{1F1F5}",
    "\u{1F1F6}\u{1F1E6}",
    "\u{1F1F6}",
    "\u{1F1F7}\u{1F1EA}",
    "\u{1F1F7}\u{1F1F4}",
    "\u{1F1F7}\u{1F1F8}",
    "\u{1F1F7}\u{1F1FA}",
    "\u{1F1F7}\u{1F1FC}",
    "\u{1F1F7}",
    "\u{1F1F8}\u{1F1E6}",
    "\u{1F1F8}\u{1F1E7}",
    "\u{1F1F8}\u{1F1E8}",
    "\u{1F1F8}\u{1F1E9}",
    "\u{1F1F8}\u{1F1EA}",
    "\u{1F1F8}\u{1F1EC}",
    "\u{1F1F8}\u{1F1ED}",
    "\u{1F1F8}\u{1F1EE}",
    "\u{1F1F8}\u{1F1EF}",
    "\u{1F1F8}\u{1F1F0}",
    "\u{1F1F8}\u{1F1F1}",
    "\u{1F1F8}\u{1F1F2}",
    "\u{1F1F8}\u{1F1F3}",
    "\u{1F1F8}\u{1F1F4}",
    "\u{1F1F8}\u{1F1F7}",
    "\u{1F1F8}\u{1F1F8}",
    "\u{1F1F8}\u{1F1F9}",
    "\u{1F1F8}\u{1F1FB}",
    "\u{1F1F8}\u{1F1FD}",
    "\u{1F1F8}\u{1F1FE}",
    "\u{1F1F8}\u{1F1FF}",
    "\u{1F1F8}",
    "\u{1F1F9}\u{1F1E6}",
    "\u{1F1F9}\u{1F1E8}",
    "\u{1F1F9}\u{1F1E9}",
    "\u{1F1F9}\u{1F1EB}",
    "\u{1F1F9}\u{1F1EC}",
    "\u{1F1F9}\u{1F1ED}",
    "\u{1F1F9}\u{1F1EF}",
    "\u{1F1F9}\u{1F1F0}",
    "\u{1F1F9}\u{1F1F1}",
    "\u{1F1F9}\u{1F1F2}",
    "\u{1F1F9}\u{1F1F3}",
    "\u{1F1F9}\u{1F1F4}",
    "\u{1F1F9}\u{1F1F7}",
    "\u{1F1F9}\u{1F1F9}",
    "\u{1F1F9}\u{1F1FB}",
    "\u{1F1F9}\u{1F1FC}",
    "\u{1F1F9}\u{1F1FF}",
    "\u{1F1F9}",
    "\u{1F1FA}\u{1F1E6}",
    "\u{1F1FA}\u{1F1EC}",
    "\u{1F1FA}\u{1F1F2}",
    "\u{1F1FA}\u{1F1F3}",
    "\u{1F1FA}\u{1F1F8}",
    "\u{1F1FA}\u{1F1FE}",
    "\u{1F1FA}\u{1F1FF}",
    "\u{1F1FA}",
    "\u{1F1FB}\u{1F1E6}",
    "\u{1F1FB}\u{1F1E8}",
    "\u{1F1FB}\u{1F1EA}",
    "\u{1F1FB}\u{1F1EC}",
    "\u{1F1FB}\u{1F1EE}",
    "\u{1F1FB}\u{1F1F3}",
    "\u{1F1FB}\u{1F1FA}",
    "\u{1F1FB}",
    "\u{1F1FC}\u{1F1EB}",
    "\u{1F1FC}\u{1F1F8}",
    "\u{1F1FC}",
    "\u{1F1FD}\u{1F1F0}",
    "\u{1F1FD}",
    "\u{1F1FE}\u{1F1EA}",
    "\u{1F1FE}\u{1F1F9}",
    "\u{1F1FE}",
    "\u{1F1FF}\u{1F1E6}",
    "\u{1F1FF}\u{1F1F2}",
    "\u{1F1FF}\u{1F1FC}",
    "\u{1F1FF}",
    "\u{1F201}",
    "\u{1F202}\uFE0F",
    "\u{1F21A}\uFE0F",
    "\u{1F22F}\uFE0F",
    "\u{1F232}",
    "\u{1F233}",
    "\u{1F234}",
    "\u{1F235}",
    "\u{1F236}",
    "\u{1F237}\uFE0F",
    "\u{1F238}",
    "\u{1F239}",
    "\u{1F23A}",
    "\u{1F250}",
    "\u{1F251}",
    "\u{1F300}",
    "\u{1F301}",
    "\u{1F302}",
    "\u{1F303}",
    "\u{1F304}",
    "\u{1F305}",
    "\u{1F306}",
    "\u{1F307}",
    "\u{1F308}",
    "\u{1F309}",
    "\u{1F30A}",
    "\u{1F30B}",
    "\u{1F30C}",
    "\u{1F30D}",
    "\u{1F30E}",
    "\u{1F30F}",
    "\u{1F310}",
    "\u{1F311}",
    "\u{1F312}",
    "\u{1F313}",
    "\u{1F314}",
    "\u{1F315}",
    "\u{1F316}",
    "\u{1F317}",
    "\u{1F318}",
    "\u{1F319}",
    "\u{1F31A}",
    "\u{1F31B}",
    "\u{1F31C}",
    "\u{1F31D}",
    "\u{1F31E}",
    "\u{1F31F}",
    "\u{1F320}",
    "\u{1F321}\uFE0F",
    "\u{1F324}\uFE0F",
    "\u{1F325}\uFE0F",
    "\u{1F326}\uFE0F",
    "\u{1F327}\uFE0F",
    "\u{1F328}\uFE0F",
    "\u{1F329}\uFE0F",
    "\u{1F32A}\uFE0F",
    "\u{1F32B}\uFE0F",
    "\u{1F32C}\uFE0F",
    "\u{1F32D}",
    "\u{1F32E}",
    "\u{1F32F}",
    "\u{1F330}",
    "\u{1F331}",
    "\u{1F332}",
    "\u{1F333}",
    "\u{1F334}",
    "\u{1F335}",
    "\u{1F336}\uFE0F",
    "\u{1F337}",
    "\u{1F338}",
    "\u{1F339}",
    "\u{1F33A}",
    "\u{1F33B}",
    "\u{1F33C}",
    "\u{1F33D}",
    "\u{1F33E}",
    "\u{1F33F}",
    "\u{1F340}",
    "\u{1F341}",
    "\u{1F342}",
    "\u{1F343}",
    "\u{1F344}",
    "\u{1F345}",
    "\u{1F346}",
    "\u{1F347}",
    "\u{1F348}",
    "\u{1F349}",
    "\u{1F34A}",
    "\u{1F34B}",
    "\u{1F34C}",
    "\u{1F34D}",
    "\u{1F34E}",
    "\u{1F34F}",
    "\u{1F350}",
    "\u{1F351}",
    "\u{1F352}",
    "\u{1F353}",
    "\u{1F354}",
    "\u{1F355}",
    "\u{1F356}",
    "\u{1F357}",
    "\u{1F358}",
    "\u{1F359}",
    "\u{1F35A}",
    "\u{1F35B}",
    "\u{1F35C}",
    "\u{1F35D}",
    "\u{1F35E}",
    "\u{1F35F}",
    "\u{1F360}",
    "\u{1F361}",
    "\u{1F362}",
    "\u{1F363}",
    "\u{1F364}",
    "\u{1F365}",
    "\u{1F366}",
    "\u{1F367}",
    "\u{1F368}",
    "\u{1F369}",
    "\u{1F36A}",
    "\u{1F36B}",
    "\u{1F36C}",
    "\u{1F36D}",
    "\u{1F36E}",
    "\u{1F36F}",
    "\u{1F370}",
    "\u{1F371}",
    "\u{1F372}",
    "\u{1F373}",
    "\u{1F374}",
    "\u{1F375}",
    "\u{1F376}",
    "\u{1F377}",
    "\u{1F378}",
    "\u{1F379}",
    "\u{1F37A}",
    "\u{1F37B}",
    "\u{1F37C}",
    "\u{1F37D}\uFE0F",
    "\u{1F37E}",
    "\u{1F37F}",
    "\u{1F380}",
    "\u{1F381}",
    "\u{1F382}",
    "\u{1F383}",
    "\u{1F384}",
    "\u{1F385}\u{1F3FB}",
    "\u{1F385}\u{1F3FC}",
    "\u{1F385}\u{1F3FD}",
    "\u{1F385}\u{1F3FE}",
    "\u{1F385}\u{1F3FF}",
    "\u{1F385}",
    "\u{1F386}",
    "\u{1F387}",
    "\u{1F388}",
    "\u{1F389}",
    "\u{1F38A}",
    "\u{1F38B}",
    "\u{1F38C}",
    "\u{1F38D}",
    "\u{1F38E}",
    "\u{1F38F}",
    "\u{1F390}",
    "\u{1F391}",
    "\u{1F392}",
    "\u{1F393}",
    "\u{1F396}\uFE0F",
    "\u{1F397}\uFE0F",
    "\u{1F399}\uFE0F",
    "\u{1F39A}\uFE0F",
    "\u{1F39B}\uFE0F",
    "\u{1F39E}\uFE0F",
    "\u{1F39F}\uFE0F",
    "\u{1F3A0}",
    "\u{1F3A1}",
    "\u{1F3A2}",
    "\u{1F3A3}",
    "\u{1F3A4}",
    "\u{1F3A5}",
    "\u{1F3A6}",
    "\u{1F3A7}",
    "\u{1F3A8}",
    "\u{1F3A9}",
    "\u{1F3AA}",
    "\u{1F3AB}",
    "\u{1F3AC}",
    "\u{1F3AD}",
    "\u{1F3AE}",
    "\u{1F3AF}",
    "\u{1F3B0}",
    "\u{1F3B1}",
    "\u{1F3B2}",
    "\u{1F3B3}",
    "\u{1F3B4}",
    "\u{1F3B5}",
    "\u{1F3B6}",
    "\u{1F3B7}",
    "\u{1F3B8}",
    "\u{1F3B9}",
    "\u{1F3BA}",
    "\u{1F3BB}",
    "\u{1F3BC}",
    "\u{1F3BD}",
    "\u{1F3BE}",
    "\u{1F3BF}",
    "\u{1F3C0}",
    "\u{1F3C1}",
    "\u{1F3C2}\u{1F3FB}",
    "\u{1F3C2}\u{1F3FC}",
    "\u{1F3C2}\u{1F3FD}",
    "\u{1F3C2}\u{1F3FE}",
    "\u{1F3C2}\u{1F3FF}",
    "\u{1F3C2}",
    "\u{1F3C3}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F3C3}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F3C3}\u{1F3FB}",
    "\u{1F3C3}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F3C3}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F3C3}\u{1F3FC}",
    "\u{1F3C3}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F3C3}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F3C3}\u{1F3FD}",
    "\u{1F3C3}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F3C3}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F3C3}\u{1F3FE}",
    "\u{1F3C3}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F3C3}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F3C3}\u{1F3FF}",
    "\u{1F3C3}\u200D\u2640\uFE0F",
    "\u{1F3C3}\u200D\u2642\uFE0F",
    "\u{1F3C3}",
    "\u{1F3C4}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F3C4}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F3C4}\u{1F3FB}",
    "\u{1F3C4}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F3C4}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F3C4}\u{1F3FC}",
    "\u{1F3C4}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F3C4}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F3C4}\u{1F3FD}",
    "\u{1F3C4}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F3C4}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F3C4}\u{1F3FE}",
    "\u{1F3C4}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F3C4}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F3C4}\u{1F3FF}",
    "\u{1F3C4}\u200D\u2640\uFE0F",
    "\u{1F3C4}\u200D\u2642\uFE0F",
    "\u{1F3C4}",
    "\u{1F3C5}",
    "\u{1F3C6}",
    "\u{1F3C7}\u{1F3FB}",
    "\u{1F3C7}\u{1F3FC}",
    "\u{1F3C7}\u{1F3FD}",
    "\u{1F3C7}\u{1F3FE}",
    "\u{1F3C7}\u{1F3FF}",
    "\u{1F3C7}",
    "\u{1F3C8}",
    "\u{1F3C9}",
    "\u{1F3CA}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F3CA}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F3CA}\u{1F3FB}",
    "\u{1F3CA}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F3CA}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F3CA}\u{1F3FC}",
    "\u{1F3CA}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F3CA}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F3CA}\u{1F3FD}",
    "\u{1F3CA}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F3CA}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F3CA}\u{1F3FE}",
    "\u{1F3CA}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F3CA}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F3CA}\u{1F3FF}",
    "\u{1F3CA}\u200D\u2640\uFE0F",
    "\u{1F3CA}\u200D\u2642\uFE0F",
    "\u{1F3CA}",
    "\u{1F3CB}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F3CB}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F3CB}\u{1F3FB}",
    "\u{1F3CB}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F3CB}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F3CB}\u{1F3FC}",
    "\u{1F3CB}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F3CB}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F3CB}\u{1F3FD}",
    "\u{1F3CB}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F3CB}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F3CB}\u{1F3FE}",
    "\u{1F3CB}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F3CB}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F3CB}\u{1F3FF}",
    "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F",
    "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F",
    "\u{1F3CB}\uFE0F",
    "\u{1F3CC}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F3CC}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F3CC}\u{1F3FB}",
    "\u{1F3CC}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F3CC}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F3CC}\u{1F3FC}",
    "\u{1F3CC}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F3CC}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F3CC}\u{1F3FD}",
    "\u{1F3CC}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F3CC}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F3CC}\u{1F3FE}",
    "\u{1F3CC}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F3CC}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F3CC}\u{1F3FF}",
    "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F",
    "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F",
    "\u{1F3CC}\uFE0F",
    "\u{1F3CD}\uFE0F",
    "\u{1F3CE}\uFE0F",
    "\u{1F3CF}",
    "\u{1F3D0}",
    "\u{1F3D1}",
    "\u{1F3D2}",
    "\u{1F3D3}",
    "\u{1F3D4}\uFE0F",
    "\u{1F3D5}\uFE0F",
    "\u{1F3D6}\uFE0F",
    "\u{1F3D7}\uFE0F",
    "\u{1F3D8}\uFE0F",
    "\u{1F3D9}\uFE0F",
    "\u{1F3DA}\uFE0F",
    "\u{1F3DB}\uFE0F",
    "\u{1F3DC}\uFE0F",
    "\u{1F3DD}\uFE0F",
    "\u{1F3DE}\uFE0F",
    "\u{1F3DF}\uFE0F",
    "\u{1F3E0}",
    "\u{1F3E1}",
    "\u{1F3E2}",
    "\u{1F3E3}",
    "\u{1F3E4}",
    "\u{1F3E5}",
    "\u{1F3E6}",
    "\u{1F3E7}",
    "\u{1F3E8}",
    "\u{1F3E9}",
    "\u{1F3EA}",
    "\u{1F3EB}",
    "\u{1F3EC}",
    "\u{1F3ED}",
    "\u{1F3EE}",
    "\u{1F3EF}",
    "\u{1F3F0}",
    "\u{1F3F3}\uFE0F\u200D\u{1F308}",
    "\u{1F3F3}\uFE0F",
    "\u{1F3F4}\u200D\u2620\uFE0F",
    "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}",
    "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}",
    "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}",
    "\u{1F3F4}",
    "\u{1F3F5}\uFE0F",
    "\u{1F3F7}\uFE0F",
    "\u{1F3F8}",
    "\u{1F3F9}",
    "\u{1F3FA}",
    "\u{1F3FB}",
    "\u{1F3FC}",
    "\u{1F3FD}",
    "\u{1F3FE}",
    "\u{1F3FF}",
    "\u{1F400}",
    "\u{1F401}",
    "\u{1F402}",
    "\u{1F403}",
    "\u{1F404}",
    "\u{1F405}",
    "\u{1F406}",
    "\u{1F407}",
    "\u{1F408}",
    "\u{1F409}",
    "\u{1F40A}",
    "\u{1F40B}",
    "\u{1F40C}",
    "\u{1F40D}",
    "\u{1F40E}",
    "\u{1F40F}",
    "\u{1F410}",
    "\u{1F411}",
    "\u{1F412}",
    "\u{1F413}",
    "\u{1F414}",
    "\u{1F415}\u200D\u{1F9BA}",
    "\u{1F415}",
    "\u{1F416}",
    "\u{1F417}",
    "\u{1F418}",
    "\u{1F419}",
    "\u{1F41A}",
    "\u{1F41B}",
    "\u{1F41C}",
    "\u{1F41D}",
    "\u{1F41E}",
    "\u{1F41F}",
    "\u{1F420}",
    "\u{1F421}",
    "\u{1F422}",
    "\u{1F423}",
    "\u{1F424}",
    "\u{1F425}",
    "\u{1F426}",
    "\u{1F427}",
    "\u{1F428}",
    "\u{1F429}",
    "\u{1F42A}",
    "\u{1F42B}",
    "\u{1F42C}",
    "\u{1F42D}",
    "\u{1F42E}",
    "\u{1F42F}",
    "\u{1F430}",
    "\u{1F431}",
    "\u{1F432}",
    "\u{1F433}",
    "\u{1F434}",
    "\u{1F435}",
    "\u{1F436}",
    "\u{1F437}",
    "\u{1F438}",
    "\u{1F439}",
    "\u{1F43A}",
    "\u{1F43B}",
    "\u{1F43C}",
    "\u{1F43D}",
    "\u{1F43E}",
    "\u{1F43F}\uFE0F",
    "\u{1F440}",
    "\u{1F441}\u200D\u{1F5E8}",
    "\u{1F441}\uFE0F",
    "\u{1F442}\u{1F3FB}",
    "\u{1F442}\u{1F3FC}",
    "\u{1F442}\u{1F3FD}",
    "\u{1F442}\u{1F3FE}",
    "\u{1F442}\u{1F3FF}",
    "\u{1F442}",
    "\u{1F443}\u{1F3FB}",
    "\u{1F443}\u{1F3FC}",
    "\u{1F443}\u{1F3FD}",
    "\u{1F443}\u{1F3FE}",
    "\u{1F443}\u{1F3FF}",
    "\u{1F443}",
    "\u{1F444}",
    "\u{1F445}",
    "\u{1F446}\u{1F3FB}",
    "\u{1F446}\u{1F3FC}",
    "\u{1F446}\u{1F3FD}",
    "\u{1F446}\u{1F3FE}",
    "\u{1F446}\u{1F3FF}",
    "\u{1F446}",
    "\u{1F447}\u{1F3FB}",
    "\u{1F447}\u{1F3FC}",
    "\u{1F447}\u{1F3FD}",
    "\u{1F447}\u{1F3FE}",
    "\u{1F447}\u{1F3FF}",
    "\u{1F447}",
    "\u{1F448}\u{1F3FB}",
    "\u{1F448}\u{1F3FC}",
    "\u{1F448}\u{1F3FD}",
    "\u{1F448}\u{1F3FE}",
    "\u{1F448}\u{1F3FF}",
    "\u{1F448}",
    "\u{1F449}\u{1F3FB}",
    "\u{1F449}\u{1F3FC}",
    "\u{1F449}\u{1F3FD}",
    "\u{1F449}\u{1F3FE}",
    "\u{1F449}\u{1F3FF}",
    "\u{1F449}",
    "\u{1F44A}\u{1F3FB}",
    "\u{1F44A}\u{1F3FC}",
    "\u{1F44A}\u{1F3FD}",
    "\u{1F44A}\u{1F3FE}",
    "\u{1F44A}\u{1F3FF}",
    "\u{1F44A}",
    "\u{1F44B}\u{1F3FB}",
    "\u{1F44B}\u{1F3FC}",
    "\u{1F44B}\u{1F3FD}",
    "\u{1F44B}\u{1F3FE}",
    "\u{1F44B}\u{1F3FF}",
    "\u{1F44B}",
    "\u{1F44C}\u{1F3FB}",
    "\u{1F44C}\u{1F3FC}",
    "\u{1F44C}\u{1F3FD}",
    "\u{1F44C}\u{1F3FE}",
    "\u{1F44C}\u{1F3FF}",
    "\u{1F44C}",
    "\u{1F44D}\u{1F3FB}",
    "\u{1F44D}\u{1F3FC}",
    "\u{1F44D}\u{1F3FD}",
    "\u{1F44D}\u{1F3FE}",
    "\u{1F44D}\u{1F3FF}",
    "\u{1F44D}",
    "\u{1F44E}\u{1F3FB}",
    "\u{1F44E}\u{1F3FC}",
    "\u{1F44E}\u{1F3FD}",
    "\u{1F44E}\u{1F3FE}",
    "\u{1F44E}\u{1F3FF}",
    "\u{1F44E}",
    "\u{1F44F}\u{1F3FB}",
    "\u{1F44F}\u{1F3FC}",
    "\u{1F44F}\u{1F3FD}",
    "\u{1F44F}\u{1F3FE}",
    "\u{1F44F}\u{1F3FF}",
    "\u{1F44F}",
    "\u{1F450}\u{1F3FB}",
    "\u{1F450}\u{1F3FC}",
    "\u{1F450}\u{1F3FD}",
    "\u{1F450}\u{1F3FE}",
    "\u{1F450}\u{1F3FF}",
    "\u{1F450}",
    "\u{1F451}",
    "\u{1F452}",
    "\u{1F453}",
    "\u{1F454}",
    "\u{1F455}",
    "\u{1F456}",
    "\u{1F457}",
    "\u{1F458}",
    "\u{1F459}",
    "\u{1F45A}",
    "\u{1F45B}",
    "\u{1F45C}",
    "\u{1F45D}",
    "\u{1F45E}",
    "\u{1F45F}",
    "\u{1F460}",
    "\u{1F461}",
    "\u{1F462}",
    "\u{1F463}",
    "\u{1F464}",
    "\u{1F465}",
    "\u{1F466}\u{1F3FB}",
    "\u{1F466}\u{1F3FC}",
    "\u{1F466}\u{1F3FD}",
    "\u{1F466}\u{1F3FE}",
    "\u{1F466}\u{1F3FF}",
    "\u{1F466}",
    "\u{1F467}\u{1F3FB}",
    "\u{1F467}\u{1F3FC}",
    "\u{1F467}\u{1F3FD}",
    "\u{1F467}\u{1F3FE}",
    "\u{1F467}\u{1F3FF}",
    "\u{1F467}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F33E}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F373}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F393}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F3A4}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F3A8}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F3EB}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F3ED}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F4BB}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F4BC}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F527}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F52C}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F680}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F692}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F9AF}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F9B0}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F9B1}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F9B2}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F9B3}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F9BC}",
    "\u{1F468}\u{1F3FB}\u200D\u{1F9BD}",
    "\u{1F468}\u{1F3FB}\u200D\u2695\uFE0F",
    "\u{1F468}\u{1F3FB}\u200D\u2696\uFE0F",
    "\u{1F468}\u{1F3FB}\u200D\u2708\uFE0F",
    "\u{1F468}\u{1F3FB}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F33E}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F373}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F393}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F3A4}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F3A8}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F3EB}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F3ED}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F4BB}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F4BC}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F527}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F52C}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F680}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F692}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F9AF}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F9B0}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F9B1}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F9B2}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F9B3}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F9BC}",
    "\u{1F468}\u{1F3FC}\u200D\u{1F9BD}",
    "\u{1F468}\u{1F3FC}\u200D\u2695\uFE0F",
    "\u{1F468}\u{1F3FC}\u200D\u2696\uFE0F",
    "\u{1F468}\u{1F3FC}\u200D\u2708\uFE0F",
    "\u{1F468}\u{1F3FC}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F33E}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F373}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F393}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F3A4}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F3A8}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F3EB}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F3ED}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F4BB}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F4BC}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F527}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F52C}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F680}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F692}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F9AF}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F9B0}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F9B1}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F9B2}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F9B3}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F9BC}",
    "\u{1F468}\u{1F3FD}\u200D\u{1F9BD}",
    "\u{1F468}\u{1F3FD}\u200D\u2695\uFE0F",
    "\u{1F468}\u{1F3FD}\u200D\u2696\uFE0F",
    "\u{1F468}\u{1F3FD}\u200D\u2708\uFE0F",
    "\u{1F468}\u{1F3FD}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F33E}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F373}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F393}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F3A4}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F3A8}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F3EB}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F3ED}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F4BB}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F4BC}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F527}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F52C}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F680}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F692}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F9AF}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F9B0}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F9B1}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F9B2}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F9B3}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F9BC}",
    "\u{1F468}\u{1F3FE}\u200D\u{1F9BD}",
    "\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F",
    "\u{1F468}\u{1F3FE}\u200D\u2696\uFE0F",
    "\u{1F468}\u{1F3FE}\u200D\u2708\uFE0F",
    "\u{1F468}\u{1F3FE}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F33E}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F373}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F393}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F3A4}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F3A8}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F3EB}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F3ED}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F4BB}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F4BC}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F527}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F52C}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F680}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F692}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F9AF}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F9B0}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F9B1}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F9B2}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F9B3}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F9BC}",
    "\u{1F468}\u{1F3FF}\u200D\u{1F9BD}",
    "\u{1F468}\u{1F3FF}\u200D\u2695\uFE0F",
    "\u{1F468}\u{1F3FF}\u200D\u2696\uFE0F",
    "\u{1F468}\u{1F3FF}\u200D\u2708\uFE0F",
    "\u{1F468}\u{1F3FF}",
    "\u{1F468}\u200D\u{1F33E}",
    "\u{1F468}\u200D\u{1F373}",
    "\u{1F468}\u200D\u{1F393}",
    "\u{1F468}\u200D\u{1F3A4}",
    "\u{1F468}\u200D\u{1F3A8}",
    "\u{1F468}\u200D\u{1F3EB}",
    "\u{1F468}\u200D\u{1F3ED}",
    "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
    "\u{1F468}\u200D\u{1F466}",
    "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
    "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
    "\u{1F468}\u200D\u{1F467}",
    "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
    "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}",
    "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
    "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
    "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}",
    "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
    "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}",
    "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
    "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
    "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}",
    "\u{1F468}\u200D\u{1F4BB}",
    "\u{1F468}\u200D\u{1F4BC}",
    "\u{1F468}\u200D\u{1F527}",
    "\u{1F468}\u200D\u{1F52C}",
    "\u{1F468}\u200D\u{1F680}",
    "\u{1F468}\u200D\u{1F692}",
    "\u{1F468}\u200D\u{1F9AF}",
    "\u{1F468}\u200D\u{1F9B0}",
    "\u{1F468}\u200D\u{1F9B1}",
    "\u{1F468}\u200D\u{1F9B2}",
    "\u{1F468}\u200D\u{1F9B3}",
    "\u{1F468}\u200D\u{1F9BC}",
    "\u{1F468}\u200D\u{1F9BD}",
    "\u{1F468}\u200D\u2695\uFE0F",
    "\u{1F468}\u200D\u2696\uFE0F",
    "\u{1F468}\u200D\u2708\uFE0F",
    "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}",
    "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
    "\u{1F468}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F33E}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F373}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F393}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F3A4}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F3A8}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F3EB}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F3ED}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F4BB}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F4BC}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F527}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F52C}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F680}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F692}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F9AF}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F9B0}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F9B1}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F9B2}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F9B3}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F9BC}",
    "\u{1F469}\u{1F3FB}\u200D\u{1F9BD}",
    "\u{1F469}\u{1F3FB}\u200D\u2695\uFE0F",
    "\u{1F469}\u{1F3FB}\u200D\u2696\uFE0F",
    "\u{1F469}\u{1F3FB}\u200D\u2708\uFE0F",
    "\u{1F469}\u{1F3FB}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F33E}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F373}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F393}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F3A4}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F3A8}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F3EB}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F3ED}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F4BB}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F4BC}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F527}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F52C}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F680}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F692}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F9AF}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F9B0}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F9B1}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F9B2}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F9B3}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F9BC}",
    "\u{1F469}\u{1F3FC}\u200D\u{1F9BD}",
    "\u{1F469}\u{1F3FC}\u200D\u2695\uFE0F",
    "\u{1F469}\u{1F3FC}\u200D\u2696\uFE0F",
    "\u{1F469}\u{1F3FC}\u200D\u2708\uFE0F",
    "\u{1F469}\u{1F3FC}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F33E}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F373}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F393}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F3A4}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F3A8}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F3EB}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F3ED}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F4BB}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F4BC}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F527}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F52C}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F680}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F692}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F9AF}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F9B0}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F9B1}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F9B2}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F9B3}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F9BC}",
    "\u{1F469}\u{1F3FD}\u200D\u{1F9BD}",
    "\u{1F469}\u{1F3FD}\u200D\u2695\uFE0F",
    "\u{1F469}\u{1F3FD}\u200D\u2696\uFE0F",
    "\u{1F469}\u{1F3FD}\u200D\u2708\uFE0F",
    "\u{1F469}\u{1F3FD}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F33E}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F373}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F393}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F3A4}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F3A8}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F3EB}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F3ED}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F4BB}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F4BC}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F527}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F52C}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F680}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F692}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F9AF}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F9B0}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F9B1}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F9B2}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F9B3}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F9BC}",
    "\u{1F469}\u{1F3FE}\u200D\u{1F9BD}",
    "\u{1F469}\u{1F3FE}\u200D\u2695\uFE0F",
    "\u{1F469}\u{1F3FE}\u200D\u2696\uFE0F",
    "\u{1F469}\u{1F3FE}\u200D\u2708\uFE0F",
    "\u{1F469}\u{1F3FE}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F33E}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F373}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F393}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F3A4}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F3A8}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F3EB}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F3ED}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F4BB}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F4BC}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F527}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F52C}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F680}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F692}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F9AF}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F9B0}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F9B1}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F9B2}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F9B3}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F9BC}",
    "\u{1F469}\u{1F3FF}\u200D\u{1F9BD}",
    "\u{1F469}\u{1F3FF}\u200D\u2695\uFE0F",
    "\u{1F469}\u{1F3FF}\u200D\u2696\uFE0F",
    "\u{1F469}\u{1F3FF}\u200D\u2708\uFE0F",
    "\u{1F469}\u{1F3FF}",
    "\u{1F469}\u200D\u{1F33E}",
    "\u{1F469}\u200D\u{1F373}",
    "\u{1F469}\u200D\u{1F393}",
    "\u{1F469}\u200D\u{1F3A4}",
    "\u{1F469}\u200D\u{1F3A8}",
    "\u{1F469}\u200D\u{1F3EB}",
    "\u{1F469}\u200D\u{1F3ED}",
    "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
    "\u{1F469}\u200D\u{1F466}",
    "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
    "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
    "\u{1F469}\u200D\u{1F467}",
    "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
    "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}",
    "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
    "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
    "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}",
    "\u{1F469}\u200D\u{1F4BB}",
    "\u{1F469}\u200D\u{1F4BC}",
    "\u{1F469}\u200D\u{1F527}",
    "\u{1F469}\u200D\u{1F52C}",
    "\u{1F469}\u200D\u{1F680}",
    "\u{1F469}\u200D\u{1F692}",
    "\u{1F469}\u200D\u{1F9AF}",
    "\u{1F469}\u200D\u{1F9B0}",
    "\u{1F469}\u200D\u{1F9B1}",
    "\u{1F469}\u200D\u{1F9B2}",
    "\u{1F469}\u200D\u{1F9B3}",
    "\u{1F469}\u200D\u{1F9BC}",
    "\u{1F469}\u200D\u{1F9BD}",
    "\u{1F469}\u200D\u2695\uFE0F",
    "\u{1F469}\u200D\u2696\uFE0F",
    "\u{1F469}\u200D\u2708\uFE0F",
    "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}",
    "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}",
    "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
    "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}",
    "\u{1F469}",
    "\u{1F46A}",
    "\u{1F46B}\u{1F3FB}",
    "\u{1F46B}\u{1F3FC}",
    "\u{1F46B}\u{1F3FD}",
    "\u{1F46B}\u{1F3FE}",
    "\u{1F46B}\u{1F3FF}",
    "\u{1F46B}",
    "\u{1F46C}\u{1F3FB}",
    "\u{1F46C}\u{1F3FC}",
    "\u{1F46C}\u{1F3FD}",
    "\u{1F46C}\u{1F3FE}",
    "\u{1F46C}\u{1F3FF}",
    "\u{1F46C}",
    "\u{1F46D}\u{1F3FB}",
    "\u{1F46D}\u{1F3FC}",
    "\u{1F46D}\u{1F3FD}",
    "\u{1F46D}\u{1F3FE}",
    "\u{1F46D}\u{1F3FF}",
    "\u{1F46D}",
    "\u{1F46E}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F46E}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F46E}\u{1F3FB}",
    "\u{1F46E}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F46E}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F46E}\u{1F3FC}",
    "\u{1F46E}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F46E}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F46E}\u{1F3FD}",
    "\u{1F46E}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F46E}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F46E}\u{1F3FE}",
    "\u{1F46E}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F46E}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F46E}\u{1F3FF}",
    "\u{1F46E}\u200D\u2640\uFE0F",
    "\u{1F46E}\u200D\u2642\uFE0F",
    "\u{1F46E}",
    "\u{1F46F}\u200D\u2640\uFE0F",
    "\u{1F46F}\u200D\u2642\uFE0F",
    "\u{1F46F}",
    "\u{1F470}\u{1F3FB}",
    "\u{1F470}\u{1F3FC}",
    "\u{1F470}\u{1F3FD}",
    "\u{1F470}\u{1F3FE}",
    "\u{1F470}\u{1F3FF}",
    "\u{1F470}",
    "\u{1F471}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F471}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F471}\u{1F3FB}",
    "\u{1F471}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F471}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F471}\u{1F3FC}",
    "\u{1F471}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F471}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F471}\u{1F3FD}",
    "\u{1F471}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F471}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F471}\u{1F3FE}",
    "\u{1F471}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F471}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F471}\u{1F3FF}",
    "\u{1F471}\u200D\u2640\uFE0F",
    "\u{1F471}\u200D\u2642\uFE0F",
    "\u{1F471}",
    "\u{1F472}\u{1F3FB}",
    "\u{1F472}\u{1F3FC}",
    "\u{1F472}\u{1F3FD}",
    "\u{1F472}\u{1F3FE}",
    "\u{1F472}\u{1F3FF}",
    "\u{1F472}",
    "\u{1F473}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F473}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F473}\u{1F3FB}",
    "\u{1F473}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F473}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F473}\u{1F3FC}",
    "\u{1F473}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F473}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F473}\u{1F3FD}",
    "\u{1F473}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F473}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F473}\u{1F3FE}",
    "\u{1F473}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F473}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F473}\u{1F3FF}",
    "\u{1F473}\u200D\u2640\uFE0F",
    "\u{1F473}\u200D\u2642\uFE0F",
    "\u{1F473}",
    "\u{1F474}\u{1F3FB}",
    "\u{1F474}\u{1F3FC}",
    "\u{1F474}\u{1F3FD}",
    "\u{1F474}\u{1F3FE}",
    "\u{1F474}\u{1F3FF}",
    "\u{1F474}",
    "\u{1F475}\u{1F3FB}",
    "\u{1F475}\u{1F3FC}",
    "\u{1F475}\u{1F3FD}",
    "\u{1F475}\u{1F3FE}",
    "\u{1F475}\u{1F3FF}",
    "\u{1F475}",
    "\u{1F476}\u{1F3FB}",
    "\u{1F476}\u{1F3FC}",
    "\u{1F476}\u{1F3FD}",
    "\u{1F476}\u{1F3FE}",
    "\u{1F476}\u{1F3FF}",
    "\u{1F476}",
    "\u{1F477}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F477}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F477}\u{1F3FB}",
    "\u{1F477}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F477}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F477}\u{1F3FC}",
    "\u{1F477}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F477}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F477}\u{1F3FD}",
    "\u{1F477}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F477}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F477}\u{1F3FE}",
    "\u{1F477}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F477}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F477}\u{1F3FF}",
    "\u{1F477}\u200D\u2640\uFE0F",
    "\u{1F477}\u200D\u2642\uFE0F",
    "\u{1F477}",
    "\u{1F478}\u{1F3FB}",
    "\u{1F478}\u{1F3FC}",
    "\u{1F478}\u{1F3FD}",
    "\u{1F478}\u{1F3FE}",
    "\u{1F478}\u{1F3FF}",
    "\u{1F478}",
    "\u{1F479}",
    "\u{1F47A}",
    "\u{1F47B}",
    "\u{1F47C}\u{1F3FB}",
    "\u{1F47C}\u{1F3FC}",
    "\u{1F47C}\u{1F3FD}",
    "\u{1F47C}\u{1F3FE}",
    "\u{1F47C}\u{1F3FF}",
    "\u{1F47C}",
    "\u{1F47D}",
    "\u{1F47E}",
    "\u{1F47F}",
    "\u{1F480}",
    "\u{1F481}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F481}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F481}\u{1F3FB}",
    "\u{1F481}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F481}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F481}\u{1F3FC}",
    "\u{1F481}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F481}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F481}\u{1F3FD}",
    "\u{1F481}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F481}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F481}\u{1F3FE}",
    "\u{1F481}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F481}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F481}\u{1F3FF}",
    "\u{1F481}\u200D\u2640\uFE0F",
    "\u{1F481}\u200D\u2642\uFE0F",
    "\u{1F481}",
    "\u{1F482}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F482}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F482}\u{1F3FB}",
    "\u{1F482}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F482}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F482}\u{1F3FC}",
    "\u{1F482}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F482}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F482}\u{1F3FD}",
    "\u{1F482}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F482}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F482}\u{1F3FE}",
    "\u{1F482}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F482}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F482}\u{1F3FF}",
    "\u{1F482}\u200D\u2640\uFE0F",
    "\u{1F482}\u200D\u2642\uFE0F",
    "\u{1F482}",
    "\u{1F483}\u{1F3FB}",
    "\u{1F483}\u{1F3FC}",
    "\u{1F483}\u{1F3FD}",
    "\u{1F483}\u{1F3FE}",
    "\u{1F483}\u{1F3FF}",
    "\u{1F483}",
    "\u{1F484}",
    "\u{1F485}\u{1F3FB}",
    "\u{1F485}\u{1F3FC}",
    "\u{1F485}\u{1F3FD}",
    "\u{1F485}\u{1F3FE}",
    "\u{1F485}\u{1F3FF}",
    "\u{1F485}",
    "\u{1F486}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F486}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F486}\u{1F3FB}",
    "\u{1F486}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F486}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F486}\u{1F3FC}",
    "\u{1F486}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F486}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F486}\u{1F3FD}",
    "\u{1F486}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F486}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F486}\u{1F3FE}",
    "\u{1F486}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F486}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F486}\u{1F3FF}",
    "\u{1F486}\u200D\u2640\uFE0F",
    "\u{1F486}\u200D\u2642\uFE0F",
    "\u{1F486}",
    "\u{1F487}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F487}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F487}\u{1F3FB}",
    "\u{1F487}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F487}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F487}\u{1F3FC}",
    "\u{1F487}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F487}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F487}\u{1F3FD}",
    "\u{1F487}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F487}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F487}\u{1F3FE}",
    "\u{1F487}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F487}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F487}\u{1F3FF}",
    "\u{1F487}\u200D\u2640\uFE0F",
    "\u{1F487}\u200D\u2642\uFE0F",
    "\u{1F487}",
    "\u{1F488}",
    "\u{1F489}",
    "\u{1F48A}",
    "\u{1F48B}",
    "\u{1F48C}",
    "\u{1F48D}",
    "\u{1F48E}",
    "\u{1F48F}",
    "\u{1F490}",
    "\u{1F491}",
    "\u{1F492}",
    "\u{1F493}",
    "\u{1F494}",
    "\u{1F495}",
    "\u{1F496}",
    "\u{1F497}",
    "\u{1F498}",
    "\u{1F499}",
    "\u{1F49A}",
    "\u{1F49B}",
    "\u{1F49C}",
    "\u{1F49D}",
    "\u{1F49E}",
    "\u{1F49F}",
    "\u{1F4A0}",
    "\u{1F4A1}",
    "\u{1F4A2}",
    "\u{1F4A3}",
    "\u{1F4A4}",
    "\u{1F4A5}",
    "\u{1F4A6}",
    "\u{1F4A7}",
    "\u{1F4A8}",
    "\u{1F4A9}",
    "\u{1F4AA}\u{1F3FB}",
    "\u{1F4AA}\u{1F3FC}",
    "\u{1F4AA}\u{1F3FD}",
    "\u{1F4AA}\u{1F3FE}",
    "\u{1F4AA}\u{1F3FF}",
    "\u{1F4AA}",
    "\u{1F4AB}",
    "\u{1F4AC}",
    "\u{1F4AD}",
    "\u{1F4AE}",
    "\u{1F4AF}",
    "\u{1F4B0}",
    "\u{1F4B1}",
    "\u{1F4B2}",
    "\u{1F4B3}",
    "\u{1F4B4}",
    "\u{1F4B5}",
    "\u{1F4B6}",
    "\u{1F4B7}",
    "\u{1F4B8}",
    "\u{1F4B9}",
    "\u{1F4BA}",
    "\u{1F4BB}",
    "\u{1F4BC}",
    "\u{1F4BD}",
    "\u{1F4BE}",
    "\u{1F4BF}",
    "\u{1F4C0}",
    "\u{1F4C1}",
    "\u{1F4C2}",
    "\u{1F4C3}",
    "\u{1F4C4}",
    "\u{1F4C5}",
    "\u{1F4C6}",
    "\u{1F4C7}",
    "\u{1F4C8}",
    "\u{1F4C9}",
    "\u{1F4CA}",
    "\u{1F4CB}",
    "\u{1F4CC}",
    "\u{1F4CD}",
    "\u{1F4CE}",
    "\u{1F4CF}",
    "\u{1F4D0}",
    "\u{1F4D1}",
    "\u{1F4D2}",
    "\u{1F4D3}",
    "\u{1F4D4}",
    "\u{1F4D5}",
    "\u{1F4D6}",
    "\u{1F4D7}",
    "\u{1F4D8}",
    "\u{1F4D9}",
    "\u{1F4DA}",
    "\u{1F4DB}",
    "\u{1F4DC}",
    "\u{1F4DD}",
    "\u{1F4DE}",
    "\u{1F4DF}",
    "\u{1F4E0}",
    "\u{1F4E1}",
    "\u{1F4E2}",
    "\u{1F4E3}",
    "\u{1F4E4}",
    "\u{1F4E5}",
    "\u{1F4E6}",
    "\u{1F4E7}",
    "\u{1F4E8}",
    "\u{1F4E9}",
    "\u{1F4EA}",
    "\u{1F4EB}",
    "\u{1F4EC}",
    "\u{1F4ED}",
    "\u{1F4EE}",
    "\u{1F4EF}",
    "\u{1F4F0}",
    "\u{1F4F1}",
    "\u{1F4F2}",
    "\u{1F4F3}",
    "\u{1F4F4}",
    "\u{1F4F5}",
    "\u{1F4F6}",
    "\u{1F4F7}",
    "\u{1F4F8}",
    "\u{1F4F9}",
    "\u{1F4FA}",
    "\u{1F4FB}",
    "\u{1F4FC}",
    "\u{1F4FD}\uFE0F",
    "\u{1F4FF}",
    "\u{1F500}",
    "\u{1F501}",
    "\u{1F502}",
    "\u{1F503}",
    "\u{1F504}",
    "\u{1F505}",
    "\u{1F506}",
    "\u{1F507}",
    "\u{1F508}",
    "\u{1F509}",
    "\u{1F50A}",
    "\u{1F50B}",
    "\u{1F50C}",
    "\u{1F50D}",
    "\u{1F50E}",
    "\u{1F50F}",
    "\u{1F510}",
    "\u{1F511}",
    "\u{1F512}",
    "\u{1F513}",
    "\u{1F514}",
    "\u{1F515}",
    "\u{1F516}",
    "\u{1F517}",
    "\u{1F518}",
    "\u{1F519}",
    "\u{1F51A}",
    "\u{1F51B}",
    "\u{1F51C}",
    "\u{1F51D}",
    "\u{1F51E}",
    "\u{1F51F}",
    "\u{1F520}",
    "\u{1F521}",
    "\u{1F522}",
    "\u{1F523}",
    "\u{1F524}",
    "\u{1F525}",
    "\u{1F526}",
    "\u{1F527}",
    "\u{1F528}",
    "\u{1F529}",
    "\u{1F52A}",
    "\u{1F52B}",
    "\u{1F52C}",
    "\u{1F52D}",
    "\u{1F52E}",
    "\u{1F52F}",
    "\u{1F530}",
    "\u{1F531}",
    "\u{1F532}",
    "\u{1F533}",
    "\u{1F534}",
    "\u{1F535}",
    "\u{1F536}",
    "\u{1F537}",
    "\u{1F538}",
    "\u{1F539}",
    "\u{1F53A}",
    "\u{1F53B}",
    "\u{1F53C}",
    "\u{1F53D}",
    "\u{1F549}\uFE0F",
    "\u{1F54A}\uFE0F",
    "\u{1F54B}",
    "\u{1F54C}",
    "\u{1F54D}",
    "\u{1F54E}",
    "\u{1F550}",
    "\u{1F551}",
    "\u{1F552}",
    "\u{1F553}",
    "\u{1F554}",
    "\u{1F555}",
    "\u{1F556}",
    "\u{1F557}",
    "\u{1F558}",
    "\u{1F559}",
    "\u{1F55A}",
    "\u{1F55B}",
    "\u{1F55C}",
    "\u{1F55D}",
    "\u{1F55E}",
    "\u{1F55F}",
    "\u{1F560}",
    "\u{1F561}",
    "\u{1F562}",
    "\u{1F563}",
    "\u{1F564}",
    "\u{1F565}",
    "\u{1F566}",
    "\u{1F567}",
    "\u{1F56F}\uFE0F",
    "\u{1F570}\uFE0F",
    "\u{1F573}\uFE0F",
    "\u{1F574}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F574}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F574}\u{1F3FB}",
    "\u{1F574}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F574}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F574}\u{1F3FC}",
    "\u{1F574}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F574}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F574}\u{1F3FD}",
    "\u{1F574}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F574}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F574}\u{1F3FE}",
    "\u{1F574}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F574}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F574}\u{1F3FF}",
    "\u{1F574}\uFE0F\u200D\u2640\uFE0F",
    "\u{1F574}\uFE0F\u200D\u2642\uFE0F",
    "\u{1F574}\uFE0F",
    "\u{1F575}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F575}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F575}\u{1F3FB}",
    "\u{1F575}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F575}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F575}\u{1F3FC}",
    "\u{1F575}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F575}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F575}\u{1F3FD}",
    "\u{1F575}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F575}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F575}\u{1F3FE}",
    "\u{1F575}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F575}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F575}\u{1F3FF}",
    "\u{1F575}\uFE0F\u200D\u2640\uFE0F",
    "\u{1F575}\uFE0F\u200D\u2642\uFE0F",
    "\u{1F575}\uFE0F",
    "\u{1F576}\uFE0F",
    "\u{1F577}\uFE0F",
    "\u{1F578}\uFE0F",
    "\u{1F579}\uFE0F",
    "\u{1F57A}\u{1F3FB}",
    "\u{1F57A}\u{1F3FC}",
    "\u{1F57A}\u{1F3FD}",
    "\u{1F57A}\u{1F3FE}",
    "\u{1F57A}\u{1F3FF}",
    "\u{1F57A}",
    "\u{1F587}\uFE0F",
    "\u{1F58A}\uFE0F",
    "\u{1F58B}\uFE0F",
    "\u{1F58C}\uFE0F",
    "\u{1F58D}\uFE0F",
    "\u{1F590}\u{1F3FB}",
    "\u{1F590}\u{1F3FC}",
    "\u{1F590}\u{1F3FD}",
    "\u{1F590}\u{1F3FE}",
    "\u{1F590}\u{1F3FF}",
    "\u{1F590}\uFE0F",
    "\u{1F595}\u{1F3FB}",
    "\u{1F595}\u{1F3FC}",
    "\u{1F595}\u{1F3FD}",
    "\u{1F595}\u{1F3FE}",
    "\u{1F595}\u{1F3FF}",
    "\u{1F595}",
    "\u{1F596}\u{1F3FB}",
    "\u{1F596}\u{1F3FC}",
    "\u{1F596}\u{1F3FD}",
    "\u{1F596}\u{1F3FE}",
    "\u{1F596}\u{1F3FF}",
    "\u{1F596}",
    "\u{1F5A4}",
    "\u{1F5A5}\uFE0F",
    "\u{1F5A8}\uFE0F",
    "\u{1F5B1}\uFE0F",
    "\u{1F5B2}\uFE0F",
    "\u{1F5BC}\uFE0F",
    "\u{1F5C2}\uFE0F",
    "\u{1F5C3}\uFE0F",
    "\u{1F5C4}\uFE0F",
    "\u{1F5D1}\uFE0F",
    "\u{1F5D2}\uFE0F",
    "\u{1F5D3}\uFE0F",
    "\u{1F5DC}\uFE0F",
    "\u{1F5DD}\uFE0F",
    "\u{1F5DE}\uFE0F",
    "\u{1F5E1}\uFE0F",
    "\u{1F5E3}\uFE0F",
    "\u{1F5E8}\uFE0F",
    "\u{1F5EF}\uFE0F",
    "\u{1F5F3}\uFE0F",
    "\u{1F5FA}\uFE0F",
    "\u{1F5FB}",
    "\u{1F5FC}",
    "\u{1F5FD}",
    "\u{1F5FE}",
    "\u{1F5FF}",
    "\u{1F600}",
    "\u{1F601}",
    "\u{1F602}",
    "\u{1F603}",
    "\u{1F604}",
    "\u{1F605}",
    "\u{1F606}",
    "\u{1F607}",
    "\u{1F608}",
    "\u{1F609}",
    "\u{1F60A}",
    "\u{1F60B}",
    "\u{1F60C}",
    "\u{1F60D}",
    "\u{1F60E}",
    "\u{1F60F}",
    "\u{1F610}",
    "\u{1F611}",
    "\u{1F612}",
    "\u{1F613}",
    "\u{1F614}",
    "\u{1F615}",
    "\u{1F616}",
    "\u{1F617}",
    "\u{1F618}",
    "\u{1F619}",
    "\u{1F61A}",
    "\u{1F61B}",
    "\u{1F61C}",
    "\u{1F61D}",
    "\u{1F61E}",
    "\u{1F61F}",
    "\u{1F620}",
    "\u{1F621}",
    "\u{1F622}",
    "\u{1F623}",
    "\u{1F624}",
    "\u{1F625}",
    "\u{1F626}",
    "\u{1F627}",
    "\u{1F628}",
    "\u{1F629}",
    "\u{1F62A}",
    "\u{1F62B}",
    "\u{1F62C}",
    "\u{1F62D}",
    "\u{1F62E}",
    "\u{1F62F}",
    "\u{1F630}",
    "\u{1F631}",
    "\u{1F632}",
    "\u{1F633}",
    "\u{1F634}",
    "\u{1F635}",
    "\u{1F636}",
    "\u{1F637}",
    "\u{1F638}",
    "\u{1F639}",
    "\u{1F63A}",
    "\u{1F63B}",
    "\u{1F63C}",
    "\u{1F63D}",
    "\u{1F63E}",
    "\u{1F63F}",
    "\u{1F640}",
    "\u{1F641}",
    "\u{1F642}",
    "\u{1F643}",
    "\u{1F644}",
    "\u{1F645}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F645}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F645}\u{1F3FB}",
    "\u{1F645}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F645}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F645}\u{1F3FC}",
    "\u{1F645}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F645}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F645}\u{1F3FD}",
    "\u{1F645}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F645}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F645}\u{1F3FE}",
    "\u{1F645}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F645}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F645}\u{1F3FF}",
    "\u{1F645}\u200D\u2640\uFE0F",
    "\u{1F645}\u200D\u2642\uFE0F",
    "\u{1F645}",
    "\u{1F646}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F646}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F646}\u{1F3FB}",
    "\u{1F646}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F646}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F646}\u{1F3FC}",
    "\u{1F646}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F646}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F646}\u{1F3FD}",
    "\u{1F646}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F646}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F646}\u{1F3FE}",
    "\u{1F646}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F646}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F646}\u{1F3FF}",
    "\u{1F646}\u200D\u2640\uFE0F",
    "\u{1F646}\u200D\u2642\uFE0F",
    "\u{1F646}",
    "\u{1F647}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F647}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F647}\u{1F3FB}",
    "\u{1F647}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F647}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F647}\u{1F3FC}",
    "\u{1F647}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F647}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F647}\u{1F3FD}",
    "\u{1F647}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F647}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F647}\u{1F3FE}",
    "\u{1F647}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F647}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F647}\u{1F3FF}",
    "\u{1F647}\u200D\u2640\uFE0F",
    "\u{1F647}\u200D\u2642\uFE0F",
    "\u{1F647}",
    "\u{1F648}",
    "\u{1F649}",
    "\u{1F64A}",
    "\u{1F64B}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F64B}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F64B}\u{1F3FB}",
    "\u{1F64B}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F64B}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F64B}\u{1F3FC}",
    "\u{1F64B}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F64B}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F64B}\u{1F3FD}",
    "\u{1F64B}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F64B}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F64B}\u{1F3FE}",
    "\u{1F64B}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F64B}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F64B}\u{1F3FF}",
    "\u{1F64B}\u200D\u2640\uFE0F",
    "\u{1F64B}\u200D\u2642\uFE0F",
    "\u{1F64B}",
    "\u{1F64C}\u{1F3FB}",
    "\u{1F64C}\u{1F3FC}",
    "\u{1F64C}\u{1F3FD}",
    "\u{1F64C}\u{1F3FE}",
    "\u{1F64C}\u{1F3FF}",
    "\u{1F64C}",
    "\u{1F64D}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F64D}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F64D}\u{1F3FB}",
    "\u{1F64D}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F64D}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F64D}\u{1F3FC}",
    "\u{1F64D}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F64D}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F64D}\u{1F3FD}",
    "\u{1F64D}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F64D}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F64D}\u{1F3FE}",
    "\u{1F64D}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F64D}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F64D}\u{1F3FF}",
    "\u{1F64D}\u200D\u2640\uFE0F",
    "\u{1F64D}\u200D\u2642\uFE0F",
    "\u{1F64D}",
    "\u{1F64E}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F64E}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F64E}\u{1F3FB}",
    "\u{1F64E}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F64E}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F64E}\u{1F3FC}",
    "\u{1F64E}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F64E}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F64E}\u{1F3FD}",
    "\u{1F64E}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F64E}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F64E}\u{1F3FE}",
    "\u{1F64E}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F64E}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F64E}\u{1F3FF}",
    "\u{1F64E}\u200D\u2640\uFE0F",
    "\u{1F64E}\u200D\u2642\uFE0F",
    "\u{1F64E}",
    "\u{1F64F}\u{1F3FB}",
    "\u{1F64F}\u{1F3FC}",
    "\u{1F64F}\u{1F3FD}",
    "\u{1F64F}\u{1F3FE}",
    "\u{1F64F}\u{1F3FF}",
    "\u{1F64F}",
    "\u{1F680}",
    "\u{1F681}",
    "\u{1F682}",
    "\u{1F683}",
    "\u{1F684}",
    "\u{1F685}",
    "\u{1F686}",
    "\u{1F687}",
    "\u{1F688}",
    "\u{1F689}",
    "\u{1F68A}",
    "\u{1F68B}",
    "\u{1F68C}",
    "\u{1F68D}",
    "\u{1F68E}",
    "\u{1F68F}",
    "\u{1F690}",
    "\u{1F691}",
    "\u{1F692}",
    "\u{1F693}",
    "\u{1F694}",
    "\u{1F695}",
    "\u{1F696}",
    "\u{1F697}",
    "\u{1F698}",
    "\u{1F699}",
    "\u{1F69A}",
    "\u{1F69B}",
    "\u{1F69C}",
    "\u{1F69D}",
    "\u{1F69E}",
    "\u{1F69F}",
    "\u{1F6A0}",
    "\u{1F6A1}",
    "\u{1F6A2}",
    "\u{1F6A3}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F6A3}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F6A3}\u{1F3FB}",
    "\u{1F6A3}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F6A3}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F6A3}\u{1F3FC}",
    "\u{1F6A3}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F6A3}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F6A3}\u{1F3FD}",
    "\u{1F6A3}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F6A3}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F6A3}\u{1F3FE}",
    "\u{1F6A3}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F6A3}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F6A3}\u{1F3FF}",
    "\u{1F6A3}\u200D\u2640\uFE0F",
    "\u{1F6A3}\u200D\u2642\uFE0F",
    "\u{1F6A3}",
    "\u{1F6A4}",
    "\u{1F6A5}",
    "\u{1F6A6}",
    "\u{1F6A7}",
    "\u{1F6A8}",
    "\u{1F6A9}",
    "\u{1F6AA}",
    "\u{1F6AB}",
    "\u{1F6AC}",
    "\u{1F6AD}",
    "\u{1F6AE}",
    "\u{1F6AF}",
    "\u{1F6B0}",
    "\u{1F6B1}",
    "\u{1F6B2}",
    "\u{1F6B3}",
    "\u{1F6B4}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F6B4}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F6B4}\u{1F3FB}",
    "\u{1F6B4}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F6B4}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F6B4}\u{1F3FC}",
    "\u{1F6B4}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F6B4}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F6B4}\u{1F3FD}",
    "\u{1F6B4}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F6B4}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F6B4}\u{1F3FE}",
    "\u{1F6B4}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F6B4}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F6B4}\u{1F3FF}",
    "\u{1F6B4}\u200D\u2640\uFE0F",
    "\u{1F6B4}\u200D\u2642\uFE0F",
    "\u{1F6B4}",
    "\u{1F6B5}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F6B5}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F6B5}\u{1F3FB}",
    "\u{1F6B5}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F6B5}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F6B5}\u{1F3FC}",
    "\u{1F6B5}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F6B5}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F6B5}\u{1F3FD}",
    "\u{1F6B5}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F6B5}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F6B5}\u{1F3FE}",
    "\u{1F6B5}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F6B5}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F6B5}\u{1F3FF}",
    "\u{1F6B5}\u200D\u2640\uFE0F",
    "\u{1F6B5}\u200D\u2642\uFE0F",
    "\u{1F6B5}",
    "\u{1F6B6}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F6B6}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F6B6}\u{1F3FB}",
    "\u{1F6B6}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F6B6}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F6B6}\u{1F3FC}",
    "\u{1F6B6}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F6B6}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F6B6}\u{1F3FD}",
    "\u{1F6B6}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F6B6}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F6B6}\u{1F3FE}",
    "\u{1F6B6}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F6B6}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F6B6}\u{1F3FF}",
    "\u{1F6B6}\u200D\u2640\uFE0F",
    "\u{1F6B6}\u200D\u2642\uFE0F",
    "\u{1F6B6}",
    "\u{1F6B7}",
    "\u{1F6B8}",
    "\u{1F6B9}",
    "\u{1F6BA}",
    "\u{1F6BB}",
    "\u{1F6BC}",
    "\u{1F6BD}",
    "\u{1F6BE}",
    "\u{1F6BF}",
    "\u{1F6C0}\u{1F3FB}",
    "\u{1F6C0}\u{1F3FC}",
    "\u{1F6C0}\u{1F3FD}",
    "\u{1F6C0}\u{1F3FE}",
    "\u{1F6C0}\u{1F3FF}",
    "\u{1F6C0}",
    "\u{1F6C1}",
    "\u{1F6C2}",
    "\u{1F6C3}",
    "\u{1F6C4}",
    "\u{1F6C5}",
    "\u{1F6CB}\uFE0F",
    "\u{1F6CC}\u{1F3FB}",
    "\u{1F6CC}\u{1F3FC}",
    "\u{1F6CC}\u{1F3FD}",
    "\u{1F6CC}\u{1F3FE}",
    "\u{1F6CC}\u{1F3FF}",
    "\u{1F6CC}",
    "\u{1F6CD}\uFE0F",
    "\u{1F6CE}\uFE0F",
    "\u{1F6CF}\uFE0F",
    "\u{1F6D0}",
    "\u{1F6D1}",
    "\u{1F6D2}",
    "\u{1F6D5}",
    "\u{1F6E0}\uFE0F",
    "\u{1F6E1}\uFE0F",
    "\u{1F6E2}\uFE0F",
    "\u{1F6E3}\uFE0F",
    "\u{1F6E4}\uFE0F",
    "\u{1F6E5}\uFE0F",
    "\u{1F6E9}\uFE0F",
    "\u{1F6EB}",
    "\u{1F6EC}",
    "\u{1F6F0}\uFE0F",
    "\u{1F6F3}\uFE0F",
    "\u{1F6F4}",
    "\u{1F6F5}",
    "\u{1F6F6}",
    "\u{1F6F7}",
    "\u{1F6F8}",
    "\u{1F6F9}",
    "\u{1F6FA}",
    "\u{1F7E0}",
    "\u{1F7E1}",
    "\u{1F7E2}",
    "\u{1F7E3}",
    "\u{1F7E4}",
    "\u{1F7E5}",
    "\u{1F7E6}",
    "\u{1F7E7}",
    "\u{1F7E8}",
    "\u{1F7E9}",
    "\u{1F7EA}",
    "\u{1F7EB}",
    "\u{1F90D}",
    "\u{1F90E}",
    "\u{1F90F}\u{1F3FB}",
    "\u{1F90F}\u{1F3FC}",
    "\u{1F90F}\u{1F3FD}",
    "\u{1F90F}\u{1F3FE}",
    "\u{1F90F}\u{1F3FF}",
    "\u{1F90F}",
    "\u{1F910}",
    "\u{1F911}",
    "\u{1F912}",
    "\u{1F913}",
    "\u{1F914}",
    "\u{1F915}",
    "\u{1F916}",
    "\u{1F917}",
    "\u{1F918}\u{1F3FB}",
    "\u{1F918}\u{1F3FC}",
    "\u{1F918}\u{1F3FD}",
    "\u{1F918}\u{1F3FE}",
    "\u{1F918}\u{1F3FF}",
    "\u{1F918}",
    "\u{1F919}\u{1F3FB}",
    "\u{1F919}\u{1F3FC}",
    "\u{1F919}\u{1F3FD}",
    "\u{1F919}\u{1F3FE}",
    "\u{1F919}\u{1F3FF}",
    "\u{1F919}",
    "\u{1F91A}\u{1F3FB}",
    "\u{1F91A}\u{1F3FC}",
    "\u{1F91A}\u{1F3FD}",
    "\u{1F91A}\u{1F3FE}",
    "\u{1F91A}\u{1F3FF}",
    "\u{1F91A}",
    "\u{1F91B}\u{1F3FB}",
    "\u{1F91B}\u{1F3FC}",
    "\u{1F91B}\u{1F3FD}",
    "\u{1F91B}\u{1F3FE}",
    "\u{1F91B}\u{1F3FF}",
    "\u{1F91B}",
    "\u{1F91C}\u{1F3FB}",
    "\u{1F91C}\u{1F3FC}",
    "\u{1F91C}\u{1F3FD}",
    "\u{1F91C}\u{1F3FE}",
    "\u{1F91C}\u{1F3FF}",
    "\u{1F91C}",
    "\u{1F91D}",
    "\u{1F91E}\u{1F3FB}",
    "\u{1F91E}\u{1F3FC}",
    "\u{1F91E}\u{1F3FD}",
    "\u{1F91E}\u{1F3FE}",
    "\u{1F91E}\u{1F3FF}",
    "\u{1F91E}",
    "\u{1F91F}\u{1F3FB}",
    "\u{1F91F}\u{1F3FC}",
    "\u{1F91F}\u{1F3FD}",
    "\u{1F91F}\u{1F3FE}",
    "\u{1F91F}\u{1F3FF}",
    "\u{1F91F}",
    "\u{1F920}",
    "\u{1F921}",
    "\u{1F922}",
    "\u{1F923}",
    "\u{1F924}",
    "\u{1F925}",
    "\u{1F926}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F926}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F926}\u{1F3FB}",
    "\u{1F926}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F926}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F926}\u{1F3FC}",
    "\u{1F926}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F926}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F926}\u{1F3FD}",
    "\u{1F926}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F926}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F926}\u{1F3FE}",
    "\u{1F926}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F926}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F926}\u{1F3FF}",
    "\u{1F926}\u200D\u2640\uFE0F",
    "\u{1F926}\u200D\u2642\uFE0F",
    "\u{1F926}",
    "\u{1F927}",
    "\u{1F928}",
    "\u{1F929}",
    "\u{1F92A}",
    "\u{1F92B}",
    "\u{1F92C}",
    "\u{1F92D}",
    "\u{1F92E}",
    "\u{1F92F}",
    "\u{1F930}\u{1F3FB}",
    "\u{1F930}\u{1F3FC}",
    "\u{1F930}\u{1F3FD}",
    "\u{1F930}\u{1F3FE}",
    "\u{1F930}\u{1F3FF}",
    "\u{1F930}",
    "\u{1F931}\u{1F3FB}",
    "\u{1F931}\u{1F3FC}",
    "\u{1F931}\u{1F3FD}",
    "\u{1F931}\u{1F3FE}",
    "\u{1F931}\u{1F3FF}",
    "\u{1F931}",
    "\u{1F932}\u{1F3FB}",
    "\u{1F932}\u{1F3FC}",
    "\u{1F932}\u{1F3FD}",
    "\u{1F932}\u{1F3FE}",
    "\u{1F932}\u{1F3FF}",
    "\u{1F932}",
    "\u{1F933}\u{1F3FB}",
    "\u{1F933}\u{1F3FC}",
    "\u{1F933}\u{1F3FD}",
    "\u{1F933}\u{1F3FE}",
    "\u{1F933}\u{1F3FF}",
    "\u{1F933}",
    "\u{1F934}\u{1F3FB}",
    "\u{1F934}\u{1F3FC}",
    "\u{1F934}\u{1F3FD}",
    "\u{1F934}\u{1F3FE}",
    "\u{1F934}\u{1F3FF}",
    "\u{1F934}",
    "\u{1F935}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F935}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F935}\u{1F3FB}",
    "\u{1F935}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F935}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F935}\u{1F3FC}",
    "\u{1F935}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F935}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F935}\u{1F3FD}",
    "\u{1F935}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F935}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F935}\u{1F3FE}",
    "\u{1F935}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F935}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F935}\u{1F3FF}",
    "\u{1F935}\u200D\u2640\uFE0F",
    "\u{1F935}\u200D\u2642\uFE0F",
    "\u{1F935}",
    "\u{1F936}\u{1F3FB}",
    "\u{1F936}\u{1F3FC}",
    "\u{1F936}\u{1F3FD}",
    "\u{1F936}\u{1F3FE}",
    "\u{1F936}\u{1F3FF}",
    "\u{1F936}",
    "\u{1F937}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F937}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F937}\u{1F3FB}",
    "\u{1F937}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F937}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F937}\u{1F3FC}",
    "\u{1F937}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F937}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F937}\u{1F3FD}",
    "\u{1F937}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F937}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F937}\u{1F3FE}",
    "\u{1F937}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F937}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F937}\u{1F3FF}",
    "\u{1F937}\u200D\u2640\uFE0F",
    "\u{1F937}\u200D\u2642\uFE0F",
    "\u{1F937}",
    "\u{1F938}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F938}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F938}\u{1F3FB}",
    "\u{1F938}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F938}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F938}\u{1F3FC}",
    "\u{1F938}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F938}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F938}\u{1F3FD}",
    "\u{1F938}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F938}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F938}\u{1F3FE}",
    "\u{1F938}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F938}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F938}\u{1F3FF}",
    "\u{1F938}\u200D\u2640\uFE0F",
    "\u{1F938}\u200D\u2642\uFE0F",
    "\u{1F938}",
    "\u{1F939}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F939}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F939}\u{1F3FB}",
    "\u{1F939}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F939}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F939}\u{1F3FC}",
    "\u{1F939}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F939}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F939}\u{1F3FD}",
    "\u{1F939}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F939}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F939}\u{1F3FE}",
    "\u{1F939}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F939}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F939}\u{1F3FF}",
    "\u{1F939}\u200D\u2640\uFE0F",
    "\u{1F939}\u200D\u2642\uFE0F",
    "\u{1F939}",
    "\u{1F93A}",
    "\u{1F93C}\u200D\u2640\uFE0F",
    "\u{1F93C}\u200D\u2642\uFE0F",
    "\u{1F93C}",
    "\u{1F93D}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F93D}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F93D}\u{1F3FB}",
    "\u{1F93D}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F93D}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F93D}\u{1F3FC}",
    "\u{1F93D}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F93D}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F93D}\u{1F3FD}",
    "\u{1F93D}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F93D}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F93D}\u{1F3FE}",
    "\u{1F93D}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F93D}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F93D}\u{1F3FF}",
    "\u{1F93D}\u200D\u2640\uFE0F",
    "\u{1F93D}\u200D\u2642\uFE0F",
    "\u{1F93D}",
    "\u{1F93E}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F93E}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F93E}\u{1F3FB}",
    "\u{1F93E}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F93E}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F93E}\u{1F3FC}",
    "\u{1F93E}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F93E}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F93E}\u{1F3FD}",
    "\u{1F93E}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F93E}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F93E}\u{1F3FE}",
    "\u{1F93E}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F93E}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F93E}\u{1F3FF}",
    "\u{1F93E}\u200D\u2640\uFE0F",
    "\u{1F93E}\u200D\u2642\uFE0F",
    "\u{1F93E}",
    "\u{1F93F}",
    "\u{1F940}",
    "\u{1F941}",
    "\u{1F942}",
    "\u{1F943}",
    "\u{1F944}",
    "\u{1F945}",
    "\u{1F947}",
    "\u{1F948}",
    "\u{1F949}",
    "\u{1F94A}",
    "\u{1F94B}",
    "\u{1F94C}",
    "\u{1F94D}",
    "\u{1F94E}",
    "\u{1F94F}",
    "\u{1F950}",
    "\u{1F951}",
    "\u{1F952}",
    "\u{1F953}",
    "\u{1F954}",
    "\u{1F955}",
    "\u{1F956}",
    "\u{1F957}",
    "\u{1F958}",
    "\u{1F959}",
    "\u{1F95A}",
    "\u{1F95B}",
    "\u{1F95C}",
    "\u{1F95D}",
    "\u{1F95E}",
    "\u{1F95F}",
    "\u{1F960}",
    "\u{1F961}",
    "\u{1F962}",
    "\u{1F963}",
    "\u{1F964}",
    "\u{1F965}",
    "\u{1F966}",
    "\u{1F967}",
    "\u{1F968}",
    "\u{1F969}",
    "\u{1F96A}",
    "\u{1F96B}",
    "\u{1F96C}",
    "\u{1F96D}",
    "\u{1F96E}",
    "\u{1F96F}",
    "\u{1F970}",
    "\u{1F971}",
    "\u{1F973}",
    "\u{1F974}",
    "\u{1F975}",
    "\u{1F976}",
    "\u{1F97A}",
    "\u{1F97B}",
    "\u{1F97C}",
    "\u{1F97D}",
    "\u{1F97E}",
    "\u{1F97F}",
    "\u{1F980}",
    "\u{1F981}",
    "\u{1F982}",
    "\u{1F983}",
    "\u{1F984}",
    "\u{1F985}",
    "\u{1F986}",
    "\u{1F987}",
    "\u{1F988}",
    "\u{1F989}",
    "\u{1F98A}",
    "\u{1F98B}",
    "\u{1F98C}",
    "\u{1F98D}",
    "\u{1F98E}",
    "\u{1F98F}",
    "\u{1F990}",
    "\u{1F991}",
    "\u{1F992}",
    "\u{1F993}",
    "\u{1F994}",
    "\u{1F995}",
    "\u{1F996}",
    "\u{1F997}",
    "\u{1F998}",
    "\u{1F999}",
    "\u{1F99A}",
    "\u{1F99B}",
    "\u{1F99C}",
    "\u{1F99D}",
    "\u{1F99E}",
    "\u{1F99F}",
    "\u{1F9A0}",
    "\u{1F9A1}",
    "\u{1F9A2}",
    "\u{1F9A5}",
    "\u{1F9A6}",
    "\u{1F9A7}",
    "\u{1F9A8}",
    "\u{1F9A9}",
    "\u{1F9AA}",
    "\u{1F9AE}",
    "\u{1F9AF}",
    "\u{1F9B0}",
    "\u{1F9B1}",
    "\u{1F9B2}",
    "\u{1F9B3}",
    "\u{1F9B4}",
    "\u{1F9B5}\u{1F3FB}",
    "\u{1F9B5}\u{1F3FC}",
    "\u{1F9B5}\u{1F3FD}",
    "\u{1F9B5}\u{1F3FE}",
    "\u{1F9B5}\u{1F3FF}",
    "\u{1F9B5}",
    "\u{1F9B6}\u{1F3FB}",
    "\u{1F9B6}\u{1F3FC}",
    "\u{1F9B6}\u{1F3FD}",
    "\u{1F9B6}\u{1F3FE}",
    "\u{1F9B6}\u{1F3FF}",
    "\u{1F9B6}",
    "\u{1F9B7}",
    "\u{1F9B8}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9B8}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9B8}\u{1F3FB}",
    "\u{1F9B8}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9B8}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9B8}\u{1F3FC}",
    "\u{1F9B8}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9B8}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9B8}\u{1F3FD}",
    "\u{1F9B8}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9B8}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9B8}\u{1F3FE}",
    "\u{1F9B8}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9B8}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9B8}\u{1F3FF}",
    "\u{1F9B8}\u200D\u2640\uFE0F",
    "\u{1F9B8}\u200D\u2642\uFE0F",
    "\u{1F9B8}",
    "\u{1F9B9}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9B9}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9B9}\u{1F3FB}",
    "\u{1F9B9}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9B9}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9B9}\u{1F3FC}",
    "\u{1F9B9}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9B9}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9B9}\u{1F3FD}",
    "\u{1F9B9}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9B9}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9B9}\u{1F3FE}",
    "\u{1F9B9}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9B9}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9B9}\u{1F3FF}",
    "\u{1F9B9}\u200D\u2640\uFE0F",
    "\u{1F9B9}\u200D\u2642\uFE0F",
    "\u{1F9B9}",
    "\u{1F9BA}",
    "\u{1F9BB}\u{1F3FB}",
    "\u{1F9BB}\u{1F3FC}",
    "\u{1F9BB}\u{1F3FD}",
    "\u{1F9BB}\u{1F3FE}",
    "\u{1F9BB}\u{1F3FF}",
    "\u{1F9BB}",
    "\u{1F9BC}",
    "\u{1F9BD}",
    "\u{1F9BE}",
    "\u{1F9BF}",
    "\u{1F9C0}",
    "\u{1F9C1}",
    "\u{1F9C2}",
    "\u{1F9C3}",
    "\u{1F9C4}",
    "\u{1F9C5}",
    "\u{1F9C6}",
    "\u{1F9C7}",
    "\u{1F9C8}",
    "\u{1F9C9}",
    "\u{1F9CA}",
    "\u{1F9CD}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9CD}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9CD}\u{1F3FB}",
    "\u{1F9CD}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9CD}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9CD}\u{1F3FC}",
    "\u{1F9CD}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9CD}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9CD}\u{1F3FD}",
    "\u{1F9CD}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9CD}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9CD}\u{1F3FE}",
    "\u{1F9CD}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9CD}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9CD}\u{1F3FF}",
    "\u{1F9CD}\u200D\u2640\uFE0F",
    "\u{1F9CD}\u200D\u2642\uFE0F",
    "\u{1F9CD}",
    "\u{1F9CE}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9CE}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9CE}\u{1F3FB}",
    "\u{1F9CE}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9CE}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9CE}\u{1F3FC}",
    "\u{1F9CE}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9CE}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9CE}\u{1F3FD}",
    "\u{1F9CE}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9CE}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9CE}\u{1F3FE}",
    "\u{1F9CE}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9CE}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9CE}\u{1F3FF}",
    "\u{1F9CE}\u200D\u2640\uFE0F",
    "\u{1F9CE}\u200D\u2642\uFE0F",
    "\u{1F9CE}",
    "\u{1F9CF}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9CF}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9CF}\u{1F3FB}",
    "\u{1F9CF}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9CF}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9CF}\u{1F3FC}",
    "\u{1F9CF}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9CF}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9CF}\u{1F3FD}",
    "\u{1F9CF}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9CF}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9CF}\u{1F3FE}",
    "\u{1F9CF}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9CF}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9CF}\u{1F3FF}",
    "\u{1F9CF}\u200D\u2640\uFE0F",
    "\u{1F9CF}\u200D\u2642\uFE0F",
    "\u{1F9CF}",
    "\u{1F9D0}",
    "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
    "\u{1F9D1}\u{1F3FB}",
    "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
    "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
    "\u{1F9D1}\u{1F3FC}",
    "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
    "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
    "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}",
    "\u{1F9D1}\u{1F3FD}",
    "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
    "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
    "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}",
    "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}",
    "\u{1F9D1}\u{1F3FE}",
    "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
    "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
    "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}",
    "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}",
    "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}",
    "\u{1F9D1}\u{1F3FF}",
    "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}",
    "\u{1F9D1}",
    "\u{1F9D2}\u{1F3FB}",
    "\u{1F9D2}\u{1F3FC}",
    "\u{1F9D2}\u{1F3FD}",
    "\u{1F9D2}\u{1F3FE}",
    "\u{1F9D2}\u{1F3FF}",
    "\u{1F9D2}",
    "\u{1F9D3}\u{1F3FB}",
    "\u{1F9D3}\u{1F3FC}",
    "\u{1F9D3}\u{1F3FD}",
    "\u{1F9D3}\u{1F3FE}",
    "\u{1F9D3}\u{1F3FF}",
    "\u{1F9D3}",
    "\u{1F9D4}\u{1F3FB}",
    "\u{1F9D4}\u{1F3FC}",
    "\u{1F9D4}\u{1F3FD}",
    "\u{1F9D4}\u{1F3FE}",
    "\u{1F9D4}\u{1F3FF}",
    "\u{1F9D4}",
    "\u{1F9D5}\u{1F3FB}",
    "\u{1F9D5}\u{1F3FC}",
    "\u{1F9D5}\u{1F3FD}",
    "\u{1F9D5}\u{1F3FE}",
    "\u{1F9D5}\u{1F3FF}",
    "\u{1F9D5}",
    "\u{1F9D6}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9D6}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9D6}\u{1F3FB}",
    "\u{1F9D6}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9D6}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9D6}\u{1F3FC}",
    "\u{1F9D6}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9D6}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9D6}\u{1F3FD}",
    "\u{1F9D6}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9D6}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9D6}\u{1F3FE}",
    "\u{1F9D6}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9D6}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9D6}\u{1F3FF}",
    "\u{1F9D6}\u200D\u2640\uFE0F",
    "\u{1F9D6}\u200D\u2642\uFE0F",
    "\u{1F9D6}",
    "\u{1F9D7}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9D7}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9D7}\u{1F3FB}",
    "\u{1F9D7}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9D7}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9D7}\u{1F3FC}",
    "\u{1F9D7}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9D7}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9D7}\u{1F3FD}",
    "\u{1F9D7}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9D7}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9D7}\u{1F3FE}",
    "\u{1F9D7}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9D7}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9D7}\u{1F3FF}",
    "\u{1F9D7}\u200D\u2640\uFE0F",
    "\u{1F9D7}\u200D\u2642\uFE0F",
    "\u{1F9D7}",
    "\u{1F9D8}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9D8}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9D8}\u{1F3FB}",
    "\u{1F9D8}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9D8}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9D8}\u{1F3FC}",
    "\u{1F9D8}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9D8}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9D8}\u{1F3FD}",
    "\u{1F9D8}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9D8}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9D8}\u{1F3FE}",
    "\u{1F9D8}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9D8}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9D8}\u{1F3FF}",
    "\u{1F9D8}\u200D\u2640\uFE0F",
    "\u{1F9D8}\u200D\u2642\uFE0F",
    "\u{1F9D8}",
    "\u{1F9D9}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9D9}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9D9}\u{1F3FB}",
    "\u{1F9D9}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9D9}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9D9}\u{1F3FC}",
    "\u{1F9D9}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9D9}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9D9}\u{1F3FD}",
    "\u{1F9D9}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9D9}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9D9}\u{1F3FE}",
    "\u{1F9D9}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9D9}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9D9}\u{1F3FF}",
    "\u{1F9D9}\u200D\u2640\uFE0F",
    "\u{1F9D9}\u200D\u2642\uFE0F",
    "\u{1F9D9}",
    "\u{1F9DA}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9DA}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9DA}\u{1F3FB}",
    "\u{1F9DA}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9DA}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9DA}\u{1F3FC}",
    "\u{1F9DA}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9DA}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9DA}\u{1F3FD}",
    "\u{1F9DA}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9DA}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9DA}\u{1F3FE}",
    "\u{1F9DA}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9DA}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9DA}\u{1F3FF}",
    "\u{1F9DA}\u200D\u2640\uFE0F",
    "\u{1F9DA}\u200D\u2642\uFE0F",
    "\u{1F9DA}",
    "\u{1F9DB}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9DB}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9DB}\u{1F3FB}",
    "\u{1F9DB}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9DB}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9DB}\u{1F3FC}",
    "\u{1F9DB}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9DB}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9DB}\u{1F3FD}",
    "\u{1F9DB}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9DB}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9DB}\u{1F3FE}",
    "\u{1F9DB}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9DB}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9DB}\u{1F3FF}",
    "\u{1F9DB}\u200D\u2640\uFE0F",
    "\u{1F9DB}\u200D\u2642\uFE0F",
    "\u{1F9DB}",
    "\u{1F9DC}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9DC}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9DC}\u{1F3FB}",
    "\u{1F9DC}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9DC}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9DC}\u{1F3FC}",
    "\u{1F9DC}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9DC}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9DC}\u{1F3FD}",
    "\u{1F9DC}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9DC}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9DC}\u{1F3FE}",
    "\u{1F9DC}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9DC}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9DC}\u{1F3FF}",
    "\u{1F9DC}\u200D\u2640\uFE0F",
    "\u{1F9DC}\u200D\u2642\uFE0F",
    "\u{1F9DC}",
    "\u{1F9DD}\u{1F3FB}\u200D\u2640\uFE0F",
    "\u{1F9DD}\u{1F3FB}\u200D\u2642\uFE0F",
    "\u{1F9DD}\u{1F3FB}",
    "\u{1F9DD}\u{1F3FC}\u200D\u2640\uFE0F",
    "\u{1F9DD}\u{1F3FC}\u200D\u2642\uFE0F",
    "\u{1F9DD}\u{1F3FC}",
    "\u{1F9DD}\u{1F3FD}\u200D\u2640\uFE0F",
    "\u{1F9DD}\u{1F3FD}\u200D\u2642\uFE0F",
    "\u{1F9DD}\u{1F3FD}",
    "\u{1F9DD}\u{1F3FE}\u200D\u2640\uFE0F",
    "\u{1F9DD}\u{1F3FE}\u200D\u2642\uFE0F",
    "\u{1F9DD}\u{1F3FE}",
    "\u{1F9DD}\u{1F3FF}\u200D\u2640\uFE0F",
    "\u{1F9DD}\u{1F3FF}\u200D\u2642\uFE0F",
    "\u{1F9DD}\u{1F3FF}",
    "\u{1F9DD}\u200D\u2640\uFE0F",
    "\u{1F9DD}\u200D\u2642\uFE0F",
    "\u{1F9DD}",
    "\u{1F9DE}\u200D\u2640\uFE0F",
    "\u{1F9DE}\u200D\u2642\uFE0F",
    "\u{1F9DE}",
    "\u{1F9DF}\u200D\u2640\uFE0F",
    "\u{1F9DF}\u200D\u2642\uFE0F",
    "\u{1F9DF}",
    "\u{1F9E0}",
    "\u{1F9E1}",
    "\u{1F9E2}",
    "\u{1F9E3}",
    "\u{1F9E4}",
    "\u{1F9E5}",
    "\u{1F9E6}",
    "\u{1F9E7}",
    "\u{1F9E8}",
    "\u{1F9E9}",
    "\u{1F9EA}",
    "\u{1F9EB}",
    "\u{1F9EC}",
    "\u{1F9ED}",
    "\u{1F9EE}",
    "\u{1F9EF}",
    "\u{1F9F0}",
    "\u{1F9F1}",
    "\u{1F9F2}",
    "\u{1F9F3}",
    "\u{1F9F4}",
    "\u{1F9F5}",
    "\u{1F9F6}",
    "\u{1F9F7}",
    "\u{1F9F8}",
    "\u{1F9F9}",
    "\u{1F9FA}",
    "\u{1F9FB}",
    "\u{1F9FC}",
    "\u{1F9FD}",
    "\u{1F9FE}",
    "\u{1F9FF}",
    "\u{1FA70}",
    "\u{1FA71}",
    "\u{1FA72}",
    "\u{1FA73}",
    "\u{1FA78}",
    "\u{1FA79}",
    "\u{1FA7A}",
    "\u{1FA80}",
    "\u{1FA81}",
    "\u{1FA82}",
    "\u{1FA90}",
    "\u{1FA91}",
    "\u{1FA92}",
    "\u{1FA93}",
    "\u{1FA94}",
    "\u{1FA95}",
    "\u203C\uFE0F",
    "\u2049\uFE0F",
    "\u2122\uFE0F",
    "\u2139\uFE0F",
    "\u2194\uFE0F",
    "\u2195\uFE0F",
    "\u2196\uFE0F",
    "\u2197\uFE0F",
    "\u2198\uFE0F",
    "\u2199\uFE0F",
    "\u21A9\uFE0F",
    "\u21AA\uFE0F",
    "#\u20E3",
    "\u231A\uFE0F",
    "\u231B\uFE0F",
    "\u2328\uFE0F",
    "\u23CF\uFE0F",
    "\u23E9",
    "\u23EA",
    "\u23EB",
    "\u23EC",
    "\u23ED\uFE0F",
    "\u23EE\uFE0F",
    "\u23EF\uFE0F",
    "\u23F0",
    "\u23F1\uFE0F",
    "\u23F2\uFE0F",
    "\u23F3",
    "\u23F8\uFE0F",
    "\u23F9\uFE0F",
    "\u23FA\uFE0F",
    "\u24C2\uFE0F",
    "\u25AA\uFE0F",
    "\u25AB\uFE0F",
    "\u25B6\uFE0F",
    "\u25C0\uFE0F",
    "\u25FB\uFE0F",
    "\u25FC\uFE0F",
    "\u25FD\uFE0F",
    "\u25FE\uFE0F",
    "\u2600\uFE0F",
    "\u2601\uFE0F",
    "\u2602\uFE0F",
    "\u2603\uFE0F",
    "\u2604\uFE0F",
    "\u260E\uFE0F",
    "\u2611\uFE0F",
    "\u2614\uFE0F",
    "\u2615\uFE0F",
    "\u2618\uFE0F",
    "\u261D\u{1F3FB}",
    "\u261D\u{1F3FC}",
    "\u261D\u{1F3FD}",
    "\u261D\u{1F3FE}",
    "\u261D\u{1F3FF}",
    "\u261D\uFE0F",
    "\u2620\uFE0F",
    "\u2622\uFE0F",
    "\u2623\uFE0F",
    "\u2626\uFE0F",
    "\u262A\uFE0F",
    "\u262E\uFE0F",
    "\u262F\uFE0F",
    "\u2638\uFE0F",
    "\u2639\uFE0F",
    "\u263A\uFE0F",
    "\u2640\uFE0F",
    "\u2642\uFE0F",
    "\u2648\uFE0F",
    "\u2649\uFE0F",
    "\u264A\uFE0F",
    "\u264B\uFE0F",
    "\u264C\uFE0F",
    "\u264D\uFE0F",
    "\u264E\uFE0F",
    "\u264F\uFE0F",
    "\u2650\uFE0F",
    "\u2651\uFE0F",
    "\u2652\uFE0F",
    "\u2653\uFE0F",
    "\u265F\uFE0F",
    "\u2660\uFE0F",
    "\u2663\uFE0F",
    "\u2665\uFE0F",
    "\u2666\uFE0F",
    "\u2668\uFE0F",
    "\u267B\uFE0F",
    "\u267E",
    "\u267F\uFE0F",
    "\u2692\uFE0F",
    "\u2693\uFE0F",
    "\u2694\uFE0F",
    "\u2695\uFE0F",
    "\u2696\uFE0F",
    "\u2697\uFE0F",
    "\u2699\uFE0F",
    "\u269B\uFE0F",
    "\u269C\uFE0F",
    "\u26A0\uFE0F",
    "\u26A1\uFE0F",
    "\u26AA\uFE0F",
    "\u26AB\uFE0F",
    "\u26B0\uFE0F",
    "\u26B1\uFE0F",
    "\u26BD\uFE0F",
    "\u26BE\uFE0F",
    "\u26C4\uFE0F",
    "\u26C5\uFE0F",
    "\u26C8\uFE0F",
    "\u26CE",
    "\u26CF\uFE0F",
    "\u26D1\uFE0F",
    "\u26D3\uFE0F",
    "\u26D4\uFE0F",
    "\u26E9\uFE0F",
    "\u26EA\uFE0F",
    "\u26F0\uFE0F",
    "\u26F1\uFE0F",
    "\u26F2\uFE0F",
    "\u26F3\uFE0F",
    "\u26F4\uFE0F",
    "\u26F5\uFE0F",
    "\u26F7\u{1F3FB}",
    "\u26F7\u{1F3FC}",
    "\u26F7\u{1F3FD}",
    "\u26F7\u{1F3FE}",
    "\u26F7\u{1F3FF}",
    "\u26F7\uFE0F",
    "\u26F8\uFE0F",
    "\u26F9\u{1F3FB}\u200D\u2640\uFE0F",
    "\u26F9\u{1F3FB}\u200D\u2642\uFE0F",
    "\u26F9\u{1F3FB}",
    "\u26F9\u{1F3FC}\u200D\u2640\uFE0F",
    "\u26F9\u{1F3FC}\u200D\u2642\uFE0F",
    "\u26F9\u{1F3FC}",
    "\u26F9\u{1F3FD}\u200D\u2640\uFE0F",
    "\u26F9\u{1F3FD}\u200D\u2642\uFE0F",
    "\u26F9\u{1F3FD}",
    "\u26F9\u{1F3FE}\u200D\u2640\uFE0F",
    "\u26F9\u{1F3FE}\u200D\u2642\uFE0F",
    "\u26F9\u{1F3FE}",
    "\u26F9\u{1F3FF}\u200D\u2640\uFE0F",
    "\u26F9\u{1F3FF}\u200D\u2642\uFE0F",
    "\u26F9\u{1F3FF}",
    "\u26F9\uFE0F\u200D\u2640\uFE0F",
    "\u26F9\uFE0F\u200D\u2642\uFE0F",
    "\u26F9\uFE0F",
    "\u26FA\uFE0F",
    "\u26FD\uFE0F",
    "\u2702\uFE0F",
    "\u2705",
    "\u2708\uFE0F",
    "\u2709\uFE0F",
    "\u270A\u{1F3FB}",
    "\u270A\u{1F3FC}",
    "\u270A\u{1F3FD}",
    "\u270A\u{1F3FE}",
    "\u270A\u{1F3FF}",
    "\u270A",
    "\u270B\u{1F3FB}",
    "\u270B\u{1F3FC}",
    "\u270B\u{1F3FD}",
    "\u270B\u{1F3FE}",
    "\u270B\u{1F3FF}",
    "\u270B",
    "\u270C\u{1F3FB}",
    "\u270C\u{1F3FC}",
    "\u270C\u{1F3FD}",
    "\u270C\u{1F3FE}",
    "\u270C\u{1F3FF}",
    "\u270C\uFE0F",
    "\u270D\u{1F3FB}",
    "\u270D\u{1F3FC}",
    "\u270D\u{1F3FD}",
    "\u270D\u{1F3FE}",
    "\u270D\u{1F3FF}",
    "\u270D\uFE0F",
    "\u270F\uFE0F",
    "\u2712\uFE0F",
    "\u2714\uFE0F",
    "\u2716\uFE0F",
    "\u271D\uFE0F",
    "\u2721\uFE0F",
    "\u2728",
    "\u2733\uFE0F",
    "\u2734\uFE0F",
    "\u2744\uFE0F",
    "\u2747\uFE0F",
    "\u274C",
    "\u274E",
    "\u2753",
    "\u2754",
    "\u2755",
    "\u2757\uFE0F",
    "\u2763\uFE0F",
    "\u2764\uFE0F",
    "\u2795",
    "\u2796",
    "\u2797",
    "\u27A1\uFE0F",
    "\u27B0",
    "\u27BF",
    "\u2934\uFE0F",
    "\u2935\uFE0F",
    "*\u20E3",
    "\u2B05\uFE0F",
    "\u2B06\uFE0F",
    "\u2B07\uFE0F",
    "\u2B1B\uFE0F",
    "\u2B1C\uFE0F",
    "\u2B50\uFE0F",
    "\u2B55\uFE0F",
    "0\u20E3",
    "\u3030\uFE0F",
    "\u303D\uFE0F",
    "1\u20E3",
    "2\u20E3",
    "\u3297\uFE0F",
    "\u3299\uFE0F",
    "3\u20E3",
    "4\u20E3",
    "5\u20E3",
    "6\u20E3",
    "7\u20E3",
    "8\u20E3",
    "9\u20E3",
    "\xA9\uFE0F",
    "\xAE\uFE0F",
    "\uE50A"
  ];
});

// node_modules/loader-utils/lib/interpolateName.js
var require_interpolateName = __commonJS((exports2, module2) => {
  "use strict";
  var path4 = require("path");
  var emojisList = require_emojis_list();
  var getHashDigest = require_getHashDigest();
  var emojiRegex = /[\uD800-\uDFFF]./;
  var emojiList = emojisList.filter((emoji) => emojiRegex.test(emoji));
  var emojiCache = {};
  function encodeStringToEmoji(content, length) {
    if (emojiCache[content]) {
      return emojiCache[content];
    }
    length = length || 1;
    const emojis = [];
    do {
      if (!emojiList.length) {
        throw new Error("Ran out of emoji");
      }
      const index = Math.floor(Math.random() * emojiList.length);
      emojis.push(emojiList[index]);
      emojiList.splice(index, 1);
    } while (--length > 0);
    const emojiEncoding = emojis.join("");
    emojiCache[content] = emojiEncoding;
    return emojiEncoding;
  }
  function interpolateName(loaderContext, name, options) {
    let filename;
    const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;
    if (typeof name === "function") {
      filename = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : void 0);
    } else {
      filename = name || "[hash].[ext]";
    }
    const context = options.context;
    const content = options.content;
    const regExp = options.regExp;
    let ext = "bin";
    let basename = "file";
    let directory = "";
    let folder = "";
    let query = "";
    if (loaderContext.resourcePath) {
      const parsed = path4.parse(loaderContext.resourcePath);
      let resourcePath = loaderContext.resourcePath;
      if (parsed.ext) {
        ext = parsed.ext.substr(1);
      }
      if (parsed.dir) {
        basename = parsed.name;
        resourcePath = parsed.dir + path4.sep;
      }
      if (typeof context !== "undefined") {
        directory = path4.relative(context, resourcePath + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
        directory = directory.substr(0, directory.length - 1);
      } else {
        directory = resourcePath.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
      }
      if (directory.length === 1) {
        directory = "";
      } else if (directory.length > 1) {
        folder = path4.basename(directory);
      }
    }
    if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {
      query = loaderContext.resourceQuery;
      const hashIdx = query.indexOf("#");
      if (hashIdx >= 0) {
        query = query.substr(0, hashIdx);
      }
    }
    let url = filename;
    if (content) {
      url = url.replace(/\[(?:([^:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi, (all, hashType, digestType, maxLength) => getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))).replace(/\[emoji(?::(\d+))?\]/gi, (all, length) => encodeStringToEmoji(content, parseInt(length, 10)));
    }
    url = url.replace(/\[ext\]/gi, () => ext).replace(/\[name\]/gi, () => basename).replace(/\[path\]/gi, () => directory).replace(/\[folder\]/gi, () => folder).replace(/\[query\]/gi, () => query);
    if (regExp && loaderContext.resourcePath) {
      const match = loaderContext.resourcePath.match(new RegExp(regExp));
      match && match.forEach((matched, i) => {
        url = url.replace(new RegExp("\\[" + i + "\\]", "ig"), matched);
      });
    }
    if (typeof loaderContext.options === "object" && typeof loaderContext.options.customInterpolateName === "function") {
      url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);
    }
    return url;
  }
  module2.exports = interpolateName;
});

// node_modules/loader-utils/lib/index.js
var require_lib3 = __commonJS((exports2) => {
  "use strict";
  var getOptions = require_getOptions();
  var parseQuery = require_parseQuery();
  var stringifyRequest = require_stringifyRequest();
  var getRemainingRequest = require_getRemainingRequest();
  var getCurrentRequest = require_getCurrentRequest();
  var isUrlRequest = require_isUrlRequest();
  var urlToRequest = require_urlToRequest();
  var parseString = require_parseString();
  var getHashDigest = require_getHashDigest();
  var interpolateName = require_interpolateName();
  exports2.getOptions = getOptions;
  exports2.parseQuery = parseQuery;
  exports2.stringifyRequest = stringifyRequest;
  exports2.getRemainingRequest = getRemainingRequest;
  exports2.getCurrentRequest = getCurrentRequest;
  exports2.isUrlRequest = isUrlRequest;
  exports2.urlToRequest = urlToRequest;
  exports2.parseString = parseString;
  exports2.getHashDigest = getHashDigest;
  exports2.interpolateName = interpolateName;
});

// node_modules/generic-names/index.js
var require_generic_names = __commonJS((exports2, module2) => {
  "use strict";
  var interpolateName = require_lib3().interpolateName;
  var path4 = require("path");
  module2.exports = function createGenerator(pattern, options) {
    options = options || {};
    var context = options && typeof options.context === "string" ? options.context : process.cwd();
    var hashPrefix = options && typeof options.hashPrefix === "string" ? options.hashPrefix : "";
    return function generate(localName, filepath) {
      var name = pattern.replace(/\[local\]/gi, localName);
      var loaderContext = {
        resourcePath: filepath
      };
      var loaderOptions = {
        content: hashPrefix + path4.relative(context, filepath).replace(/\\/g, "/") + "+" + localName,
        context
      };
      var genericName = interpolateName(loaderContext, name, loaderOptions);
      return genericName.replace(new RegExp("[^a-zA-Z0-9\\-_\xA0-\uFFFF]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
    };
  };
});

// node_modules/postcss-modules/build/unquote/index.js
var require_unquote = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = unquote;
  var reg = /['"]/;
  function unquote(str) {
    if (!str) {
      return "";
    }
    if (reg.test(str.charAt(0))) {
      str = str.substr(1);
    }
    if (reg.test(str.charAt(str.length - 1))) {
      str = str.substr(0, str.length - 1);
    }
    return str;
  }
});

// node_modules/icss-replace-symbols/lib/index.js
var require_lib4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.replaceAll = replaceAll;
  var matchConstName = /[$#]?[\w-\.]+/g;
  function replaceAll(replacements, text) {
    var matches = void 0;
    while (matches = matchConstName.exec(text)) {
      var replacement = replacements[matches[0]];
      if (replacement) {
        text = text.slice(0, matches.index) + replacement + text.slice(matchConstName.lastIndex);
        matchConstName.lastIndex -= matches[0].length - replacement.length;
      }
    }
    return text;
  }
  exports2.default = function(css, translations) {
    css.walkDecls(function(decl) {
      return decl.value = replaceAll(translations, decl.value);
    });
    css.walkAtRules("media", function(atRule) {
      return atRule.params = replaceAll(translations, atRule.params);
    });
  };
});

// node_modules/postcss-modules/build/css-loader-core/parser.js
var require_parser3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _icssReplaceSymbols = require_lib4();
  var _icssReplaceSymbols2 = _interopRequireDefault(_icssReplaceSymbols);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var importRegexp = /^:import\((.+)\)$/;
  var Parser = class {
    constructor(pathFetcher, trace) {
      this.pathFetcher = pathFetcher;
      this.plugin = this.plugin.bind(this);
      this.exportTokens = {};
      this.translations = {};
      this.trace = trace;
    }
    plugin() {
      const parser = this;
      return {
        postcssPlugin: "css-modules-parser",
        OnceExit(css) {
          return Promise.all(parser.fetchAllImports(css)).then(() => parser.linkImportedSymbols(css)).then(() => parser.extractExports(css));
        }
      };
    }
    fetchAllImports(css) {
      let imports = [];
      css.each((node) => {
        if (node.type == "rule" && node.selector.match(importRegexp)) {
          imports.push(this.fetchImport(node, css.source.input.from, imports.length));
        }
      });
      return imports;
    }
    linkImportedSymbols(css) {
      (0, _icssReplaceSymbols2.default)(css, this.translations);
    }
    extractExports(css) {
      css.each((node) => {
        if (node.type == "rule" && node.selector == ":export")
          this.handleExport(node);
      });
    }
    handleExport(exportNode) {
      exportNode.each((decl) => {
        if (decl.type == "decl") {
          Object.keys(this.translations).forEach((translation) => {
            decl.value = decl.value.replace(translation, this.translations[translation]);
          });
          this.exportTokens[decl.prop] = decl.value;
        }
      });
      exportNode.remove();
    }
    fetchImport(importNode, relativeTo, depNr) {
      let file = importNode.selector.match(importRegexp)[1], depTrace = this.trace + String.fromCharCode(depNr);
      return this.pathFetcher(file, relativeTo, depTrace).then((exports3) => {
        importNode.each((decl) => {
          if (decl.type == "decl") {
            this.translations[decl.prop] = exports3[decl.value];
          }
        });
        importNode.remove();
      }, (err) => console.log(err));
    }
  };
  exports2.default = Parser;
});

// node_modules/postcss-modules/build/css-loader-core/loader.js
var require_loader = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _postcss = require_postcss();
  var _postcss2 = _interopRequireDefault(_postcss);
  var _fs = require("fs");
  var _fs2 = _interopRequireDefault(_fs);
  var _path = require("path");
  var _path2 = _interopRequireDefault(_path);
  var _parser = require_parser3();
  var _parser2 = _interopRequireDefault(_parser);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var Core = class {
    constructor(plugins) {
      this.plugins = plugins || Core.defaultPlugins;
    }
    load(sourceString, sourcePath, trace, pathFetcher) {
      let parser = new _parser2.default(pathFetcher, trace);
      return (0, _postcss2.default)(this.plugins.concat([parser.plugin()])).process(sourceString, {from: "/" + sourcePath}).then((result) => {
        return {
          injectableSource: result.css,
          exportTokens: parser.exportTokens
        };
      });
    }
  };
  var traceKeySorter = (a, b) => {
    if (a.length < b.length) {
      return a < b.substring(0, a.length) ? -1 : 1;
    } else if (a.length > b.length) {
      return a.substring(0, b.length) <= b ? -1 : 1;
    } else {
      return a < b ? -1 : 1;
    }
  };
  var FileSystemLoader = class {
    constructor(root, plugins) {
      this.root = root;
      this.sources = {};
      this.traces = {};
      this.importNr = 0;
      this.core = new Core(plugins);
      this.tokensByFile = {};
    }
    fetch(_newPath, relativeTo, _trace) {
      let newPath = _newPath.replace(/^["']|["']$/g, ""), trace = _trace || String.fromCharCode(this.importNr++);
      return new Promise((resolve, reject) => {
        let relativeDir = _path2.default.dirname(relativeTo), rootRelativePath = _path2.default.resolve(relativeDir, newPath), fileRelativePath = _path2.default.resolve(_path2.default.join(this.root, relativeDir), newPath);
        if (newPath[0] !== "." && newPath[0] !== "/") {
          try {
            fileRelativePath = require.resolve(newPath);
          } catch (e) {
          }
        }
        const tokens = this.tokensByFile[fileRelativePath];
        if (tokens) {
          return resolve(tokens);
        }
        _fs2.default.readFile(fileRelativePath, "utf-8", (err, source) => {
          if (err)
            reject(err);
          this.core.load(source, rootRelativePath, trace, this.fetch.bind(this)).then(({injectableSource, exportTokens}) => {
            this.sources[fileRelativePath] = injectableSource;
            this.traces[trace] = fileRelativePath;
            this.tokensByFile[fileRelativePath] = exportTokens;
            resolve(exportTokens);
          }, reject);
        });
      });
    }
    get finalSource() {
      const traces = this.traces;
      const sources = this.sources;
      let written = new Set();
      return Object.keys(traces).sort(traceKeySorter).map((key) => {
        const filename = traces[key];
        if (written.has(filename)) {
          return null;
        }
        written.add(filename);
        return sources[filename];
      }).join("");
    }
  };
  exports2.default = FileSystemLoader;
});

// node_modules/string-hash/index.js
var require_string_hash = __commonJS((exports2, module2) => {
  "use strict";
  function hash(str) {
    var hash2 = 5381, i = str.length;
    while (i) {
      hash2 = hash2 * 33 ^ str.charCodeAt(--i);
    }
    return hash2 >>> 0;
  }
  module2.exports = hash;
});

// node_modules/postcss-modules/build/generateScopedName.js
var require_generateScopedName = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = generateScopedName;
  var _stringHash = require_string_hash();
  var _stringHash2 = _interopRequireDefault(_stringHash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function generateScopedName(name, filename, css) {
    const i = css.indexOf(`.${name}`);
    const lineNumber = css.substr(0, i).split(/[\r\n]/).length;
    const hash = (0, _stringHash2.default)(css).toString(36).substr(0, 5);
    return `_${name}_${hash}_${lineNumber}`;
  }
});

// node_modules/postcss-modules/build/saveJSON.js
var require_saveJSON = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = saveJSON;
  var _fs = require("fs");
  function saveJSON(cssFile, json) {
    return new Promise((resolve, reject) => {
      (0, _fs.writeFile)(`${cssFile}.json`, JSON.stringify(json), (e) => e ? reject(e) : resolve(json));
    });
  }
});

// node_modules/postcss-value-parser/lib/parse.js
var require_parse3 = __commonJS((exports2, module2) => {
  var openParentheses = "(".charCodeAt(0);
  var closeParentheses = ")".charCodeAt(0);
  var singleQuote = "'".charCodeAt(0);
  var doubleQuote = '"'.charCodeAt(0);
  var backslash = "\\".charCodeAt(0);
  var slash = "/".charCodeAt(0);
  var comma = ",".charCodeAt(0);
  var colon = ":".charCodeAt(0);
  var star = "*".charCodeAt(0);
  var uLower = "u".charCodeAt(0);
  var uUpper = "U".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var isUnicodeRange = /^[a-f0-9?-]+$/i;
  module2.exports = function(input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [{nodes: tokens}];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while (pos < max) {
      if (code <= 32) {
        next = pos;
        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);
        token = value.slice(pos, next);
        prev = tokens[tokens.length - 1];
        if (code === closeParentheses && balanced) {
          after = token;
        } else if (prev && prev.type === "div") {
          prev.after = token;
        } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
          before = token;
        } else {
          tokens.push({
            type: "space",
            sourceIndex: pos,
            value: token
          });
        }
        pos = next;
      } else if (code === singleQuote || code === doubleQuote) {
        next = pos;
        quote = code === singleQuote ? "'" : '"';
        token = {
          type: "string",
          sourceIndex: pos,
          quote
        };
        do {
          escape = false;
          next = value.indexOf(quote, next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += quote;
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        token.value = value.slice(pos + 1, next);
        tokens.push(token);
        pos = next + 1;
        code = value.charCodeAt(pos);
      } else if (code === slash && value.charCodeAt(pos + 1) === star) {
        token = {
          type: "comment",
          sourceIndex: pos
        };
        next = value.indexOf("*/", pos);
        if (next === -1) {
          token.unclosed = true;
          next = value.length;
        }
        token.value = value.slice(pos + 2, next);
        tokens.push(token);
        pos = next + 2;
        code = value.charCodeAt(pos);
      } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
        token = value[pos];
        tokens.push({
          type: "word",
          sourceIndex: pos - before.length,
          value: token
        });
        pos += 1;
        code = value.charCodeAt(pos);
      } else if (code === slash || code === comma || code === colon) {
        token = value[pos];
        tokens.push({
          type: "div",
          sourceIndex: pos - before.length,
          value: token,
          before,
          after: ""
        });
        before = "";
        pos += 1;
        code = value.charCodeAt(pos);
      } else if (openParentheses === code) {
        next = pos;
        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);
        parenthesesOpenPos = pos;
        token = {
          type: "function",
          sourceIndex: pos - name.length,
          value: name,
          before: value.slice(parenthesesOpenPos + 1, next)
        };
        pos = next;
        if (name === "url" && code !== singleQuote && code !== doubleQuote) {
          next -= 1;
          do {
            escape = false;
            next = value.indexOf(")", next + 1);
            if (~next) {
              escapePos = next;
              while (value.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape = !escape;
              }
            } else {
              value += ")";
              next = value.length - 1;
              token.unclosed = true;
            }
          } while (escape);
          whitespacePos = next;
          do {
            whitespacePos -= 1;
            code = value.charCodeAt(whitespacePos);
          } while (code <= 32);
          if (parenthesesOpenPos < whitespacePos) {
            if (pos !== whitespacePos + 1) {
              token.nodes = [
                {
                  type: "word",
                  sourceIndex: pos,
                  value: value.slice(pos, whitespacePos + 1)
                }
              ];
            } else {
              token.nodes = [];
            }
            if (token.unclosed && whitespacePos + 1 !== next) {
              token.after = "";
              token.nodes.push({
                type: "space",
                sourceIndex: whitespacePos + 1,
                value: value.slice(whitespacePos + 1, next)
              });
            } else {
              token.after = value.slice(whitespacePos + 1, next);
            }
          } else {
            token.after = "";
            token.nodes = [];
          }
          pos = next + 1;
          code = value.charCodeAt(pos);
          tokens.push(token);
        } else {
          balanced += 1;
          token.after = "";
          tokens.push(token);
          stack.push(token);
          tokens = token.nodes = [];
          parent = token;
        }
        name = "";
      } else if (closeParentheses === code && balanced) {
        pos += 1;
        code = value.charCodeAt(pos);
        parent.after = after;
        after = "";
        balanced -= 1;
        stack.pop();
        parent = stack[balanced];
        tokens = parent.nodes;
      } else {
        next = pos;
        do {
          if (code === backslash) {
            next += 1;
          }
          next += 1;
          code = value.charCodeAt(next);
        } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
        token = value.slice(pos, next);
        if (openParentheses === code) {
          name = token;
        } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
          tokens.push({
            type: "unicode-range",
            sourceIndex: pos,
            value: token
          });
        } else {
          tokens.push({
            type: "word",
            sourceIndex: pos,
            value: token
          });
        }
        pos = next;
      }
    }
    for (pos = stack.length - 1; pos; pos -= 1) {
      stack[pos].unclosed = true;
    }
    return stack[0].nodes;
  };
});

// node_modules/postcss-value-parser/lib/walk.js
var require_walk = __commonJS((exports2, module2) => {
  module2.exports = function walk(nodes, cb, bubble) {
    var i, max, node, result;
    for (i = 0, max = nodes.length; i < max; i += 1) {
      node = nodes[i];
      if (!bubble) {
        result = cb(node, i, nodes);
      }
      if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
        walk(node.nodes, cb, bubble);
      }
      if (bubble) {
        cb(node, i, nodes);
      }
    }
  };
});

// node_modules/postcss-value-parser/lib/stringify.js
var require_stringify3 = __commonJS((exports2, module2) => {
  function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;
    if (custom && (customResult = custom(node)) !== void 0) {
      return customResult;
    } else if (type === "word" || type === "space") {
      return value;
    } else if (type === "string") {
      buf = node.quote || "";
      return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
      return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
      return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
      buf = stringify(node.nodes, custom);
      if (type !== "function") {
        return buf;
      }
      return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }
    return value;
  }
  function stringify(nodes, custom) {
    var result, i;
    if (Array.isArray(nodes)) {
      result = "";
      for (i = nodes.length - 1; ~i; i -= 1) {
        result = stringifyNode(nodes[i], custom) + result;
      }
      return result;
    }
    return stringifyNode(nodes, custom);
  }
  module2.exports = stringify;
});

// node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS((exports2, module2) => {
  var minus = "-".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0);
  function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
      nextCode = value.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      var nextNextCode = value.charCodeAt(2);
      if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code === dot) {
      nextCode = value.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code >= 48 && code <= 57) {
      return true;
    }
    return false;
  }
  module2.exports = function(value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value)) {
      return false;
    }
    code = value.charCodeAt(pos);
    if (code === plus || code === minus) {
      pos++;
    }
    while (pos < length) {
      code = value.charCodeAt(pos);
      if (code < 48 || code > 57) {
        break;
      }
      pos += 1;
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
      pos += 2;
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
      pos += nextCode === plus || nextCode === minus ? 3 : 2;
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    return {
      number: value.slice(0, pos),
      unit: value.slice(pos)
    };
  };
});

// node_modules/postcss-value-parser/lib/index.js
var require_lib5 = __commonJS((exports2, module2) => {
  var parse2 = require_parse3();
  var walk = require_walk();
  var stringify = require_stringify3();
  function ValueParser(value) {
    if (this instanceof ValueParser) {
      this.nodes = parse2(value);
      return this;
    }
    return new ValueParser(value);
  }
  ValueParser.prototype.toString = function() {
    return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
  };
  ValueParser.prototype.walk = function(cb, bubble) {
    walk(this.nodes, cb, bubble);
    return this;
  };
  ValueParser.unit = require_unit();
  ValueParser.walk = walk;
  ValueParser.stringify = stringify;
  module2.exports = ValueParser;
});

// node_modules/icss-utils/src/replaceValueSymbols.js
var require_replaceValueSymbols = __commonJS((exports2, module2) => {
  var matchValueName = /[$]?[\w-]+/g;
  var replaceValueSymbols = (value, replacements) => {
    let matches;
    while (matches = matchValueName.exec(value)) {
      const replacement = replacements[matches[0]];
      if (replacement) {
        value = value.slice(0, matches.index) + replacement + value.slice(matchValueName.lastIndex);
        matchValueName.lastIndex -= matches[0].length - replacement.length;
      }
    }
    return value;
  };
  module2.exports = replaceValueSymbols;
});

// node_modules/icss-utils/src/replaceSymbols.js
var require_replaceSymbols = __commonJS((exports2, module2) => {
  var replaceValueSymbols = require_replaceValueSymbols();
  var replaceSymbols = (css, replacements) => {
    css.walk((node) => {
      if (node.type === "decl" && node.value) {
        node.value = replaceValueSymbols(node.value.toString(), replacements);
      } else if (node.type === "rule" && node.selector) {
        node.selector = replaceValueSymbols(node.selector.toString(), replacements);
      } else if (node.type === "atrule" && node.params) {
        node.params = replaceValueSymbols(node.params.toString(), replacements);
      }
    });
  };
  module2.exports = replaceSymbols;
});

// node_modules/icss-utils/src/extractICSS.js
var require_extractICSS = __commonJS((exports2, module2) => {
  var importPattern = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/;
  var balancedQuotes = /^("[^"]*"|'[^']*'|[^"']+)$/;
  var getDeclsObject = (rule) => {
    const object = {};
    rule.walkDecls((decl) => {
      const before = decl.raws.before ? decl.raws.before.trim() : "";
      object[before + decl.prop] = decl.value;
    });
    return object;
  };
  var extractICSS = (css, removeRules = true, mode = "auto") => {
    const icssImports = {};
    const icssExports = {};
    function addImports(node, path4) {
      const unquoted = path4.replace(/'|"/g, "");
      icssImports[unquoted] = Object.assign(icssImports[unquoted] || {}, getDeclsObject(node));
      if (removeRules) {
        node.remove();
      }
    }
    function addExports(node) {
      Object.assign(icssExports, getDeclsObject(node));
      if (removeRules) {
        node.remove();
      }
    }
    css.each((node) => {
      if (node.type === "rule" && mode !== "at-rule") {
        if (node.selector.slice(0, 7) === ":import") {
          const matches = importPattern.exec(node.selector);
          if (matches) {
            addImports(node, matches[1]);
          }
        }
        if (node.selector === ":export") {
          addExports(node);
        }
      }
      if (node.type === "atrule" && mode !== "rule") {
        if (node.name === "icss-import") {
          const matches = balancedQuotes.exec(node.params);
          if (matches) {
            addImports(node, matches[1]);
          }
        }
        if (node.name === "icss-export") {
          addExports(node);
        }
      }
    });
    return {icssImports, icssExports};
  };
  module2.exports = extractICSS;
});

// node_modules/icss-utils/src/createICSSRules.js
var require_createICSSRules = __commonJS((exports2, module2) => {
  var createImports = (imports, postcss, mode = "rule") => {
    return Object.keys(imports).map((path4) => {
      const aliases = imports[path4];
      const declarations = Object.keys(aliases).map((key) => postcss.decl({
        prop: key,
        value: aliases[key],
        raws: {before: "\n  "}
      }));
      const hasDeclarations = declarations.length > 0;
      const rule = mode === "rule" ? postcss.rule({
        selector: `:import('${path4}')`,
        raws: {after: hasDeclarations ? "\n" : ""}
      }) : postcss.atRule({
        name: "icss-import",
        params: `'${path4}'`,
        raws: {after: hasDeclarations ? "\n" : ""}
      });
      if (hasDeclarations) {
        rule.append(declarations);
      }
      return rule;
    });
  };
  var createExports = (exports3, postcss, mode = "rule") => {
    const declarations = Object.keys(exports3).map((key) => postcss.decl({
      prop: key,
      value: exports3[key],
      raws: {before: "\n  "}
    }));
    if (declarations.length === 0) {
      return [];
    }
    const rule = mode === "rule" ? postcss.rule({
      selector: `:export`,
      raws: {after: "\n"}
    }) : postcss.atRule({
      name: "icss-export",
      raws: {after: "\n"}
    });
    rule.append(declarations);
    return [rule];
  };
  var createICSSRules = (imports, exports3, postcss, mode) => [
    ...createImports(imports, postcss, mode),
    ...createExports(exports3, postcss, mode)
  ];
  module2.exports = createICSSRules;
});

// node_modules/icss-utils/src/index.js
var require_src = __commonJS((exports2, module2) => {
  var replaceValueSymbols = require_replaceValueSymbols();
  var replaceSymbols = require_replaceSymbols();
  var extractICSS = require_extractICSS();
  var createICSSRules = require_createICSSRules();
  module2.exports = {
    replaceValueSymbols,
    replaceSymbols,
    extractICSS,
    createICSSRules
  };
});

// node_modules/postcss-modules-local-by-default/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  "use strict";
  var selectorParser = require_dist();
  var valueParser = require_lib5();
  var {extractICSS} = require_src();
  var isSpacing = (node) => node.type === "combinator" && node.value === " ";
  function normalizeNodeArray(nodes) {
    const array = [];
    nodes.forEach((x) => {
      if (Array.isArray(x)) {
        normalizeNodeArray(x).forEach((item) => {
          array.push(item);
        });
      } else if (x) {
        array.push(x);
      }
    });
    if (array.length > 0 && isSpacing(array[array.length - 1])) {
      array.pop();
    }
    return array;
  }
  function localizeNode(rule, mode, localAliasMap) {
    const transform = (node, context) => {
      if (context.ignoreNextSpacing && !isSpacing(node)) {
        throw new Error("Missing whitespace after " + context.ignoreNextSpacing);
      }
      if (context.enforceNoSpacing && isSpacing(node)) {
        throw new Error("Missing whitespace before " + context.enforceNoSpacing);
      }
      let newNodes;
      switch (node.type) {
        case "root": {
          let resultingGlobal;
          context.hasPureGlobals = false;
          newNodes = node.nodes.map((n) => {
            const nContext = {
              global: context.global,
              lastWasSpacing: true,
              hasLocals: false,
              explicit: false
            };
            n = transform(n, nContext);
            if (typeof resultingGlobal === "undefined") {
              resultingGlobal = nContext.global;
            } else if (resultingGlobal !== nContext.global) {
              throw new Error('Inconsistent rule global/local result in rule "' + node + '" (multiple selectors must result in the same mode for the rule)');
            }
            if (!nContext.hasLocals) {
              context.hasPureGlobals = true;
            }
            return n;
          });
          context.global = resultingGlobal;
          node.nodes = normalizeNodeArray(newNodes);
          break;
        }
        case "selector": {
          newNodes = node.map((childNode) => transform(childNode, context));
          node = node.clone();
          node.nodes = normalizeNodeArray(newNodes);
          break;
        }
        case "combinator": {
          if (isSpacing(node)) {
            if (context.ignoreNextSpacing) {
              context.ignoreNextSpacing = false;
              context.lastWasSpacing = false;
              context.enforceNoSpacing = false;
              return null;
            }
            context.lastWasSpacing = true;
            return node;
          }
          break;
        }
        case "pseudo": {
          let childContext;
          const isNested = !!node.length;
          const isScoped = node.value === ":local" || node.value === ":global";
          const isImportExport = node.value === ":import" || node.value === ":export";
          if (isImportExport) {
            context.hasLocals = true;
          } else if (isNested) {
            if (isScoped) {
              if (node.nodes.length === 0) {
                throw new Error(`${node.value}() can't be empty`);
              }
              if (context.inside) {
                throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);
              }
              childContext = {
                global: node.value === ":global",
                inside: node.value,
                hasLocals: false,
                explicit: true
              };
              newNodes = node.map((childNode) => transform(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);
              if (newNodes.length) {
                const {before, after} = node.spaces;
                const first = newNodes[0];
                const last = newNodes[newNodes.length - 1];
                first.spaces = {before, after: first.spaces.after};
                last.spaces = {before: last.spaces.before, after};
              }
              node = newNodes;
              break;
            } else {
              childContext = {
                global: context.global,
                inside: context.inside,
                lastWasSpacing: true,
                hasLocals: false,
                explicit: context.explicit
              };
              newNodes = node.map((childNode) => transform(childNode, childContext));
              node = node.clone();
              node.nodes = normalizeNodeArray(newNodes);
              if (childContext.hasLocals) {
                context.hasLocals = true;
              }
            }
            break;
          } else if (isScoped) {
            if (context.inside) {
              throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);
            }
            const addBackSpacing = !!node.spaces.before;
            context.ignoreNextSpacing = context.lastWasSpacing ? node.value : false;
            context.enforceNoSpacing = context.lastWasSpacing ? false : node.value;
            context.global = node.value === ":global";
            context.explicit = true;
            return addBackSpacing ? selectorParser.combinator({value: " "}) : null;
          }
          break;
        }
        case "id":
        case "class": {
          if (!node.value) {
            throw new Error("Invalid class or id selector syntax");
          }
          if (context.global) {
            break;
          }
          const isImportedValue = localAliasMap.has(node.value);
          const isImportedWithExplicitScope = isImportedValue && context.explicit;
          if (!isImportedValue || isImportedWithExplicitScope) {
            const innerNode = node.clone();
            innerNode.spaces = {before: "", after: ""};
            node = selectorParser.pseudo({
              value: ":local",
              nodes: [innerNode],
              spaces: node.spaces
            });
            context.hasLocals = true;
          }
          break;
        }
      }
      context.lastWasSpacing = false;
      context.ignoreNextSpacing = false;
      context.enforceNoSpacing = false;
      return node;
    };
    const rootContext = {
      global: mode === "global",
      hasPureGlobals: false
    };
    rootContext.selector = selectorParser((root) => {
      transform(root, rootContext);
    }).processSync(rule, {updateSelector: false, lossless: true});
    return rootContext;
  }
  function localizeDeclNode(node, context) {
    switch (node.type) {
      case "word":
        if (context.localizeNextItem) {
          if (!context.localAliasMap.has(node.value)) {
            node.value = ":local(" + node.value + ")";
            context.localizeNextItem = false;
          }
        }
        break;
      case "function":
        if (context.options && context.options.rewriteUrl && node.value.toLowerCase() === "url") {
          node.nodes.map((nestedNode) => {
            if (nestedNode.type !== "string" && nestedNode.type !== "word") {
              return;
            }
            let newUrl = context.options.rewriteUrl(context.global, nestedNode.value);
            switch (nestedNode.type) {
              case "string":
                if (nestedNode.quote === "'") {
                  newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'");
                }
                if (nestedNode.quote === '"') {
                  newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"');
                }
                break;
              case "word":
                newUrl = newUrl.replace(/("|'|\)|\\)/g, "\\$1");
                break;
            }
            nestedNode.value = newUrl;
          });
        }
        break;
    }
    return node;
  }
  function isWordAFunctionArgument(wordNode, functionNode) {
    return functionNode ? functionNode.nodes.some((functionNodeChild) => functionNodeChild.sourceIndex === wordNode.sourceIndex) : false;
  }
  function localizeDeclarationValues(localize, declaration, context) {
    const valueNodes = valueParser(declaration.value);
    valueNodes.walk((node, index, nodes) => {
      const subContext = {
        options: context.options,
        global: context.global,
        localizeNextItem: localize && !context.global,
        localAliasMap: context.localAliasMap
      };
      nodes[index] = localizeDeclNode(node, subContext);
    });
    declaration.value = valueNodes.toString();
  }
  function localizeDeclaration(declaration, context) {
    const isAnimation = /animation$/i.test(declaration.prop);
    if (isAnimation) {
      const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;
      const animationKeywords = {
        $alternate: 1,
        "$alternate-reverse": 1,
        $backwards: 1,
        $both: 1,
        $ease: 1,
        "$ease-in": 1,
        "$ease-in-out": 1,
        "$ease-out": 1,
        $forwards: 1,
        $infinite: 1,
        $linear: 1,
        $none: Infinity,
        $normal: 1,
        $paused: 1,
        $reverse: 1,
        $running: 1,
        "$step-end": 1,
        "$step-start": 1,
        $initial: Infinity,
        $inherit: Infinity,
        $unset: Infinity
      };
      const didParseAnimationName = false;
      let parsedAnimationKeywords = {};
      let stepsFunctionNode = null;
      const valueNodes = valueParser(declaration.value).walk((node) => {
        if (node.type === "div") {
          parsedAnimationKeywords = {};
        }
        if (node.type === "function" && node.value.toLowerCase() === "steps") {
          stepsFunctionNode = node;
        }
        const value = node.type === "word" && !isWordAFunctionArgument(node, stepsFunctionNode) ? node.value.toLowerCase() : null;
        let shouldParseAnimationName = false;
        if (!didParseAnimationName && value && validIdent.test(value)) {
          if ("$" + value in animationKeywords) {
            parsedAnimationKeywords["$" + value] = "$" + value in parsedAnimationKeywords ? parsedAnimationKeywords["$" + value] + 1 : 0;
            shouldParseAnimationName = parsedAnimationKeywords["$" + value] >= animationKeywords["$" + value];
          } else {
            shouldParseAnimationName = true;
          }
        }
        const subContext = {
          options: context.options,
          global: context.global,
          localizeNextItem: shouldParseAnimationName && !context.global,
          localAliasMap: context.localAliasMap
        };
        return localizeDeclNode(node, subContext);
      });
      declaration.value = valueNodes.toString();
      return;
    }
    const isAnimationName = /animation(-name)?$/i.test(declaration.prop);
    if (isAnimationName) {
      return localizeDeclarationValues(true, declaration, context);
    }
    const hasUrl = /url\(/i.test(declaration.value);
    if (hasUrl) {
      return localizeDeclarationValues(false, declaration, context);
    }
  }
  module2.exports = (options = {}) => {
    if (options && options.mode && options.mode !== "global" && options.mode !== "local" && options.mode !== "pure") {
      throw new Error('options.mode must be either "global", "local" or "pure" (default "local")');
    }
    const pureMode = options && options.mode === "pure";
    const globalMode = options && options.mode === "global";
    return {
      postcssPlugin: "postcss-modules-local-by-default",
      prepare() {
        const localAliasMap = new Map();
        return {
          Once(root) {
            const {icssImports} = extractICSS(root, false);
            Object.keys(icssImports).forEach((key) => {
              Object.keys(icssImports[key]).forEach((prop) => {
                localAliasMap.set(prop, icssImports[key][prop]);
              });
            });
            root.walkAtRules((atRule) => {
              if (/keyframes$/i.test(atRule.name)) {
                const globalMatch = /^\s*:global\s*\((.+)\)\s*$/.exec(atRule.params);
                const localMatch = /^\s*:local\s*\((.+)\)\s*$/.exec(atRule.params);
                let globalKeyframes = globalMode;
                if (globalMatch) {
                  if (pureMode) {
                    throw atRule.error("@keyframes :global(...) is not allowed in pure mode");
                  }
                  atRule.params = globalMatch[1];
                  globalKeyframes = true;
                } else if (localMatch) {
                  atRule.params = localMatch[0];
                  globalKeyframes = false;
                } else if (!globalMode) {
                  if (atRule.params && !localAliasMap.has(atRule.params)) {
                    atRule.params = ":local(" + atRule.params + ")";
                  }
                }
                atRule.walkDecls((declaration) => {
                  localizeDeclaration(declaration, {
                    localAliasMap,
                    options,
                    global: globalKeyframes
                  });
                });
              } else if (atRule.nodes) {
                atRule.nodes.forEach((declaration) => {
                  if (declaration.type === "decl") {
                    localizeDeclaration(declaration, {
                      localAliasMap,
                      options,
                      global: globalMode
                    });
                  }
                });
              }
            });
            root.walkRules((rule) => {
              if (rule.parent && rule.parent.type === "atrule" && /keyframes$/i.test(rule.parent.name)) {
                return;
              }
              const context = localizeNode(rule, options.mode, localAliasMap);
              context.options = options;
              context.localAliasMap = localAliasMap;
              if (pureMode && context.hasPureGlobals) {
                throw rule.error('Selector "' + rule.selector + '" is not pure (pure selectors must contain at least one local class or id)');
              }
              rule.selector = context.selector;
              if (rule.nodes) {
                rule.nodes.forEach((declaration) => localizeDeclaration(declaration, context));
              }
            });
          }
        };
      }
    };
  };
  module2.exports.postcss = true;
});

// node_modules/postcss-modules-extract-imports/src/topologicalSort.js
var require_topologicalSort = __commonJS((exports2, module2) => {
  var PERMANENT_MARKER = 2;
  var TEMPORARY_MARKER = 1;
  function createError(node, graph) {
    const er = new Error("Nondeterministic import's order");
    const related = graph[node];
    const relatedNode = related.find((relatedNode2) => graph[relatedNode2].indexOf(node) > -1);
    er.nodes = [node, relatedNode];
    return er;
  }
  function walkGraph(node, graph, state, result, strict) {
    if (state[node] === PERMANENT_MARKER) {
      return;
    }
    if (state[node] === TEMPORARY_MARKER) {
      if (strict) {
        return createError(node, graph);
      }
      return;
    }
    state[node] = TEMPORARY_MARKER;
    const children = graph[node];
    const length = children.length;
    for (let i = 0; i < length; ++i) {
      const error = walkGraph(children[i], graph, state, result, strict);
      if (error instanceof Error) {
        return error;
      }
    }
    state[node] = PERMANENT_MARKER;
    result.push(node);
  }
  function topologicalSort(graph, strict) {
    const result = [];
    const state = {};
    const nodes = Object.keys(graph);
    const length = nodes.length;
    for (let i = 0; i < length; ++i) {
      const er = walkGraph(nodes[i], graph, state, result, strict);
      if (er instanceof Error) {
        return er;
      }
    }
    return result;
  }
  module2.exports = topologicalSort;
});

// node_modules/postcss-modules-extract-imports/src/index.js
var require_src3 = __commonJS((exports2, module2) => {
  var topologicalSort = require_topologicalSort();
  var matchImports = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;
  var icssImport = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
  var VISITED_MARKER = 1;
  function addImportToGraph(importId, parentId, graph, visited) {
    const siblingsId = parentId + "_siblings";
    const visitedId = parentId + "_" + importId;
    if (visited[visitedId] !== VISITED_MARKER) {
      if (!Array.isArray(visited[siblingsId])) {
        visited[siblingsId] = [];
      }
      const siblings = visited[siblingsId];
      if (Array.isArray(graph[importId])) {
        graph[importId] = graph[importId].concat(siblings);
      } else {
        graph[importId] = siblings.slice();
      }
      visited[visitedId] = VISITED_MARKER;
      siblings.push(importId);
    }
  }
  module2.exports = (options = {}) => {
    let importIndex = 0;
    const createImportedName = typeof options.createImportedName !== "function" ? (importName) => `i__imported_${importName.replace(/\W/g, "_")}_${importIndex++}` : options.createImportedName;
    const failOnWrongOrder = options.failOnWrongOrder;
    return {
      postcssPlugin: "postcss-modules-extract-imports",
      prepare() {
        const graph = {};
        const visited = {};
        const existingImports = {};
        const importDecls = {};
        const imports = {};
        return {
          Once(root, postcss) {
            root.walkRules((rule) => {
              const matches = icssImport.exec(rule.selector);
              if (matches) {
                const [, doubleQuotePath, singleQuotePath] = matches;
                const importPath = doubleQuotePath || singleQuotePath;
                addImportToGraph(importPath, "root", graph, visited);
                existingImports[importPath] = rule;
              }
            });
            root.walkDecls(/^composes$/, (declaration) => {
              const matches = declaration.value.match(matchImports);
              if (!matches) {
                return;
              }
              let tmpSymbols;
              let [
                ,
                symbols,
                doubleQuotePath,
                singleQuotePath,
                global2
              ] = matches;
              if (global2) {
                tmpSymbols = symbols.split(/\s+/).map((s) => `global(${s})`);
              } else {
                const importPath = doubleQuotePath || singleQuotePath;
                let parent = declaration.parent;
                let parentIndexes = "";
                while (parent.type !== "root") {
                  parentIndexes = parent.parent.index(parent) + "_" + parentIndexes;
                  parent = parent.parent;
                }
                const {selector} = declaration.parent;
                const parentRule = `_${parentIndexes}${selector}`;
                addImportToGraph(importPath, parentRule, graph, visited);
                importDecls[importPath] = declaration;
                imports[importPath] = imports[importPath] || {};
                tmpSymbols = symbols.split(/\s+/).map((s) => {
                  if (!imports[importPath][s]) {
                    imports[importPath][s] = createImportedName(s, importPath);
                  }
                  return imports[importPath][s];
                });
              }
              declaration.value = tmpSymbols.join(" ");
            });
            const importsOrder = topologicalSort(graph, failOnWrongOrder);
            if (importsOrder instanceof Error) {
              const importPath = importsOrder.nodes.find((importPath2) => importDecls.hasOwnProperty(importPath2));
              const decl = importDecls[importPath];
              throw decl.error("Failed to resolve order of composed modules " + importsOrder.nodes.map((importPath2) => "`" + importPath2 + "`").join(", ") + ".", {
                plugin: "postcss-modules-extract-imports",
                word: "composes"
              });
            }
            let lastImportRule;
            importsOrder.forEach((path4) => {
              const importedSymbols = imports[path4];
              let rule = existingImports[path4];
              if (!rule && importedSymbols) {
                rule = postcss.rule({
                  selector: `:import("${path4}")`,
                  raws: {after: "\n"}
                });
                if (lastImportRule) {
                  root.insertAfter(lastImportRule, rule);
                } else {
                  root.prepend(rule);
                }
              }
              lastImportRule = rule;
              if (!importedSymbols) {
                return;
              }
              Object.keys(importedSymbols).forEach((importedSymbol) => {
                rule.append(postcss.decl({
                  value: importedSymbol,
                  prop: importedSymbols[importedSymbol],
                  raws: {before: "\n  "}
                }));
              });
            });
          }
        };
      }
    };
  };
  module2.exports.postcss = true;
});

// node_modules/postcss-modules-scope/src/index.js
var require_src4 = __commonJS((exports2, module2) => {
  "use strict";
  var selectorParser = require_dist();
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function getSingleLocalNamesForComposes(root) {
    return root.nodes.map((node) => {
      if (node.type !== "selector" || node.nodes.length !== 1) {
        throw new Error(`composition is only allowed when selector is single :local class name not in "${root}"`);
      }
      node = node.nodes[0];
      if (node.type !== "pseudo" || node.value !== ":local" || node.nodes.length !== 1) {
        throw new Error('composition is only allowed when selector is single :local class name not in "' + root + '", "' + node + '" is weird');
      }
      node = node.first;
      if (node.type !== "selector" || node.length !== 1) {
        throw new Error('composition is only allowed when selector is single :local class name not in "' + root + '", "' + node + '" is weird');
      }
      node = node.first;
      if (node.type !== "class") {
        throw new Error('composition is only allowed when selector is single :local class name not in "' + root + '", "' + node + '" is weird');
      }
      return node.value;
    });
  }
  var whitespace = "[\\x20\\t\\r\\n\\f]";
  var unescapeRegExp = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig");
  function unescape2(str) {
    return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {
      const high = "0x" + escaped - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
    });
  }
  var plugin = (options = {}) => {
    const generateScopedName = options && options.generateScopedName || plugin.generateScopedName;
    const generateExportEntry = options && options.generateExportEntry || plugin.generateExportEntry;
    const exportGlobals = options && options.exportGlobals;
    return {
      postcssPlugin: "postcss-modules-scope",
      Once(root, {rule}) {
        const exports3 = Object.create(null);
        function exportScopedName(name, rawName) {
          const scopedName = generateScopedName(rawName ? rawName : name, root.source.input.from, root.source.input.css);
          const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, root.source.input.from, root.source.input.css);
          const {key, value} = exportEntry;
          exports3[key] = exports3[key] || [];
          if (exports3[key].indexOf(value) < 0) {
            exports3[key].push(value);
          }
          return scopedName;
        }
        function localizeNode(node) {
          switch (node.type) {
            case "selector":
              node.nodes = node.map(localizeNode);
              return node;
            case "class":
              return selectorParser.className({
                value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)
              });
            case "id": {
              return selectorParser.id({
                value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)
              });
            }
          }
          throw new Error(`${node.type} ("${node}") is not allowed in a :local block`);
        }
        function traverseNode(node) {
          switch (node.type) {
            case "pseudo":
              if (node.value === ":local") {
                if (node.nodes.length !== 1) {
                  throw new Error('Unexpected comma (",") in :local block');
                }
                const selector = localizeNode(node.first, node.spaces);
                selector.first.spaces = node.spaces;
                const nextNode = node.next();
                if (nextNode && nextNode.type === "combinator" && nextNode.value === " " && /\\[A-F0-9]{1,6}$/.test(selector.last.value)) {
                  selector.last.spaces.after = " ";
                }
                node.replaceWith(selector);
                return;
              }
            case "root":
            case "selector": {
              node.each(traverseNode);
              break;
            }
            case "id":
            case "class":
              if (exportGlobals) {
                exports3[node.value] = [node.value];
              }
              break;
          }
          return node;
        }
        const importedNames = {};
        root.walkRules(/^:import\(.+\)$/, (rule2) => {
          rule2.walkDecls((decl) => {
            importedNames[decl.prop] = true;
          });
        });
        root.walkRules((rule2) => {
          let parsedSelector = selectorParser().astSync(rule2);
          rule2.selector = traverseNode(parsedSelector.clone()).toString();
          rule2.walkDecls(/composes|compose-with/i, (decl) => {
            const localNames = getSingleLocalNamesForComposes(parsedSelector);
            const classes = decl.value.split(/\s+/);
            classes.forEach((className) => {
              const global2 = /^global\(([^)]+)\)$/.exec(className);
              if (global2) {
                localNames.forEach((exportedName) => {
                  exports3[exportedName].push(global2[1]);
                });
              } else if (hasOwnProperty.call(importedNames, className)) {
                localNames.forEach((exportedName) => {
                  exports3[exportedName].push(className);
                });
              } else if (hasOwnProperty.call(exports3, className)) {
                localNames.forEach((exportedName) => {
                  exports3[className].forEach((item) => {
                    exports3[exportedName].push(item);
                  });
                });
              } else {
                throw decl.error(`referenced class name "${className}" in ${decl.prop} not found`);
              }
            });
            decl.remove();
          });
          rule2.walkDecls((decl) => {
            if (!/:local\s*\((.+?)\)/.test(decl.value)) {
              return;
            }
            let tokens = decl.value.split(/(,|'[^']*'|"[^"]*")/);
            tokens = tokens.map((token, idx) => {
              if (idx === 0 || tokens[idx - 1] === ",") {
                let result = token;
                const localMatch = /:local\s*\((.+?)\)/.exec(token);
                if (localMatch) {
                  const input = localMatch.input;
                  const matchPattern = localMatch[0];
                  const matchVal = localMatch[1];
                  const newVal = exportScopedName(matchVal);
                  result = input.replace(matchPattern, newVal);
                } else {
                  return token;
                }
                return result;
              } else {
                return token;
              }
            });
            decl.value = tokens.join("");
          });
        });
        root.walkAtRules(/keyframes$/i, (atRule) => {
          const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(atRule.params);
          if (!localMatch) {
            return;
          }
          atRule.params = exportScopedName(localMatch[1]);
        });
        const exportedNames = Object.keys(exports3);
        if (exportedNames.length > 0) {
          const exportRule = rule({selector: ":export"});
          exportedNames.forEach((exportedName) => exportRule.append({
            prop: exportedName,
            value: exports3[exportedName].join(" "),
            raws: {before: "\n  "}
          }));
          root.append(exportRule);
        }
      }
    };
  };
  plugin.postcss = true;
  plugin.generateScopedName = function(name, path4) {
    const sanitisedPath = path4.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "");
    return `_${sanitisedPath}__${name}`.trim();
  };
  plugin.generateExportEntry = function(name, scopedName) {
    return {
      key: unescape2(name),
      value: unescape2(scopedName)
    };
  };
  module2.exports = plugin;
});

// node_modules/postcss-modules-values/src/index.js
var require_src5 = __commonJS((exports2, module2) => {
  "use strict";
  var ICSSUtils = require_src();
  var matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
  var matchValueDefinition = /(?:\s+|^)([\w-]+):?(.*?)$/;
  var matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
  module2.exports = (options) => {
    let importIndex = 0;
    const createImportedName = options && options.createImportedName || ((importName) => `i__const_${importName.replace(/\W/g, "_")}_${importIndex++}`);
    return {
      postcssPlugin: "postcss-modules-values",
      prepare(result) {
        const importAliases = [];
        const definitions = {};
        return {
          Once(root, postcss) {
            root.walkAtRules(/value/i, (atRule) => {
              const matches = atRule.params.match(matchImports);
              if (matches) {
                let [, aliases, path4] = matches;
                if (definitions[path4]) {
                  path4 = definitions[path4];
                }
                const imports = aliases.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((alias) => {
                  const tokens = matchImport.exec(alias);
                  if (tokens) {
                    const [, theirName, myName = theirName] = tokens;
                    const importedName = createImportedName(myName);
                    definitions[myName] = importedName;
                    return {theirName, importedName};
                  } else {
                    throw new Error(`@import statement "${alias}" is invalid!`);
                  }
                });
                importAliases.push({path: path4, imports});
                atRule.remove();
                return;
              }
              if (atRule.params.indexOf("@value") !== -1) {
                result.warn("Invalid value definition: " + atRule.params);
              }
              let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(matchValueDefinition);
              const normalizedValue = value.replace(/\/\*((?!\*\/).*?)\*\//g, "");
              if (normalizedValue.length === 0) {
                result.warn("Invalid value definition: " + atRule.params);
                atRule.remove();
                return;
              }
              let isOnlySpace = /^\s+$/.test(normalizedValue);
              if (!isOnlySpace) {
                value = value.trim();
              }
              definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);
              atRule.remove();
            });
            if (!Object.keys(definitions).length) {
              return;
            }
            ICSSUtils.replaceSymbols(root, definitions);
            const exportDeclarations = Object.keys(definitions).map((key) => postcss.decl({
              value: definitions[key],
              prop: key,
              raws: {before: "\n  "}
            }));
            if (exportDeclarations.length > 0) {
              const exportRule = postcss.rule({
                selector: ":export",
                raws: {after: "\n"}
              });
              exportRule.append(exportDeclarations);
              root.prepend(exportRule);
            }
            importAliases.reverse().forEach(({path: path4, imports}) => {
              const importRule = postcss.rule({
                selector: `:import(${path4})`,
                raws: {after: "\n"}
              });
              imports.forEach(({theirName, importedName}) => {
                importRule.append({
                  value: theirName,
                  prop: importedName,
                  raws: {before: "\n  "}
                });
              });
              root.prepend(importRule);
            });
          }
        };
      }
    };
  };
  module2.exports.postcss = true;
});

// node_modules/postcss-modules/build/behaviours.js
var require_behaviours = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.behaviours = void 0;
  exports2.getDefaultPlugins = getDefaultPlugins;
  exports2.isValidBehaviour = isValidBehaviour;
  var _postcssModulesLocalByDefault = require_src2();
  var _postcssModulesLocalByDefault2 = _interopRequireDefault(_postcssModulesLocalByDefault);
  var _postcssModulesExtractImports = require_src3();
  var _postcssModulesExtractImports2 = _interopRequireDefault(_postcssModulesExtractImports);
  var _postcssModulesScope = require_src4();
  var _postcssModulesScope2 = _interopRequireDefault(_postcssModulesScope);
  var _postcssModulesValues = require_src5();
  var _postcssModulesValues2 = _interopRequireDefault(_postcssModulesValues);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var behaviours = exports2.behaviours = {
    LOCAL: "local",
    GLOBAL: "global"
  };
  function getDefaultPlugins({
    behaviour,
    generateScopedName,
    exportGlobals
  }) {
    const scope = (0, _postcssModulesScope2.default)({generateScopedName, exportGlobals});
    const plugins = {
      [behaviours.LOCAL]: [_postcssModulesValues2.default, _postcssModulesLocalByDefault2.default, _postcssModulesExtractImports2.default, scope],
      [behaviours.GLOBAL]: [_postcssModulesValues2.default, _postcssModulesExtractImports2.default, scope]
    };
    return plugins[behaviour];
  }
  function isValidBehaviour(behaviour) {
    return Object.keys(behaviours).map((key) => behaviours[key]).indexOf(behaviour) > -1;
  }
});

// node_modules/postcss-modules/build/index.js
var require_build = __commonJS((exports2, module2) => {
  "use strict";
  var _postcss = require_postcss();
  var _postcss2 = _interopRequireDefault(_postcss);
  var _lodash = require_lodash();
  var _lodash2 = _interopRequireDefault(_lodash);
  var _genericNames = require_generic_names();
  var _genericNames2 = _interopRequireDefault(_genericNames);
  var _unquote = require_unquote();
  var _unquote2 = _interopRequireDefault(_unquote);
  var _parser = require_parser3();
  var _parser2 = _interopRequireDefault(_parser);
  var _loader = require_loader();
  var _loader2 = _interopRequireDefault(_loader);
  var _generateScopedName = require_generateScopedName();
  var _generateScopedName2 = _interopRequireDefault(_generateScopedName);
  var _saveJSON = require_saveJSON();
  var _saveJSON2 = _interopRequireDefault(_saveJSON);
  var _behaviours = require_behaviours();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _asyncToGenerator(fn) {
    return function() {
      var gen = fn.apply(this, arguments);
      return new Promise(function(resolve, reject) {
        function step(key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }
          if (info.done) {
            resolve(value);
          } else {
            return Promise.resolve(value).then(function(value2) {
              step("next", value2);
            }, function(err) {
              step("throw", err);
            });
          }
        }
        return step("next");
      });
    };
  }
  var PLUGIN_NAME = "postcss-modules";
  function getDefaultScopeBehaviour(opts) {
    if (opts.scopeBehaviour && (0, _behaviours.isValidBehaviour)(opts.scopeBehaviour)) {
      return opts.scopeBehaviour;
    }
    return _behaviours.behaviours.LOCAL;
  }
  function getScopedNameGenerator(opts) {
    const scopedNameGenerator = opts.generateScopedName || _generateScopedName2.default;
    if (typeof scopedNameGenerator === "function")
      return scopedNameGenerator;
    return (0, _genericNames2.default)(scopedNameGenerator, {
      context: process.cwd(),
      hashPrefix: opts.hashPrefix
    });
  }
  function getLoader(opts, plugins) {
    const root = typeof opts.root === "undefined" ? "/" : opts.root;
    return typeof opts.Loader === "function" ? new opts.Loader(root, plugins) : new _loader2.default(root, plugins);
  }
  function isGlobalModule(globalModules, inputFile) {
    return globalModules.some((regex) => inputFile.match(regex));
  }
  function getDefaultPluginsList(opts, inputFile) {
    const globalModulesList = opts.globalModulePaths || null;
    const exportGlobals = opts.exportGlobals || false;
    const defaultBehaviour = getDefaultScopeBehaviour(opts);
    const generateScopedName = getScopedNameGenerator(opts);
    if (globalModulesList && isGlobalModule(globalModulesList, inputFile)) {
      return (0, _behaviours.getDefaultPlugins)({
        behaviour: _behaviours.behaviours.GLOBAL,
        generateScopedName,
        exportGlobals
      });
    }
    return (0, _behaviours.getDefaultPlugins)({
      behaviour: defaultBehaviour,
      generateScopedName,
      exportGlobals
    });
  }
  function isOurPlugin(plugin) {
    return plugin.postcssPlugin === PLUGIN_NAME;
  }
  function dashesCamelCase(string) {
    return string.replace(/-+(\w)/g, (_, firstLetter) => firstLetter.toUpperCase());
  }
  module2.exports = (opts = {}) => {
    return {
      postcssPlugin: PLUGIN_NAME,
      OnceExit(css, {result}) {
        return _asyncToGenerator(function* () {
          const getJSON = opts.getJSON || _saveJSON2.default;
          const inputFile = css.source.input.file;
          const pluginList = getDefaultPluginsList(opts, inputFile);
          const resultPluginIndex = result.processor.plugins.findIndex(function(plugin) {
            return isOurPlugin(plugin);
          });
          if (resultPluginIndex === -1) {
            throw new Error("Plugin missing from options.");
          }
          const earlierPlugins = result.processor.plugins.slice(0, resultPluginIndex);
          const loaderPlugins = [...earlierPlugins, ...pluginList];
          const loader = getLoader(opts, loaderPlugins);
          const fetcher = function fetcher2(file, relativeTo, depTrace) {
            const unquoteFile = (0, _unquote2.default)(file);
            const resolvedResult = typeof opts.resolve === "function" && opts.resolve(unquoteFile);
            const resolvedFile = resolvedResult instanceof Promise ? resolvedResult : Promise.resolve(resolvedResult);
            return resolvedFile.then(function(f) {
              return loader.fetch.call(loader, `"${f || unquoteFile}"`, relativeTo, depTrace);
            });
          };
          const parser = new _parser2.default(fetcher);
          yield (0, _postcss2.default)([...pluginList, parser.plugin()]).process(css, {
            from: inputFile
          });
          const out = loader.finalSource;
          if (out)
            css.prepend(out);
          if (opts.localsConvention) {
            const isFunc = typeof opts.localsConvention === "function";
            parser.exportTokens = Object.entries(parser.exportTokens).reduce(function(tokens, [className, value]) {
              if (isFunc) {
                tokens[opts.localsConvention(className, value, inputFile)] = value;
                return tokens;
              }
              switch (opts.localsConvention) {
                case "camelCase":
                  tokens[className] = value;
                  tokens[(0, _lodash2.default)(className)] = value;
                  break;
                case "camelCaseOnly":
                  tokens[(0, _lodash2.default)(className)] = value;
                  break;
                case "dashes":
                  tokens[className] = value;
                  tokens[dashesCamelCase(className)] = value;
                  break;
                case "dashesOnly":
                  tokens[dashesCamelCase(className)] = value;
                  break;
              }
              return tokens;
            }, {});
          }
          result.messages.push({
            type: "export",
            plugin: "postcss-modules",
            exportTokens: parser.exportTokens
          });
          return getJSON(css.source.input.file, parser.exportTokens, result.opts.to);
        })();
      }
    };
  };
  module2.exports.postcss = true;
});

// node_modules/@vue/compiler-sfc/dist/compiler-sfc.cjs.js
var require_compiler_sfc_cjs = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var CompilerDOM = require_compiler_dom_esm_bundler();
  var sourceMap = require_source_map();
  var hash = require_hash_sum();
  var path4 = require("path");
  var compilerCore = require_compiler_core_esm_bundler();
  var url = require("url");
  var shared4 = require_shared_esm_bundler();
  var CompilerSSR = require_compiler_ssr_cjs();
  var postcss = require_postcss();
  var selectorParser = require_dist();
  var merge = require_merge_source_map();
  var MagicString = require_magic_string_es();
  var parser = require_lib();
  var estreeWalker = require_estree_walker();
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e["default"] : e;
  }
  function _interopNamespace(e) {
    if (e && e.__esModule)
      return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function(k) {
        n[k] = e[k];
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }
  var CompilerDOM__namespace = /* @__PURE__ */ _interopNamespace(CompilerDOM);
  var hash__default = /* @__PURE__ */ _interopDefaultLegacy(hash);
  var path__default = /* @__PURE__ */ _interopDefaultLegacy(path4);
  var CompilerSSR__namespace = /* @__PURE__ */ _interopNamespace(CompilerSSR);
  var postcss__default = /* @__PURE__ */ _interopDefaultLegacy(postcss);
  var selectorParser__default = /* @__PURE__ */ _interopDefaultLegacy(selectorParser);
  var merge__default = /* @__PURE__ */ _interopDefaultLegacy(merge);
  var MagicString__default = /* @__PURE__ */ _interopDefaultLegacy(MagicString);
  var CSS_VARS_HELPER = `useCssVars`;
  var cssVarRE = /\bv-bind\(\s*(?:'([^']+)'|"([^"]+)"|([^'"][^)]*))\s*\)/g;
  function genCssVarsFromList(vars, id, isProd) {
    return `{
  ${vars.map((key) => `"${genVarName(id, key, isProd)}": (${key})`).join(",\n  ")}
}`;
  }
  function genVarName(id, raw, isProd) {
    if (isProd) {
      return hash__default(id + raw);
    } else {
      return `${id}-${raw.replace(/([^\w-])/g, "_")}`;
    }
  }
  function parseCssVars(sfc) {
    const vars = [];
    sfc.styles.forEach((style) => {
      let match;
      const content = style.content.replace(/\/\*([\s\S]*?)\*\//g, "");
      while (match = cssVarRE.exec(content)) {
        const variable = match[1] || match[2] || match[3];
        if (!vars.includes(variable)) {
          vars.push(variable);
        }
      }
    });
    return vars;
  }
  var cssVarsPlugin = (opts) => {
    const {id, isProd} = opts;
    return {
      postcssPlugin: "vue-sfc-vars",
      Declaration(decl) {
        if (cssVarRE.test(decl.value)) {
          decl.value = decl.value.replace(cssVarRE, (_, $1, $2, $3) => {
            return `var(--${genVarName(id, $1 || $2 || $3, isProd)})`;
          });
        }
      }
    };
  };
  cssVarsPlugin.postcss = true;
  function genCssVarsCode(vars, bindings, id, isProd) {
    const varsExp = genCssVarsFromList(vars, id, isProd);
    const exp = CompilerDOM.createSimpleExpression(varsExp, false);
    const context = CompilerDOM.createTransformContext(CompilerDOM.createRoot([]), {
      prefixIdentifiers: true,
      inline: true,
      bindingMetadata: bindings.__isScriptSetup === false ? void 0 : bindings
    });
    const transformed = CompilerDOM.processExpression(exp, context);
    const transformedString = transformed.type === 4 ? transformed.content : transformed.children.map((c) => {
      return typeof c === "string" ? c : c.content;
    }).join("");
    return `_${CSS_VARS_HELPER}(_ctx => (${transformedString}))`;
  }
  function genNormalScriptCssVarsCode(cssVars, bindings, id, isProd) {
    return `
import { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'
const __injectCSSVars__ = () => {
${genCssVarsCode(cssVars, bindings, id, isProd)}}
const __setup__ = __default__.setup
__default__.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
  }
  function createCache(size2 = 500) {
    return new (require_lru_cache())(size2);
  }
  var sourceToSFC = createCache();
  function parse2(source, {sourceMap: sourceMap2 = true, filename = "anonymous.vue", sourceRoot = "", pad = false, ignoreEmpty = true, compiler = CompilerDOM__namespace} = {}) {
    const sourceKey = source + sourceMap2 + filename + sourceRoot + pad + compiler.parse;
    const cache = sourceToSFC.get(sourceKey);
    if (cache) {
      return cache;
    }
    const descriptor = {
      filename,
      source,
      template: null,
      script: null,
      scriptSetup: null,
      styles: [],
      customBlocks: [],
      cssVars: [],
      slotted: false
    };
    const errors = [];
    const ast = compiler.parse(source, {
      isNativeTag: () => true,
      isPreTag: () => true,
      getTextMode: ({tag, props}, parent) => {
        if (!parent && tag !== "template" || tag === "template" && props.some((p) => p.type === 6 && p.name === "lang" && p.value && p.value.content && p.value.content !== "html")) {
          return 2;
        } else {
          return 0;
        }
      },
      onError: (e) => {
        errors.push(e);
      }
    });
    ast.children.forEach((node) => {
      if (node.type !== 1) {
        return;
      }
      if (ignoreEmpty && node.tag !== "template" && isEmpty(node) && !hasSrc(node)) {
        return;
      }
      switch (node.tag) {
        case "template":
          if (!descriptor.template) {
            const templateBlock = descriptor.template = createBlock(node, source, false);
            templateBlock.ast = node;
            if (templateBlock.attrs.functional) {
              const err = new SyntaxError(`<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead.`);
              err.loc = node.props.find((p) => p.name === "functional").loc;
              errors.push(err);
            }
          } else {
            errors.push(createDuplicateBlockError(node));
          }
          break;
        case "script":
          const scriptBlock = createBlock(node, source, pad);
          const isSetup = !!scriptBlock.attrs.setup;
          if (isSetup && !descriptor.scriptSetup) {
            descriptor.scriptSetup = scriptBlock;
            break;
          }
          if (!isSetup && !descriptor.script) {
            descriptor.script = scriptBlock;
            break;
          }
          errors.push(createDuplicateBlockError(node, isSetup));
          break;
        case "style":
          const styleBlock = createBlock(node, source, pad);
          if (styleBlock.attrs.vars) {
            errors.push(new SyntaxError(`<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231`));
          }
          descriptor.styles.push(styleBlock);
          break;
        default:
          descriptor.customBlocks.push(createBlock(node, source, pad));
          break;
      }
    });
    if (descriptor.scriptSetup) {
      if (descriptor.scriptSetup.src) {
        errors.push(new SyntaxError(`<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.`));
        descriptor.scriptSetup = null;
      }
      if (descriptor.script && descriptor.script.src) {
        errors.push(new SyntaxError(`<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.`));
        descriptor.script = null;
      }
    }
    if (sourceMap2) {
      const genMap = (block) => {
        if (block && !block.src) {
          block.map = generateSourceMap(filename, source, block.content, sourceRoot, !pad || block.type === "template" ? block.loc.start.line - 1 : 0);
        }
      };
      genMap(descriptor.template);
      genMap(descriptor.script);
      descriptor.styles.forEach(genMap);
      descriptor.customBlocks.forEach(genMap);
    }
    descriptor.cssVars = parseCssVars(descriptor);
    const slottedRE = /(?:::v-|:)slotted\(/;
    descriptor.slotted = descriptor.styles.some((s) => s.scoped && slottedRE.test(s.content));
    const result = {
      descriptor,
      errors
    };
    sourceToSFC.set(sourceKey, result);
    return result;
  }
  function createDuplicateBlockError(node, isScriptSetup = false) {
    const err = new SyntaxError(`Single file component can contain only one <${node.tag}${isScriptSetup ? ` setup` : ``}> element`);
    err.loc = node.loc;
    return err;
  }
  function createBlock(node, source, pad) {
    const type = node.tag;
    let {start, end} = node.loc;
    let content = "";
    if (node.children.length) {
      start = node.children[0].loc.start;
      end = node.children[node.children.length - 1].loc.end;
      content = source.slice(start.offset, end.offset);
    } else {
      const offset = node.loc.source.indexOf(`</`);
      if (offset > -1) {
        start = {
          line: start.line,
          column: start.column + offset,
          offset: start.offset + offset
        };
      }
      end = Object.assign({}, start);
    }
    const loc = {
      source: content,
      start,
      end
    };
    const attrs = {};
    const block = {
      type,
      content,
      loc,
      attrs
    };
    if (pad) {
      block.content = padContent(source, block, pad) + block.content;
    }
    node.props.forEach((p) => {
      if (p.type === 6) {
        attrs[p.name] = p.value ? p.value.content || true : true;
        if (p.name === "lang") {
          block.lang = p.value && p.value.content;
        } else if (p.name === "src") {
          block.src = p.value && p.value.content;
        } else if (type === "style") {
          if (p.name === "scoped") {
            block.scoped = true;
          } else if (p.name === "module") {
            block.module = attrs[p.name];
          }
        } else if (type === "script" && p.name === "setup") {
          block.setup = attrs.setup;
        }
      }
    });
    return block;
  }
  var splitRE = /\r?\n/g;
  var emptyRE = /^(?:\/\/)?\s*$/;
  var replaceRE = /./g;
  function generateSourceMap(filename, source, generated, sourceRoot, lineOffset) {
    const map = new sourceMap.SourceMapGenerator({
      file: filename.replace(/\\/g, "/"),
      sourceRoot: sourceRoot.replace(/\\/g, "/")
    });
    map.setSourceContent(filename, source);
    generated.split(splitRE).forEach((line, index) => {
      if (!emptyRE.test(line)) {
        const originalLine = index + 1 + lineOffset;
        const generatedLine = index + 1;
        for (let i = 0; i < line.length; i++) {
          if (!/\s/.test(line[i])) {
            map.addMapping({
              source: filename,
              original: {
                line: originalLine,
                column: i
              },
              generated: {
                line: generatedLine,
                column: i
              }
            });
          }
        }
      }
    });
    return JSON.parse(map.toString());
  }
  function padContent(content, block, pad) {
    content = content.slice(0, block.loc.start.offset);
    if (pad === "space") {
      return content.replace(replaceRE, " ");
    } else {
      const offset = content.split(splitRE).length;
      const padChar = block.type === "script" && !block.lang ? "//\n" : "\n";
      return Array(offset).join(padChar);
    }
  }
  function hasSrc(node) {
    return node.props.some((p) => {
      if (p.type !== 6) {
        return false;
      }
      return p.name === "src";
    });
  }
  function isEmpty(node) {
    return node.children.filter((child) => child.type !== 2 || child.content.trim() !== "").length === 0;
  }
  function isRelativeUrl(url2) {
    const firstChar = url2.charAt(0);
    return firstChar === "." || firstChar === "~" || firstChar === "@";
  }
  var externalRE = /^https?:\/\//;
  function isExternalUrl(url2) {
    return externalRE.test(url2);
  }
  var dataUrlRE = /^\s*data:/i;
  function isDataUrl(url2) {
    return dataUrlRE.test(url2);
  }
  function parseUrl(url2) {
    const firstChar = url2.charAt(0);
    if (firstChar === "~") {
      const secondChar = url2.charAt(1);
      url2 = url2.slice(secondChar === "/" ? 2 : 1);
    }
    return parseUriParts(url2);
  }
  function parseUriParts(urlString) {
    return url.parse(shared4.isString(urlString) ? urlString : "", false, true);
  }
  var defaultAssetUrlOptions = {
    base: null,
    includeAbsolute: false,
    tags: {
      video: ["src", "poster"],
      source: ["src"],
      img: ["src"],
      image: ["xlink:href", "href"],
      use: ["xlink:href", "href"]
    }
  };
  var normalizeOptions = (options) => {
    if (Object.keys(options).some((key) => shared4.isArray(options[key]))) {
      return Object.assign(Object.assign({}, defaultAssetUrlOptions), {tags: options});
    }
    return Object.assign(Object.assign({}, defaultAssetUrlOptions), options);
  };
  var createAssetUrlTransformWithOptions = (options) => {
    return (node, context) => transformAssetUrl(node, context, options);
  };
  var transformAssetUrl = (node, context, options = defaultAssetUrlOptions) => {
    if (node.type === 1) {
      if (!node.props.length) {
        return;
      }
      const tags = options.tags || defaultAssetUrlOptions.tags;
      const attrs = tags[node.tag];
      const wildCardAttrs = tags["*"];
      if (!attrs && !wildCardAttrs) {
        return;
      }
      const assetAttrs = (attrs || []).concat(wildCardAttrs || []);
      node.props.forEach((attr, index) => {
        if (attr.type !== 6 || !assetAttrs.includes(attr.name) || !attr.value || isExternalUrl(attr.value.content) || isDataUrl(attr.value.content) || attr.value.content[0] === "#" || !options.includeAbsolute && !isRelativeUrl(attr.value.content)) {
          return;
        }
        const url2 = parseUrl(attr.value.content);
        if (options.base && attr.value.content[0] === ".") {
          const base = parseUrl(options.base);
          const protocol = base.protocol || "";
          const host = base.host ? protocol + "//" + base.host : "";
          const basePath = base.path || "/";
          attr.value.content = host + (path__default.posix || path__default).join(basePath, url2.path + (url2.hash || ""));
          return;
        }
        const exp = getImportsExpressionExp(url2.path, url2.hash, attr.loc, context);
        node.props[index] = {
          type: 7,
          name: "bind",
          arg: compilerCore.createSimpleExpression(attr.name, true, attr.loc),
          exp,
          modifiers: [],
          loc: attr.loc
        };
      });
    }
  };
  function getImportsExpressionExp(path5, hash2, loc, context) {
    if (path5) {
      const existing = context.imports.find((i) => i.path === path5);
      if (existing) {
        return existing.exp;
      }
      const name = `_imports_${context.imports.length}`;
      const exp = compilerCore.createSimpleExpression(name, false, loc, 2);
      context.imports.push({exp, path: path5});
      if (hash2 && path5) {
        return context.hoist(compilerCore.createSimpleExpression(`${name} + '${hash2}'`, false, loc, 2));
      } else {
        return exp;
      }
    } else {
      return compilerCore.createSimpleExpression(`''`, false, loc, 2);
    }
  }
  var srcsetTags = ["img", "source"];
  var escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
  var createSrcsetTransformWithOptions = (options) => {
    return (node, context) => transformSrcset(node, context, options);
  };
  var transformSrcset = (node, context, options = defaultAssetUrlOptions) => {
    if (node.type === 1) {
      if (srcsetTags.includes(node.tag) && node.props.length) {
        node.props.forEach((attr, index) => {
          if (attr.name === "srcset" && attr.type === 6) {
            if (!attr.value)
              return;
            const value = attr.value.content;
            if (!value)
              return;
            const imageCandidates = value.split(",").map((s) => {
              const [url2, descriptor] = s.replace(escapedSpaceCharacters, " ").trim().split(" ", 2);
              return {url: url2, descriptor};
            });
            for (let i = 0; i < imageCandidates.length; i++) {
              const {url: url2} = imageCandidates[i];
              if (isDataUrl(url2)) {
                imageCandidates[i + 1].url = url2 + "," + imageCandidates[i + 1].url;
                imageCandidates.splice(i, 1);
              }
            }
            const hasQualifiedUrl = imageCandidates.some(({url: url2}) => {
              return !isExternalUrl(url2) && !isDataUrl(url2) && (options.includeAbsolute || isRelativeUrl(url2));
            });
            if (!hasQualifiedUrl) {
              return;
            }
            if (options.base) {
              const base = options.base;
              const set2 = [];
              imageCandidates.forEach(({url: url2, descriptor}) => {
                descriptor = descriptor ? ` ${descriptor}` : ``;
                if (isRelativeUrl(url2)) {
                  set2.push((path__default.posix || path__default).join(base, url2) + descriptor);
                } else {
                  set2.push(url2 + descriptor);
                }
              });
              attr.value.content = set2.join(", ");
              return;
            }
            const compoundExpression = compilerCore.createCompoundExpression([], attr.loc);
            imageCandidates.forEach(({url: url2, descriptor}, index2) => {
              if (!isExternalUrl(url2) && !isDataUrl(url2) && (options.includeAbsolute || isRelativeUrl(url2))) {
                const {path: path5} = parseUrl(url2);
                let exp;
                if (path5) {
                  const existingImportsIndex = context.imports.findIndex((i) => i.path === path5);
                  if (existingImportsIndex > -1) {
                    exp = compilerCore.createSimpleExpression(`_imports_${existingImportsIndex}`, false, attr.loc, 2);
                  } else {
                    exp = compilerCore.createSimpleExpression(`_imports_${context.imports.length}`, false, attr.loc, 2);
                    context.imports.push({exp, path: path5});
                  }
                  compoundExpression.children.push(exp);
                }
              } else {
                const exp = compilerCore.createSimpleExpression(`"${url2}"`, false, attr.loc, 2);
                compoundExpression.children.push(exp);
              }
              const isNotLast = imageCandidates.length - 1 > index2;
              if (descriptor && isNotLast) {
                compoundExpression.children.push(` + ' ${descriptor}, ' + `);
              } else if (descriptor) {
                compoundExpression.children.push(` + ' ${descriptor}'`);
              } else if (isNotLast) {
                compoundExpression.children.push(` + ', ' + `);
              }
            });
            const hoisted = context.hoist(compoundExpression);
            hoisted.constType = 2;
            node.props[index] = {
              type: 7,
              name: "bind",
              arg: compilerCore.createSimpleExpression("srcset", true, attr.loc),
              exp: hoisted,
              modifiers: [],
              loc: attr.loc
            };
          }
        });
      }
    }
  };
  var hasWarned = {};
  function warnOnce(msg) {
    const isNodeProd = typeof process !== "undefined" && process.env.NODE_ENV === "production";
    if (!isNodeProd && true && !hasWarned[msg]) {
      hasWarned[msg] = true;
      warn(msg);
    }
  }
  function warn(msg) {
    console.warn(`[1m[33m[@vue/compiler-sfc][0m[33m ${msg}[0m
`);
  }
  function warnExperimental(feature, url2) {
    if (typeof window !== "undefined") {
      return;
    }
    warnOnce(`${feature} is still an experimental proposal.
Follow its status at ${url2}.`);
    warnOnce(`When using experimental features,
it is recommended to pin your vue dependencies to exact versions to avoid breakage.`);
  }
  function preprocess({source, filename, preprocessOptions}, preprocessor) {
    let res = "";
    let err = null;
    preprocessor.render(source, Object.assign({filename}, preprocessOptions), (_err, _res) => {
      if (_err)
        err = _err;
      res = _res;
    });
    if (err)
      throw err;
    return res;
  }
  function compileTemplate(options) {
    const {preprocessLang, preprocessCustomRequire} = options;
    const preprocessor = preprocessLang ? preprocessCustomRequire ? preprocessCustomRequire(preprocessLang) : require("consolidate")[preprocessLang] : false;
    if (preprocessor) {
      try {
        return doCompileTemplate(Object.assign(Object.assign({}, options), {source: preprocess(options, preprocessor)}));
      } catch (e) {
        return {
          code: `export default function render() {}`,
          source: options.source,
          tips: [],
          errors: [e]
        };
      }
    } else if (preprocessLang) {
      return {
        code: `export default function render() {}`,
        source: options.source,
        tips: [
          `Component ${options.filename} uses lang ${preprocessLang} for template. Please install the language preprocessor.`
        ],
        errors: [
          `Component ${options.filename} uses lang ${preprocessLang} for template, however it is not installed.`
        ]
      };
    } else {
      return doCompileTemplate(options);
    }
  }
  function doCompileTemplate({filename, id, scoped, slotted, inMap, source, ssr = false, ssrCssVars, isProd = false, compiler = ssr ? CompilerSSR__namespace : CompilerDOM__namespace, compilerOptions = {}, transformAssetUrls}) {
    const errors = [];
    const warnings = [];
    let nodeTransforms = [];
    if (shared4.isObject(transformAssetUrls)) {
      const assetOptions = normalizeOptions(transformAssetUrls);
      nodeTransforms = [
        createAssetUrlTransformWithOptions(assetOptions),
        createSrcsetTransformWithOptions(assetOptions)
      ];
    } else if (transformAssetUrls !== false) {
      nodeTransforms = [transformAssetUrl, transformSrcset];
    }
    if (ssr && !ssrCssVars) {
      warnOnce(`compileTemplate is called with \`ssr: true\` but no corresponding \`cssVars\` option.\`.`);
    }
    if (!id) {
      warnOnce(`compileTemplate now requires the \`id\` option.\`.`);
      id = "";
    }
    const shortId = id.replace(/^data-v-/, "");
    const longId = `data-v-${shortId}`;
    let {code, ast, preamble, map} = compiler.compile(source, Object.assign(Object.assign({mode: "module", prefixIdentifiers: true, hoistStatic: true, cacheHandlers: true, ssrCssVars: ssr && ssrCssVars && ssrCssVars.length ? genCssVarsFromList(ssrCssVars, shortId, isProd) : "", scopeId: scoped ? longId : void 0, slotted}, compilerOptions), {nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []), filename, sourceMap: true, onError: (e) => errors.push(e), onWarn: (w) => warnings.push(w)}));
    if (inMap) {
      if (map) {
        map = mapLines(inMap, map);
      }
      if (errors.length) {
        patchErrors(errors, source, inMap);
      }
    }
    const tips = warnings.map((w) => {
      let msg = w.message;
      if (w.loc) {
        msg += `
${shared4.generateCodeFrame(source, w.loc.start.offset, w.loc.end.offset)}`;
      }
      return msg;
    });
    return {code, ast, preamble, source, errors, tips, map};
  }
  function mapLines(oldMap, newMap) {
    if (!oldMap)
      return newMap;
    if (!newMap)
      return oldMap;
    const oldMapConsumer = new sourceMap.SourceMapConsumer(oldMap);
    const newMapConsumer = new sourceMap.SourceMapConsumer(newMap);
    const mergedMapGenerator = new sourceMap.SourceMapGenerator();
    newMapConsumer.eachMapping((m) => {
      if (m.originalLine == null) {
        return;
      }
      const origPosInOldMap = oldMapConsumer.originalPositionFor({
        line: m.originalLine,
        column: m.originalColumn
      });
      if (origPosInOldMap.source == null) {
        return;
      }
      mergedMapGenerator.addMapping({
        generated: {
          line: m.generatedLine,
          column: m.generatedColumn
        },
        original: {
          line: origPosInOldMap.line,
          column: m.originalColumn
        },
        source: origPosInOldMap.source,
        name: origPosInOldMap.name
      });
    });
    const generator = mergedMapGenerator;
    oldMapConsumer.sources.forEach((sourceFile) => {
      generator._sources.add(sourceFile);
      const sourceContent = oldMapConsumer.sourceContentFor(sourceFile);
      if (sourceContent != null) {
        mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
      }
    });
    generator._sourceRoot = oldMap.sourceRoot;
    generator._file = oldMap.file;
    return generator.toJSON();
  }
  function patchErrors(errors, source, inMap) {
    const originalSource = inMap.sourcesContent[0];
    const offset = originalSource.indexOf(source);
    const lineOffset = originalSource.slice(0, offset).split(/\r?\n/).length - 1;
    errors.forEach((err) => {
      if (err.loc) {
        err.loc.start.line += lineOffset;
        err.loc.start.offset += offset;
        if (err.loc.end !== err.loc.start) {
          err.loc.end.line += lineOffset;
          err.loc.end.offset += offset;
        }
      }
    });
  }
  var trimPlugin = () => {
    return {
      postcssPlugin: "vue-sfc-trim",
      Once(root) {
        root.walk(({type, raws}) => {
          if (type === "rule" || type === "atrule") {
            if (raws.before)
              raws.before = "\n";
            if ("after" in raws && raws.after)
              raws.after = "\n";
          }
        });
      }
    };
  };
  trimPlugin.postcss = true;
  var animationNameRE = /^(-\w+-)?animation-name$/;
  var animationRE = /^(-\w+-)?animation$/;
  var scopedPlugin = (id = "") => {
    const keyframes = Object.create(null);
    const shortId = id.replace(/^data-v-/, "");
    return {
      postcssPlugin: "vue-sfc-scoped",
      Rule(rule) {
        processRule(id, rule);
      },
      AtRule(node) {
        if (/-?keyframes$/.test(node.name) && !node.params.endsWith(`-${shortId}`)) {
          keyframes[node.params] = node.params = node.params + "-" + shortId;
        }
      },
      OnceExit(root) {
        if (Object.keys(keyframes).length) {
          root.walkDecls((decl) => {
            if (animationNameRE.test(decl.prop)) {
              decl.value = decl.value.split(",").map((v) => keyframes[v.trim()] || v.trim()).join(",");
            }
            if (animationRE.test(decl.prop)) {
              decl.value = decl.value.split(",").map((v) => {
                const vals = v.trim().split(/\s+/);
                const i = vals.findIndex((val) => keyframes[val]);
                if (i !== -1) {
                  vals.splice(i, 1, keyframes[vals[i]]);
                  return vals.join(" ");
                } else {
                  return v;
                }
              }).join(",");
            }
          });
        }
      }
    };
  };
  var processedRules = new WeakSet();
  function processRule(id, rule) {
    if (processedRules.has(rule) || rule.parent && rule.parent.type === "atrule" && /-?keyframes$/.test(rule.parent.name)) {
      return;
    }
    processedRules.add(rule);
    rule.selector = selectorParser__default((selectorRoot) => {
      selectorRoot.each((selector) => {
        rewriteSelector(id, selector, selectorRoot);
      });
    }).processSync(rule.selector);
  }
  function rewriteSelector(id, selector, selectorRoot, slotted = false) {
    let node = null;
    let shouldInject = true;
    selector.each((n) => {
      if (n.type === "combinator" && (n.value === ">>>" || n.value === "/deep/")) {
        n.value = " ";
        n.spaces.before = n.spaces.after = "";
        warn(`the >>> and /deep/ combinators have been deprecated. Use :deep() instead.`);
        return false;
      }
      if (n.type === "pseudo") {
        const {value} = n;
        if (value === ":deep" || value === "::v-deep") {
          if (n.nodes.length) {
            let last = n;
            n.nodes[0].each((ss) => {
              selector.insertAfter(last, ss);
              last = ss;
            });
            const prev = selector.at(selector.index(n) - 1);
            if (!prev || !isSpaceCombinator(prev)) {
              selector.insertAfter(n, selectorParser__default.combinator({
                value: " "
              }));
            }
            selector.removeChild(n);
          } else {
            warn(`::v-deep usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead.`);
            const prev = selector.at(selector.index(n) - 1);
            if (prev && isSpaceCombinator(prev)) {
              selector.removeChild(prev);
            }
            selector.removeChild(n);
          }
          return false;
        }
        if (value === ":slotted" || value === "::v-slotted") {
          rewriteSelector(id, n.nodes[0], selectorRoot, true);
          let last = n;
          n.nodes[0].each((ss) => {
            selector.insertAfter(last, ss);
            last = ss;
          });
          selector.removeChild(n);
          shouldInject = false;
          return false;
        }
        if (value === ":global" || value === "::v-global") {
          selectorRoot.insertAfter(selector, n.nodes[0]);
          selectorRoot.removeChild(selector);
          return false;
        }
      }
      if (n.type !== "pseudo" && n.type !== "combinator") {
        node = n;
      }
    });
    if (node) {
      node.spaces.after = "";
    } else {
      selector.first.spaces.before = "";
    }
    if (shouldInject) {
      const idToAdd = slotted ? id + "-s" : id;
      selector.insertAfter(node, selectorParser__default.attribute({
        attribute: idToAdd,
        value: idToAdd,
        raws: {},
        quoteMark: `"`
      }));
    }
  }
  function isSpaceCombinator(node) {
    return node.type === "combinator" && /^\s+$/.test(node.value);
  }
  scopedPlugin.postcss = true;
  var scss = (source, map, options, load = require) => {
    const nodeSass = load("sass");
    const finalOptions = Object.assign(Object.assign({}, options), {data: getSource(source, options.filename, options.additionalData), file: options.filename, outFile: options.filename, sourceMap: !!map});
    try {
      const result = nodeSass.renderSync(finalOptions);
      const dependencies = result.stats.includedFiles;
      if (map) {
        return {
          code: result.css.toString(),
          map: merge__default(map, JSON.parse(result.map.toString())),
          errors: [],
          dependencies
        };
      }
      return {code: result.css.toString(), errors: [], dependencies};
    } catch (e) {
      return {code: "", errors: [e], dependencies: []};
    }
  };
  var sass = (source, map, options, load) => scss(source, map, Object.assign(Object.assign({}, options), {indentedSyntax: true}), load);
  var less = (source, map, options, load = require) => {
    const nodeLess = load("less");
    let result;
    let error = null;
    nodeLess.render(getSource(source, options.filename, options.additionalData), Object.assign(Object.assign({}, options), {syncImport: true}), (err, output) => {
      error = err;
      result = output;
    });
    if (error)
      return {code: "", errors: [error], dependencies: []};
    const dependencies = result.imports;
    if (map) {
      return {
        code: result.css.toString(),
        map: merge__default(map, result.map),
        errors: [],
        dependencies
      };
    }
    return {
      code: result.css.toString(),
      errors: [],
      dependencies
    };
  };
  var styl = (source, map, options, load = require) => {
    const nodeStylus = load("stylus");
    try {
      const ref2 = nodeStylus(source);
      Object.keys(options).forEach((key) => ref2.set(key, options[key]));
      if (map)
        ref2.set("sourcemap", {inline: false, comment: false});
      const result = ref2.render();
      const dependencies = ref2.deps();
      if (map) {
        return {
          code: result,
          map: merge__default(map, ref2.sourcemap),
          errors: [],
          dependencies
        };
      }
      return {code: result, errors: [], dependencies};
    } catch (e) {
      return {code: "", errors: [e], dependencies: []};
    }
  };
  function getSource(source, filename, additionalData) {
    if (!additionalData)
      return source;
    if (shared4.isFunction(additionalData)) {
      return additionalData(source, filename);
    }
    return additionalData + source;
  }
  var processors = {
    less,
    sass,
    scss,
    styl,
    stylus: styl
  };
  function compileStyle(options) {
    return doCompileStyle(Object.assign(Object.assign({}, options), {isAsync: false}));
  }
  function compileStyleAsync(options) {
    return doCompileStyle(Object.assign(Object.assign({}, options), {isAsync: true}));
  }
  function doCompileStyle(options) {
    const {filename, id, scoped = false, trim = true, isProd = false, modules = false, modulesOptions = {}, preprocessLang, postcssOptions, postcssPlugins} = options;
    const preprocessor = preprocessLang && processors[preprocessLang];
    const preProcessedSource = preprocessor && preprocess$1(options, preprocessor);
    const map = preProcessedSource ? preProcessedSource.map : options.inMap || options.map;
    const source = preProcessedSource ? preProcessedSource.code : options.source;
    const shortId = id.replace(/^data-v-/, "");
    const longId = `data-v-${shortId}`;
    const plugins = (postcssPlugins || []).slice();
    plugins.unshift(cssVarsPlugin({id: shortId, isProd}));
    if (trim) {
      plugins.push(trimPlugin());
    }
    if (scoped) {
      plugins.push(scopedPlugin(longId));
    }
    let cssModules;
    if (modules) {
      if (!options.isAsync) {
        throw new Error("[@vue/compiler-sfc] `modules` option can only be used with compileStyleAsync().");
      }
      plugins.push(require_build()(Object.assign(Object.assign({}, modulesOptions), {getJSON: (_cssFileName, json) => {
        cssModules = json;
      }})));
    }
    const postCSSOptions = Object.assign(Object.assign({}, postcssOptions), {to: filename, from: filename});
    if (map) {
      postCSSOptions.map = {
        inline: false,
        annotation: false,
        prev: map
      };
    }
    let result;
    let code;
    let outMap;
    const dependencies = new Set(preProcessedSource ? preProcessedSource.dependencies : []);
    dependencies.delete(filename);
    const errors = [];
    if (preProcessedSource && preProcessedSource.errors.length) {
      errors.push(...preProcessedSource.errors);
    }
    const recordPlainCssDependencies = (messages) => {
      messages.forEach((msg) => {
        if (msg.type === "dependency") {
          dependencies.add(msg.file);
        }
      });
      return dependencies;
    };
    try {
      result = postcss__default(plugins).process(source, postCSSOptions);
      if (options.isAsync) {
        return result.then((result2) => ({
          code: result2.css || "",
          map: result2.map && result2.map.toJSON(),
          errors,
          modules: cssModules,
          rawResult: result2,
          dependencies: recordPlainCssDependencies(result2.messages)
        })).catch((error) => ({
          code: "",
          map: void 0,
          errors: [...errors, error],
          rawResult: void 0,
          dependencies
        }));
      }
      recordPlainCssDependencies(result.messages);
      code = result.css;
      outMap = result.map;
    } catch (e) {
      errors.push(e);
    }
    return {
      code: code || ``,
      map: outMap && outMap.toJSON(),
      errors,
      rawResult: result,
      dependencies
    };
  }
  function preprocess$1(options, preprocessor) {
    return preprocessor(options.source, options.inMap || options.map, Object.assign({filename: options.filename}, options.preprocessOptions), options.preprocessCustomRequire);
  }
  var defaultExportRE = /((?:^|\n|;)\s*)export(\s*)default/;
  var namedDefaultExportRE = /((?:^|\n|;)\s*)export(.+)as(\s*)default/s;
  var exportDefaultClassRE = /((?:^|\n|;)\s*)export\s+default\s+class\s+([\w$]+)/;
  function rewriteDefault(input, as, parserPlugins) {
    if (!hasDefaultExport(input)) {
      return input + `
const ${as} = {}`;
    }
    let replaced;
    const classMatch = input.match(exportDefaultClassRE);
    if (classMatch) {
      replaced = input.replace(exportDefaultClassRE, "$1class $2") + `
const ${as} = ${classMatch[2]}`;
    } else {
      replaced = input.replace(defaultExportRE, `$1const ${as} =`);
    }
    if (!hasDefaultExport(replaced)) {
      return replaced;
    }
    const s = new MagicString__default(input);
    const ast = parser.parse(input, {
      sourceType: "module",
      plugins: parserPlugins
    }).program.body;
    ast.forEach((node) => {
      if (node.type === "ExportDefaultDeclaration") {
        s.overwrite(node.start, node.declaration.start, `const ${as} = `);
      }
      if (node.type === "ExportNamedDeclaration") {
        node.specifiers.forEach((specifier) => {
          if (specifier.type === "ExportSpecifier" && specifier.exported.type === "Identifier" && specifier.exported.name === "default") {
            const end = specifier.end;
            s.overwrite(specifier.start, input.charAt(end) === "," ? end + 1 : end, ``);
            s.append(`
const ${as} = ${specifier.local.name}`);
          }
        });
      }
    });
    return s.toString();
  }
  function hasDefaultExport(input) {
    return defaultExportRE.test(input) || namedDefaultExportRE.test(input);
  }
  var DEFINE_PROPS = "defineProps";
  var DEFINE_EMITS = "defineEmits";
  var DEFINE_EXPOSE = "defineExpose";
  var WITH_DEFAULTS = "withDefaults";
  var $REF = `$ref`;
  var $SHALLOW_REF = "$shallowRef";
  var $COMPUTED = `$computed`;
  var $FROM_REFS = `$fromRefs`;
  var $RAW = `$raw`;
  var isBuiltInDir = shared4.makeMap(`once,memo,if,else,else-if,slot,text,html,on,bind,model,show,cloak,is`);
  function compileScript(sfc, options) {
    let {script, scriptSetup, source, filename} = sfc;
    const enableRefSugar = !!options.refSugar;
    const parseOnly = !!options.parseOnly;
    if (parseOnly && !scriptSetup) {
      scriptSetup = {
        type: "script",
        content: "",
        attrs: {},
        loc: CompilerDOM.locStub
      };
    }
    if (!options) {
      options = {id: ""};
    }
    if (!options.id) {
      warnOnce(`compileScript now requires passing the \`id\` option.
Upgrade your vite or vue-loader version for compatibility with the latest experimental proposals.`);
    }
    const scopeId = options.id ? options.id.replace(/^data-v-/, "") : "";
    const cssVars = sfc.cssVars;
    const scriptLang = script && script.lang;
    const scriptSetupLang = scriptSetup && scriptSetup.lang;
    const isTS = scriptLang === "ts" || scriptLang === "tsx" || scriptSetupLang === "ts" || scriptSetupLang === "tsx";
    const plugins = [...shared4.babelParserDefaultPlugins];
    if (!isTS || scriptLang === "tsx" || scriptSetupLang === "tsx") {
      plugins.push("jsx");
    }
    if (options.babelParserPlugins)
      plugins.push(...options.babelParserPlugins);
    if (isTS)
      plugins.push("typescript", "decorators-legacy");
    if (!scriptSetup) {
      if (!script) {
        throw new Error(`[@vue/compiler-sfc] SFC contains no <script> tags.`);
      }
      if (scriptLang && !isTS && scriptLang !== "jsx") {
        return script;
      }
      try {
        const scriptAst2 = parser.parse(script.content, {
          plugins,
          sourceType: "module",
          errorRecovery: parseOnly
        }).program.body;
        const bindings = analyzeScriptBindings(scriptAst2);
        let content = script.content;
        if (cssVars.length) {
          content = rewriteDefault(content, `__default__`, plugins);
          content += genNormalScriptCssVarsCode(cssVars, bindings, scopeId, !!options.isProd);
          content += `
export default __default__`;
        }
        return Object.assign(Object.assign({}, script), {
          content,
          bindings,
          scriptAst: scriptAst2
        });
      } catch (e) {
        return script;
      }
    }
    if (script && scriptLang !== scriptSetupLang) {
      throw new Error(`[@vue/compiler-sfc] <script> and <script setup> must have the same language type.`);
    }
    if (scriptSetupLang && !isTS && scriptSetupLang !== "jsx") {
      return scriptSetup;
    }
    const bindingMetadata = {};
    const ranges = parseOnly ? {
      scriptBindings: [],
      scriptSetupBindings: []
    } : void 0;
    const defaultTempVar = `__default__`;
    const helperImports = new Set();
    const userImports = Object.create(null);
    const userImportAlias = Object.create(null);
    const setupBindings = Object.create(null);
    const refBindings = Object.create(null);
    const refIdentifiers = new Set();
    let defaultExport;
    let hasDefinePropsCall = false;
    let hasDefineEmitCall = false;
    let hasDefineExposeCall = false;
    let propsRuntimeDecl;
    let propsRuntimeDefaults;
    let propsTypeDecl;
    let propsTypeDeclRaw;
    let propsIdentifier;
    let emitsRuntimeDecl;
    let emitsTypeDecl;
    let emitsTypeDeclRaw;
    let emitIdentifier;
    let hasAwait = false;
    let hasInlinedSsrRenderFn = false;
    const typeDeclaredProps = {};
    const typeDeclaredEmits = new Set();
    const declaredTypes = {};
    const s = new MagicString__default(source);
    const startOffset = scriptSetup.loc.start.offset;
    const endOffset = scriptSetup.loc.end.offset;
    const scriptStartOffset = script && script.loc.start.offset;
    const scriptEndOffset = script && script.loc.end.offset;
    function helper(key) {
      helperImports.add(key);
      return `_${key}`;
    }
    function parse3(input, options2, offset) {
      try {
        options2.errorRecovery = parseOnly;
        return parser.parse(input, options2).program.body;
      } catch (e) {
        e.message = `[@vue/compiler-sfc] ${e.message}

${sfc.filename}
${shared4.generateCodeFrame(source, e.pos + offset, e.pos + offset + 1)}`;
        throw e;
      }
    }
    function error(msg, node, end = node.end + startOffset) {
      throw new Error(`[@vue/compiler-sfc] ${msg}

${sfc.filename}
${shared4.generateCodeFrame(source, node.start + startOffset, end)}`);
    }
    function registerUserImport(source2, local, imported, isType, isFromSetup, rangeNode) {
      if (source2 === "vue" && imported) {
        userImportAlias[imported] = local;
      }
      let isUsedInTemplate = true;
      if (isTS && sfc.template && !sfc.template.src && !sfc.template.lang) {
        isUsedInTemplate = new RegExp(`[^\\w$_]${local.replace(/\$/g, "\\$")}[^\\w$_]`).test(resolveTemplateUsageCheckString(sfc));
      }
      userImports[local] = {
        isType,
        imported: imported || "default",
        source: source2,
        rangeNode,
        isFromSetup,
        isUsedInTemplate
      };
    }
    function processDefineProps(node) {
      if (!isCallOf(node, DEFINE_PROPS)) {
        return false;
      }
      if (hasDefinePropsCall) {
        error(`duplicate ${DEFINE_PROPS}() call`, node);
      }
      hasDefinePropsCall = true;
      propsRuntimeDecl = node.arguments[0];
      if (node.typeParameters) {
        if (propsRuntimeDecl) {
          error(`${DEFINE_PROPS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node);
        }
        propsTypeDeclRaw = node.typeParameters.params[0];
        propsTypeDecl = resolveQualifiedType(propsTypeDeclRaw, (node2) => node2.type === "TSTypeLiteral");
        if (!propsTypeDecl) {
          error(`type argument passed to ${DEFINE_PROPS}() must be a literal type, or a reference to an interface or literal type.`, propsTypeDeclRaw);
        }
      }
      return true;
    }
    function processWithDefaults(node) {
      if (!isCallOf(node, WITH_DEFAULTS)) {
        return false;
      }
      if (processDefineProps(node.arguments[0])) {
        if (propsRuntimeDecl) {
          error(`${WITH_DEFAULTS} can only be used with type-based ${DEFINE_PROPS} declaration.`, node);
        }
        propsRuntimeDefaults = node.arguments[1];
      } else {
        error(`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`, node.arguments[0] || node);
      }
      return true;
    }
    function processDefineEmits(node) {
      if (!isCallOf(node, DEFINE_EMITS)) {
        return false;
      }
      if (hasDefineEmitCall) {
        error(`duplicate ${DEFINE_EMITS}() call`, node);
      }
      hasDefineEmitCall = true;
      emitsRuntimeDecl = node.arguments[0];
      if (node.typeParameters) {
        if (emitsRuntimeDecl) {
          error(`${DEFINE_EMITS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node);
        }
        emitsTypeDeclRaw = node.typeParameters.params[0];
        emitsTypeDecl = resolveQualifiedType(emitsTypeDeclRaw, (node2) => node2.type === "TSFunctionType" || node2.type === "TSTypeLiteral");
        if (!emitsTypeDecl) {
          error(`type argument passed to ${DEFINE_EMITS}() must be a function type, a literal type with call signatures, or a reference to the above types.`, emitsTypeDeclRaw);
        }
      }
      return true;
    }
    function resolveQualifiedType(node, qualifier) {
      if (qualifier(node)) {
        return node;
      }
      if (node.type === "TSTypeReference" && node.typeName.type === "Identifier") {
        const refName = node.typeName.name;
        const isQualifiedType = (node2) => {
          if (node2.type === "TSInterfaceDeclaration" && node2.id.name === refName) {
            return node2.body;
          } else if (node2.type === "TSTypeAliasDeclaration" && node2.id.name === refName && qualifier(node2.typeAnnotation)) {
            return node2.typeAnnotation;
          } else if (node2.type === "ExportNamedDeclaration" && node2.declaration) {
            return isQualifiedType(node2.declaration);
          }
        };
        for (const node2 of scriptSetupAst) {
          const qualified = isQualifiedType(node2);
          if (qualified) {
            return qualified;
          }
        }
      }
    }
    function processDefineExpose(node) {
      if (isCallOf(node, DEFINE_EXPOSE)) {
        if (hasDefineExposeCall) {
          error(`duplicate ${DEFINE_EXPOSE}() call`, node);
        }
        hasDefineExposeCall = true;
        return true;
      }
      return false;
    }
    function checkInvalidScopeReference(node, method) {
      if (!node)
        return;
      walkIdentifiers(node, (id) => {
        if (setupBindings[id.name]) {
          error(`\`${method}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options requires initialization in the module scope, use a separate normal <script> to export the options instead.`, id);
        }
      });
    }
    function processAwait(node, isStatement) {
      s.overwrite(node.start + startOffset, node.argument.start + startOffset, `${isStatement ? `;` : ``}(([__temp,__restore]=${helper(`withAsyncContext`)}(()=>(`);
      s.appendLeft(node.end + startOffset, `))),__temp=await __temp,__restore()${isStatement ? `` : `,__temp`})`);
    }
    function isRefSugarCall(callee) {
      return callee === $REF || callee === $COMPUTED || callee === $FROM_REFS || callee === $SHALLOW_REF;
    }
    function processRefSugar(decl, statement) {
      if (!isCallOf(decl.init, isRefSugarCall)) {
        return;
      }
      if (!enableRefSugar) {
        error(`ref sugar is an experimental proposal and must be explicitly enabled via @vue/compiler-sfc options.`, decl.init);
      } else {
        warnExperimental(`ref sugar`, `https://github.com/vuejs/rfcs/discussions/369`);
      }
      const callee = decl.init.callee.name;
      const start = decl.init.start + startOffset;
      if (callee === $REF || callee === $SHALLOW_REF) {
        if (statement.kind !== "let") {
          error(`${callee}() bindings can only be declared with let.`, decl);
        }
        if (decl.id.type !== "Identifier") {
          error(`${callee}() bindings cannot be used with destructuring. If you are trying to destructure from an object of refs, use \`let { x } = $fromRefs(obj)\`.`, decl.id);
        }
        registerRefBinding(decl.id);
        s.overwrite(start, start + callee.length, helper(callee === $REF ? "ref" : "shallowRef"));
      } else if (callee === $COMPUTED) {
        if (decl.id.type !== "Identifier") {
          error(`${callee}() bindings cannot be used with destructuring.`, decl.id);
        }
        registerRefBinding(decl.id);
        s.overwrite(start, start + $COMPUTED.length, helper("computed"));
      } else if (callee === $FROM_REFS) {
        if (!decl.id.type.endsWith("Pattern")) {
          error(`${callee}() declaration must be used with destructure patterns.`, decl);
        }
        if (decl.id.type === "ObjectPattern") {
          processRefObjectPattern(decl.id, statement);
        } else if (decl.id.type === "ArrayPattern") {
          processRefArrayPattern(decl.id, statement);
        }
        s.remove(start, start + callee.length);
      }
    }
    function registerRefBinding(id) {
      if (id.name[0] === "$") {
        error(`ref variable identifiers cannot start with $.`, id);
      }
      refBindings[id.name] = setupBindings[id.name] = {
        type: "setup-ref",
        rangeNode: id
      };
      refIdentifiers.add(id);
    }
    function processRefObjectPattern(pattern, statement) {
      for (const p of pattern.properties) {
        let nameId;
        if (p.type === "ObjectProperty") {
          if (p.key.start === p.value.start) {
            nameId = p.key;
            s.appendLeft(nameId.end + startOffset, `: __${nameId.name}`);
            if (p.value.type === "AssignmentPattern") {
              refIdentifiers.add(p.value.left);
            }
          } else {
            if (p.value.type === "Identifier") {
              nameId = p.value;
              s.prependRight(nameId.start + startOffset, `__`);
            } else if (p.value.type === "ObjectPattern") {
              processRefObjectPattern(p.value, statement);
            } else if (p.value.type === "ArrayPattern") {
              processRefArrayPattern(p.value, statement);
            } else if (p.value.type === "AssignmentPattern") {
              nameId = p.value.left;
              s.prependRight(nameId.start + startOffset, `__`);
            }
          }
        } else {
          nameId = p.argument;
          s.prependRight(nameId.start + startOffset, `__`);
        }
        if (nameId) {
          registerRefBinding(nameId);
          s.appendLeft(statement.end + startOffset, `
const ${nameId.name} = ${helper("shallowRef")}(__${nameId.name});`);
        }
      }
    }
    function processRefArrayPattern(pattern, statement) {
      for (const e of pattern.elements) {
        if (!e)
          continue;
        let nameId;
        if (e.type === "Identifier") {
          nameId = e;
        } else if (e.type === "AssignmentPattern") {
          nameId = e.left;
        } else if (e.type === "RestElement") {
          nameId = e.argument;
        } else if (e.type === "ObjectPattern") {
          processRefObjectPattern(e, statement);
        } else if (e.type === "ArrayPattern") {
          processRefArrayPattern(e, statement);
        }
        if (nameId) {
          registerRefBinding(nameId);
          s.prependRight(nameId.start + startOffset, `__`);
          s.appendLeft(statement.end + startOffset, `
const ${nameId.name} = ${helper("shallowRef")}(__${nameId.name});`);
        }
      }
    }
    function genRuntimeProps(props) {
      const keys = Object.keys(props);
      if (!keys.length) {
        return ``;
      }
      const hasStaticDefaults = propsRuntimeDefaults && propsRuntimeDefaults.type === "ObjectExpression" && propsRuntimeDefaults.properties.every((node) => node.type === "ObjectProperty" && !node.computed);
      let propsDecls = `{
    ${keys.map((key) => {
        let defaultString;
        if (hasStaticDefaults) {
          const prop = propsRuntimeDefaults.properties.find((node) => node.key.name === key);
          if (prop) {
            defaultString = `default: ${source.slice(prop.value.start + startOffset, prop.value.end + startOffset)}`;
          }
        }
        {
          const {type, required} = props[key];
          return `${key}: { type: ${toRuntimeTypeString(type)}, required: ${required}${defaultString ? `, ${defaultString}` : ``} }`;
        }
      }).join(",\n    ")}
  }`;
      if (propsRuntimeDefaults && !hasStaticDefaults) {
        propsDecls = `${helper("mergeDefaults")}(${propsDecls}, ${source.slice(propsRuntimeDefaults.start + startOffset, propsRuntimeDefaults.end + startOffset)})`;
      }
      return `
  props: ${propsDecls} as unknown as undefined,`;
    }
    let scriptAst;
    if (script) {
      scriptAst = parse3(script.content, {
        plugins,
        sourceType: "module"
      }, scriptStartOffset);
      for (const node of scriptAst) {
        if (node.type === "ImportDeclaration") {
          for (const specifier of node.specifiers) {
            const imported = specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier" && specifier.imported.name;
            registerUserImport(node.source.value, specifier.local.name, imported, node.importKind === "type", false, specifier.local);
          }
        } else if (node.type === "ExportDefaultDeclaration") {
          defaultExport = node;
          const start = node.start + scriptStartOffset;
          s.overwrite(start, start + `export default`.length, `const ${defaultTempVar} =`);
        } else if (node.type === "ExportNamedDeclaration" && node.specifiers) {
          const defaultSpecifier = node.specifiers.find((s2) => s2.exported.type === "Identifier" && s2.exported.name === "default");
          if (defaultSpecifier) {
            defaultExport = node;
            if (node.specifiers.length > 1) {
              s.remove(defaultSpecifier.start + scriptStartOffset, defaultSpecifier.end + scriptStartOffset);
            } else {
              s.remove(node.start + scriptStartOffset, node.end + scriptStartOffset);
            }
            if (node.source) {
              s.prepend(`import { ${defaultSpecifier.local.name} as ${defaultTempVar} } from '${node.source.value}'
`);
            } else {
              s.append(`
const ${defaultTempVar} = ${defaultSpecifier.local.name}
`);
            }
          }
        }
      }
    }
    const scriptSetupAst = parse3(scriptSetup.content, {
      plugins: [
        ...plugins,
        "topLevelAwait"
      ],
      sourceType: "module"
    }, startOffset);
    for (const node of scriptSetupAst) {
      const start = node.start + startOffset;
      let end = node.end + startOffset;
      if (node.trailingComments && node.trailingComments.length > 0) {
        const lastCommentNode = node.trailingComments[node.trailingComments.length - 1];
        end = lastCommentNode.end + startOffset;
      }
      while (end <= source.length) {
        if (!/\s/.test(source.charAt(end))) {
          break;
        }
        end++;
      }
      if (node.type === "LabeledStatement" && node.label.name === "ref" && node.body.type === "ExpressionStatement") {
        error(`ref sugar using the label syntax was an experimental proposal and has been dropped based on community feedback.`, node);
      }
      if (node.type === "ImportDeclaration") {
        s.move(start, end, 0);
        let removed = 0;
        const removeSpecifier = (i) => {
          const removeLeft = i > removed;
          removed++;
          const current = node.specifiers[i];
          const next = node.specifiers[i + 1];
          s.remove(removeLeft ? node.specifiers[i - 1].end + startOffset : current.start + startOffset, next && !removeLeft ? next.start + startOffset : current.end + startOffset);
        };
        for (let i = 0; i < node.specifiers.length; i++) {
          const specifier = node.specifiers[i];
          const local = specifier.local.name;
          const imported = specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier" && specifier.imported.name;
          const source2 = node.source.value;
          const existing = userImports[local];
          if (source2 === "vue" && (imported === DEFINE_PROPS || imported === DEFINE_EMITS || imported === DEFINE_EXPOSE)) {
            warnOnce(`\`${imported}\` is a compiler macro and no longer needs to be imported.`);
            removeSpecifier(i);
          } else if (existing) {
            if (existing.source === source2 && existing.imported === imported) {
              removeSpecifier(i);
            } else {
              error(`different imports aliased to same local name.`, specifier);
            }
          } else {
            registerUserImport(source2, local, imported, node.importKind === "type", true, specifier.local);
          }
        }
        if (node.specifiers.length && removed === node.specifiers.length) {
          s.remove(node.start + startOffset, node.end + startOffset);
        }
      }
      if (node.type === "ExpressionStatement") {
        if (processDefineProps(node.expression) || processDefineEmits(node.expression) || processWithDefaults(node.expression)) {
          s.remove(node.start + startOffset, node.end + startOffset);
        } else if (processDefineExpose(node.expression)) {
          const callee = node.expression.callee;
          s.overwrite(callee.start + startOffset, callee.end + startOffset, "expose");
        }
      }
      if (node.type === "VariableDeclaration" && !node.declare) {
        const total = node.declarations.length;
        let left = total;
        for (let i = 0; i < total; i++) {
          const decl = node.declarations[i];
          if (decl.init) {
            const isDefineProps = processDefineProps(decl.init) || processWithDefaults(decl.init);
            if (isDefineProps) {
              propsIdentifier = scriptSetup.content.slice(decl.id.start, decl.id.end);
            }
            const isDefineEmits = processDefineEmits(decl.init);
            if (isDefineEmits) {
              emitIdentifier = scriptSetup.content.slice(decl.id.start, decl.id.end);
            }
            if (isDefineProps || isDefineEmits) {
              if (left === 1) {
                s.remove(node.start + startOffset, node.end + startOffset);
              } else {
                let start2 = decl.start + startOffset;
                let end2 = decl.end + startOffset;
                if (i < total - 1) {
                  end2 = node.declarations[i + 1].start + startOffset;
                } else {
                  start2 = node.declarations[i - 1].end + startOffset;
                }
                s.remove(start2, end2);
                left--;
              }
            } else {
              processRefSugar(decl, node);
            }
          }
        }
      }
      if ((node.type === "VariableDeclaration" || node.type === "FunctionDeclaration" || node.type === "ClassDeclaration") && !node.declare) {
        walkDeclaration(node, setupBindings, userImportAlias);
      }
      if (node.type === "VariableDeclaration" && !node.declare || node.type.endsWith("Statement")) {
        estreeWalker.walk(node, {
          enter(child, parent) {
            if (isFunction2(child)) {
              this.skip();
            }
            if (child.type === "AwaitExpression") {
              hasAwait = true;
              processAwait(child, parent.type === "ExpressionStatement");
            }
          }
        });
      }
      if (node.type === "ExportNamedDeclaration" && node.exportKind !== "type" || node.type === "ExportAllDeclaration" || node.type === "ExportDefaultDeclaration") {
        error(`<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`, node);
      }
      if (isTS) {
        if (node.type === "TSEnumDeclaration") {
          registerBinding(setupBindings, node.id, "setup-const");
        }
        if (node.type.startsWith("TS") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "VariableDeclaration" && node.declare) {
          recordType(node, declaredTypes);
          s.move(start, end, 0);
        }
      }
    }
    if (parseOnly) {
      for (const key in userImports) {
        const {rangeNode, isFromSetup} = userImports[key];
        const bindings = isFromSetup ? ranges.scriptSetupBindings : ranges.scriptBindings;
        bindings.push(toTextRange(rangeNode));
      }
      for (const key in setupBindings) {
        ranges.scriptSetupBindings.push(toTextRange(setupBindings[key].rangeNode));
      }
      if (propsRuntimeDecl) {
        ranges.propsRuntimeArg = toTextRange(propsRuntimeDecl);
      }
      if (propsTypeDeclRaw) {
        ranges.propsTypeArg = toTextRange(propsTypeDeclRaw);
      }
      if (emitsRuntimeDecl) {
        ranges.emitsRuntimeArg = toTextRange(emitsRuntimeDecl);
      }
      if (emitsTypeDeclRaw) {
        ranges.emitsTypeArg = toTextRange(emitsTypeDeclRaw);
      }
      if (propsRuntimeDefaults) {
        ranges.withDefaultsArg = toTextRange(propsRuntimeDefaults);
      }
      return Object.assign(Object.assign({}, scriptSetup), {
        ranges,
        scriptAst,
        scriptSetupAst
      });
    }
    if (enableRefSugar) {
      const onIdent = (id, parent, parentStack) => {
        if (refBindings[id.name] && !refIdentifiers.has(id)) {
          if (isStaticProperty(parent) && parent.shorthand) {
            if (!parent.inPattern || isInDestructureAssignment(parent, parentStack)) {
              s.appendLeft(id.end + startOffset, `: ${id.name}.value`);
            }
          } else {
            s.appendLeft(id.end + startOffset, ".value");
          }
        }
      };
      const onNode = (node, parent) => {
        if (isCallOf(node, $RAW)) {
          s.remove(node.callee.start + startOffset, node.callee.end + startOffset);
          return false;
        } else if (parent && isCallOf(node, isRefSugarCall) && (parent.type !== "VariableDeclarator" || node !== parent.init)) {
          error(`${node.callee.name} can only be used directly as a variable initializer.`, node);
        }
      };
      for (const node of scriptSetupAst) {
        if (node.type !== "ImportDeclaration") {
          walkIdentifiers(node, onIdent, onNode);
        }
      }
    }
    if (propsTypeDecl) {
      extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes);
    }
    if (emitsTypeDecl) {
      extractRuntimeEmits(emitsTypeDecl, typeDeclaredEmits);
    }
    checkInvalidScopeReference(propsRuntimeDecl, DEFINE_PROPS);
    checkInvalidScopeReference(propsRuntimeDefaults, DEFINE_PROPS);
    checkInvalidScopeReference(emitsRuntimeDecl, DEFINE_PROPS);
    if (script) {
      if (startOffset < scriptStartOffset) {
        s.remove(0, startOffset);
        s.remove(endOffset, scriptStartOffset);
        s.remove(scriptEndOffset, source.length);
      } else {
        s.remove(0, scriptStartOffset);
        s.remove(scriptEndOffset, startOffset);
        s.remove(endOffset, source.length);
      }
    } else {
      s.remove(0, startOffset);
      s.remove(endOffset, source.length);
    }
    if (scriptAst) {
      Object.assign(bindingMetadata, analyzeScriptBindings(scriptAst));
    }
    if (propsRuntimeDecl) {
      for (const key of getObjectOrArrayExpressionKeys(propsRuntimeDecl)) {
        bindingMetadata[key] = "props";
      }
    }
    for (const key in typeDeclaredProps) {
      bindingMetadata[key] = "props";
    }
    for (const [key, {isType, imported, source: source2}] of Object.entries(userImports)) {
      if (isType)
        continue;
      bindingMetadata[key] = imported === "default" && source2.endsWith(".vue") || source2 === "vue" ? "setup-const" : "setup-maybe-ref";
    }
    for (const key in setupBindings) {
      bindingMetadata[key] = setupBindings[key].type;
    }
    for (const key in refBindings) {
      bindingMetadata[key] = "setup-ref";
    }
    if (cssVars.length) {
      helperImports.add(CSS_VARS_HELPER);
      helperImports.add("unref");
      s.prependRight(startOffset, `
${genCssVarsCode(cssVars, bindingMetadata, scopeId, !!options.isProd)}
`);
    }
    let args = `__props`;
    if (propsTypeDecl) {
      args += `: ${scriptSetup.content.slice(propsTypeDecl.start, propsTypeDecl.end)}`;
    }
    if (propsIdentifier) {
      s.prependRight(startOffset, `
const ${propsIdentifier} = __props`);
    }
    if (hasAwait) {
      const any = isTS ? `:any` : ``;
      s.prependRight(startOffset, `
let __temp${any}, __restore${any}
`);
    }
    const destructureElements = hasDefineExposeCall || !options.inlineTemplate ? [`expose`] : [];
    if (emitIdentifier) {
      destructureElements.push(emitIdentifier === `emit` ? `emit` : `emit: ${emitIdentifier}`);
    }
    if (destructureElements.length) {
      args += `, { ${destructureElements.join(", ")} }`;
      if (emitsTypeDecl) {
        args += `: { emit: (${scriptSetup.content.slice(emitsTypeDecl.start, emitsTypeDecl.end)}), expose: any, slots: any, attrs: any }`;
      }
    }
    let returned;
    if (options.inlineTemplate) {
      if (sfc.template && !sfc.template.src) {
        if (options.templateOptions && options.templateOptions.ssr) {
          hasInlinedSsrRenderFn = true;
        }
        const {code, ast, preamble, tips, errors} = compileTemplate(Object.assign(Object.assign({filename, source: sfc.template.content, inMap: sfc.template.map}, options.templateOptions), {id: scopeId, scoped: sfc.styles.some((s2) => s2.scoped), isProd: options.isProd, ssrCssVars: sfc.cssVars, compilerOptions: Object.assign(Object.assign({}, options.templateOptions && options.templateOptions.compilerOptions), {
          inline: true,
          isTS,
          bindingMetadata
        })}));
        if (tips.length) {
          tips.forEach(warnOnce);
        }
        const err = errors[0];
        if (typeof err === "string") {
          throw new Error(err);
        } else if (err) {
          if (err.loc) {
            err.message += `

` + sfc.filename + "\n" + shared4.generateCodeFrame(source, err.loc.start.offset, err.loc.end.offset) + `
`;
          }
          throw err;
        }
        if (preamble) {
          s.prepend(preamble);
        }
        if (ast && ast.helpers.includes(CompilerDOM.UNREF)) {
          helperImports.delete("unref");
        }
        returned = code;
      } else {
        returned = `() => {}`;
      }
    } else {
      const allBindings = Object.assign({}, setupBindings);
      for (const key in userImports) {
        if (!userImports[key].isType && userImports[key].isUsedInTemplate) {
          allBindings[key] = true;
        }
      }
      returned = `{ ${Object.keys(allBindings).join(", ")} }`;
    }
    if (!options.inlineTemplate && true) {
      s.appendRight(endOffset, `
const __returned__ = ${returned}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`);
    } else {
      s.appendRight(endOffset, `
return ${returned}
}

`);
    }
    let runtimeOptions = ``;
    if (hasInlinedSsrRenderFn) {
      runtimeOptions += `
  __ssrInlineRender: true,`;
    }
    if (propsRuntimeDecl) {
      runtimeOptions += `
  props: ${scriptSetup.content.slice(propsRuntimeDecl.start, propsRuntimeDecl.end).trim()},`;
    } else if (propsTypeDecl) {
      runtimeOptions += genRuntimeProps(typeDeclaredProps);
    }
    if (emitsRuntimeDecl) {
      runtimeOptions += `
  emits: ${scriptSetup.content.slice(emitsRuntimeDecl.start, emitsRuntimeDecl.end).trim()},`;
    } else if (emitsTypeDecl) {
      runtimeOptions += genRuntimeEmits(typeDeclaredEmits);
    }
    const exposeCall = hasDefineExposeCall || options.inlineTemplate ? `` : `  expose()
`;
    if (isTS) {
      const def2 = defaultExport ? `
  ...${defaultTempVar},` : ``;
      s.prependLeft(startOffset, `
export default ${helper(`defineComponent`)}({${def2}${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`);
      s.appendRight(endOffset, `})`);
    } else {
      if (defaultExport) {
        s.prependLeft(startOffset, `
${hasAwait ? `async ` : ``}function setup(${args}) {
`);
        s.append(`
export default /*#__PURE__*/ Object.assign(${defaultTempVar}, {${runtimeOptions}
  setup
})
`);
      } else {
        s.prependLeft(startOffset, `
export default {${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`);
        s.appendRight(endOffset, `}`);
      }
    }
    if (helperImports.size > 0) {
      s.prepend(`import { ${[...helperImports].map((h) => `${h} as _${h}`).join(", ")} } from 'vue'
`);
    }
    s.trim();
    return Object.assign(Object.assign({}, scriptSetup), {
      bindings: bindingMetadata,
      content: s.toString(),
      map: s.generateMap({
        source: filename,
        hires: true,
        includeContent: true
      }),
      scriptAst,
      scriptSetupAst
    });
  }
  function registerBinding(bindings, node, type) {
    bindings[node.name] = {
      type,
      rangeNode: node
    };
  }
  function walkDeclaration(node, bindings, userImportAlias) {
    if (node.type === "VariableDeclaration") {
      const isConst = node.kind === "const";
      for (const {id, init} of node.declarations) {
        const isDefineCall = !!(isConst && isCallOf(init, (c) => c === DEFINE_PROPS || c === DEFINE_EMITS || c === WITH_DEFAULTS));
        if (id.type === "Identifier") {
          let bindingType;
          const userReactiveBinding = userImportAlias["reactive"] || "reactive";
          if (isCallOf(init, userReactiveBinding)) {
            bindingType = "setup-let";
          } else if (isDefineCall || isConst && canNeverBeRef(init, userReactiveBinding)) {
            bindingType = "setup-const";
          } else if (isConst) {
            if (isCallOf(init, userImportAlias["ref"] || "ref")) {
              bindingType = "setup-ref";
            } else {
              bindingType = "setup-maybe-ref";
            }
          } else {
            bindingType = "setup-let";
          }
          registerBinding(bindings, id, bindingType);
        } else if (id.type === "ObjectPattern") {
          walkObjectPattern(id, bindings, isConst, isDefineCall);
        } else if (id.type === "ArrayPattern") {
          walkArrayPattern(id, bindings, isConst, isDefineCall);
        }
      }
    } else if (node.type === "FunctionDeclaration" || node.type === "ClassDeclaration") {
      bindings[node.id.name] = {
        type: "setup-const",
        rangeNode: node.id
      };
    }
  }
  function walkObjectPattern(node, bindings, isConst, isDefineCall = false) {
    for (const p of node.properties) {
      if (p.type === "ObjectProperty") {
        if (p.key.type === "Identifier") {
          if (p.key === p.value) {
            const type = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
            registerBinding(bindings, p.key, type);
          } else {
            walkPattern(p.value, bindings, isConst, isDefineCall);
          }
        }
      } else {
        const type = isConst ? "setup-const" : "setup-let";
        registerBinding(bindings, p.argument, type);
      }
    }
  }
  function walkArrayPattern(node, bindings, isConst, isDefineCall = false) {
    for (const e of node.elements) {
      e && walkPattern(e, bindings, isConst, isDefineCall);
    }
  }
  function walkPattern(node, bindings, isConst, isDefineCall = false) {
    if (node.type === "Identifier") {
      const type = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
      registerBinding(bindings, node, type);
    } else if (node.type === "RestElement") {
      const type = isConst ? "setup-const" : "setup-let";
      registerBinding(bindings, node.argument, type);
    } else if (node.type === "ObjectPattern") {
      walkObjectPattern(node, bindings, isConst);
    } else if (node.type === "ArrayPattern") {
      walkArrayPattern(node, bindings, isConst);
    } else if (node.type === "AssignmentPattern") {
      if (node.left.type === "Identifier") {
        const type = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
        registerBinding(bindings, node.left, type);
      } else {
        walkPattern(node.left, bindings, isConst);
      }
    }
  }
  function recordType(node, declaredTypes) {
    if (node.type === "TSInterfaceDeclaration") {
      declaredTypes[node.id.name] = [`Object`];
    } else if (node.type === "TSTypeAliasDeclaration") {
      declaredTypes[node.id.name] = inferRuntimeType(node.typeAnnotation, declaredTypes);
    } else if (node.type === "ExportNamedDeclaration" && node.declaration) {
      recordType(node.declaration, declaredTypes);
    }
  }
  function extractRuntimeProps(node, props, declaredTypes) {
    const members = node.type === "TSTypeLiteral" ? node.members : node.body;
    for (const m of members) {
      if ((m.type === "TSPropertySignature" || m.type === "TSMethodSignature") && m.key.type === "Identifier") {
        let type;
        {
          if (m.type === "TSMethodSignature") {
            type = ["Function"];
          } else if (m.typeAnnotation) {
            type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes);
          }
        }
        props[m.key.name] = {
          key: m.key.name,
          required: !m.optional,
          type: type || [`null`]
        };
      }
    }
  }
  function inferRuntimeType(node, declaredTypes) {
    switch (node.type) {
      case "TSStringKeyword":
        return ["String"];
      case "TSNumberKeyword":
        return ["Number"];
      case "TSBooleanKeyword":
        return ["Boolean"];
      case "TSObjectKeyword":
        return ["Object"];
      case "TSTypeLiteral":
        return ["Object"];
      case "TSFunctionType":
        return ["Function"];
      case "TSArrayType":
      case "TSTupleType":
        return ["Array"];
      case "TSLiteralType":
        switch (node.literal.type) {
          case "StringLiteral":
            return ["String"];
          case "BooleanLiteral":
            return ["Boolean"];
          case "NumericLiteral":
          case "BigIntLiteral":
            return ["Number"];
          default:
            return [`null`];
        }
      case "TSTypeReference":
        if (node.typeName.type === "Identifier") {
          if (declaredTypes[node.typeName.name]) {
            return declaredTypes[node.typeName.name];
          }
          switch (node.typeName.name) {
            case "Array":
            case "Function":
            case "Object":
            case "Set":
            case "Map":
            case "WeakSet":
            case "WeakMap":
              return [node.typeName.name];
            case "Record":
            case "Partial":
            case "Readonly":
            case "Pick":
            case "Omit":
            case "Exclude":
            case "Extract":
            case "Required":
            case "InstanceType":
              return ["Object"];
          }
        }
        return [`null`];
      case "TSParenthesizedType":
        return inferRuntimeType(node.typeAnnotation, declaredTypes);
      case "TSUnionType":
        return [
          ...new Set([].concat(...node.types.map((t) => inferRuntimeType(t, declaredTypes))))
        ];
      case "TSIntersectionType":
        return ["Object"];
      default:
        return [`null`];
    }
  }
  function toRuntimeTypeString(types) {
    return types.length > 1 ? `[${types.join(", ")}]` : types[0];
  }
  function extractRuntimeEmits(node, emits) {
    if (node.type === "TSTypeLiteral" || node.type === "TSInterfaceBody") {
      const members = node.type === "TSTypeLiteral" ? node.members : node.body;
      for (let t of members) {
        if (t.type === "TSCallSignatureDeclaration") {
          extractEventNames(t.parameters[0], emits);
        }
      }
      return;
    } else {
      extractEventNames(node.parameters[0], emits);
    }
  }
  function extractEventNames(eventName, emits) {
    if (eventName.type === "Identifier" && eventName.typeAnnotation && eventName.typeAnnotation.type === "TSTypeAnnotation") {
      const typeNode = eventName.typeAnnotation.typeAnnotation;
      if (typeNode.type === "TSLiteralType") {
        emits.add(String(typeNode.literal.value));
      } else if (typeNode.type === "TSUnionType") {
        for (const t of typeNode.types) {
          if (t.type === "TSLiteralType") {
            emits.add(String(t.literal.value));
          }
        }
      }
    }
  }
  function genRuntimeEmits(emits) {
    return emits.size ? `
  emits: [${Array.from(emits).map((p) => JSON.stringify(p)).join(", ")}] as unknown as undefined,` : ``;
  }
  function markScopeIdentifier(node, child, knownIds) {
    const {name} = child;
    if (node.scopeIds && node.scopeIds.has(name)) {
      return;
    }
    if (name in knownIds) {
      knownIds[name]++;
    } else {
      knownIds[name] = 1;
    }
    (node.scopeIds || (node.scopeIds = new Set())).add(name);
  }
  function walkIdentifiers(root, onIdentifier, onNode) {
    const parentStack = [];
    const knownIds = Object.create(null);
    estreeWalker.walk(root, {
      enter(node, parent) {
        parent && parentStack.push(parent);
        if (parent && parent.type.startsWith("TS") && parent.type !== "TSAsExpression" && parent.type !== "TSNonNullExpression" && parent.type !== "TSTypeAssertion") {
          return this.skip();
        }
        if (onNode && onNode(node, parent, parentStack) === false) {
          return this.skip();
        }
        if (node.type === "Identifier") {
          if (!knownIds[node.name] && isRefIdentifier(node, parent, parentStack)) {
            onIdentifier(node, parent, parentStack);
          }
        } else if (isFunction2(node)) {
          if (node.body.type === "BlockStatement") {
            node.body.body.forEach((p) => {
              if (p.type === "VariableDeclaration") {
                for (const decl of p.declarations) {
                  extractIdentifiers(decl.id).forEach((id) => {
                    markScopeIdentifier(node, id, knownIds);
                  });
                }
              }
            });
          }
          node.params.forEach((p) => estreeWalker.walk(p, {
            enter(child, parent2) {
              if (child.type === "Identifier" && !isStaticPropertyKey(child, parent2) && !(parent2 && parent2.type === "AssignmentPattern" && parent2.right === child)) {
                markScopeIdentifier(node, child, knownIds);
              }
            }
          }));
        } else if (node.type === "ObjectProperty" && parent.type === "ObjectPattern") {
          node.inPattern = true;
        }
      },
      leave(node, parent) {
        parent && parentStack.pop();
        if (node.scopeIds) {
          node.scopeIds.forEach((id) => {
            knownIds[id]--;
            if (knownIds[id] === 0) {
              delete knownIds[id];
            }
          });
        }
      }
    });
  }
  function isRefIdentifier(id, parent, parentStack) {
    if (!parent) {
      return true;
    }
    if ((parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) {
      return false;
    }
    if (isFunction2(parent)) {
      if (parent.id === id) {
        return false;
      }
      if (parent.params.includes(id)) {
        return false;
      }
    }
    if (isStaticPropertyKey(id, parent)) {
      return false;
    }
    if (parent.type === "ArrayPattern" && !isInDestructureAssignment(parent, parentStack)) {
      return false;
    }
    if ((parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression") && parent.property === id && !parent.computed) {
      return false;
    }
    if (id.name === "arguments") {
      return false;
    }
    return true;
  }
  var isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
  var isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
  function isFunction2(node) {
    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
  }
  function isCallOf(node, test) {
    return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
  }
  function canNeverBeRef(node, userReactiveImport) {
    if (isCallOf(node, userReactiveImport)) {
      return true;
    }
    switch (node.type) {
      case "UnaryExpression":
      case "BinaryExpression":
      case "ArrayExpression":
      case "ObjectExpression":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
      case "UpdateExpression":
      case "ClassExpression":
      case "TaggedTemplateExpression":
        return true;
      case "SequenceExpression":
        return canNeverBeRef(node.expressions[node.expressions.length - 1], userReactiveImport);
      default:
        if (node.type.endsWith("Literal")) {
          return true;
        }
        return false;
    }
  }
  function isInDestructureAssignment(parent, parentStack) {
    if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
      let i = parentStack.length;
      while (i--) {
        const p = parentStack[i];
        if (p.type === "AssignmentExpression") {
          const root = parentStack[0];
          return !(root.type === "LabeledStatement" && root.label.name === "ref");
        } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
          break;
        }
      }
    }
    return false;
  }
  function analyzeScriptBindings(ast) {
    for (const node of ast) {
      if (node.type === "ExportDefaultDeclaration" && node.declaration.type === "ObjectExpression") {
        return analyzeBindingsFromOptions(node.declaration);
      }
    }
    return {};
  }
  function analyzeBindingsFromOptions(node) {
    const bindings = {};
    Object.defineProperty(bindings, "__isScriptSetup", {
      enumerable: false,
      value: false
    });
    for (const property of node.properties) {
      if (property.type === "ObjectProperty" && !property.computed && property.key.type === "Identifier") {
        if (property.key.name === "props") {
          for (const key of getObjectOrArrayExpressionKeys(property.value)) {
            bindings[key] = "props";
          }
        } else if (property.key.name === "inject") {
          for (const key of getObjectOrArrayExpressionKeys(property.value)) {
            bindings[key] = "options";
          }
        } else if (property.value.type === "ObjectExpression" && (property.key.name === "computed" || property.key.name === "methods")) {
          for (const key of getObjectExpressionKeys(property.value)) {
            bindings[key] = "options";
          }
        }
      } else if (property.type === "ObjectMethod" && property.key.type === "Identifier" && (property.key.name === "setup" || property.key.name === "data")) {
        for (const bodyItem of property.body.body) {
          if (bodyItem.type === "ReturnStatement" && bodyItem.argument && bodyItem.argument.type === "ObjectExpression") {
            for (const key of getObjectExpressionKeys(bodyItem.argument)) {
              bindings[key] = property.key.name === "setup" ? "setup-maybe-ref" : "data";
            }
          }
        }
      }
    }
    return bindings;
  }
  function getObjectExpressionKeys(node) {
    const keys = [];
    for (const prop of node.properties) {
      if ((prop.type === "ObjectProperty" || prop.type === "ObjectMethod") && !prop.computed) {
        if (prop.key.type === "Identifier") {
          keys.push(prop.key.name);
        } else if (prop.key.type === "StringLiteral") {
          keys.push(prop.key.value);
        }
      }
    }
    return keys;
  }
  function getArrayExpressionKeys(node) {
    const keys = [];
    for (const element of node.elements) {
      if (element && element.type === "StringLiteral") {
        keys.push(element.value);
      }
    }
    return keys;
  }
  function getObjectOrArrayExpressionKeys(value) {
    if (value.type === "ArrayExpression") {
      return getArrayExpressionKeys(value);
    }
    if (value.type === "ObjectExpression") {
      return getObjectExpressionKeys(value);
    }
    return [];
  }
  function extractIdentifiers(param, nodes = []) {
    switch (param.type) {
      case "Identifier":
        nodes.push(param);
        break;
      case "MemberExpression":
        let object = param;
        while (object.type === "MemberExpression") {
          object = object.object;
        }
        nodes.push(object);
        break;
      case "ObjectPattern":
        param.properties.forEach((prop) => {
          if (prop.type === "RestElement") {
            extractIdentifiers(prop.argument, nodes);
          } else {
            extractIdentifiers(prop.value, nodes);
          }
        });
        break;
      case "ArrayPattern":
        param.elements.forEach((element) => {
          if (element)
            extractIdentifiers(element, nodes);
        });
        break;
      case "RestElement":
        extractIdentifiers(param.argument, nodes);
        break;
      case "AssignmentPattern":
        extractIdentifiers(param.left, nodes);
        break;
    }
    return nodes;
  }
  function toTextRange(node) {
    return {
      start: node.start,
      end: node.end
    };
  }
  var templateUsageCheckCache = createCache();
  function resolveTemplateUsageCheckString(sfc) {
    const {content, ast} = sfc.template;
    const cached = templateUsageCheckCache.get(content);
    if (cached) {
      return cached;
    }
    let code = "";
    CompilerDOM.transform(CompilerDOM.createRoot([ast]), {
      nodeTransforms: [
        (node) => {
          if (node.type === 1) {
            if (!CompilerDOM.parserOptions.isNativeTag(node.tag) && !CompilerDOM.parserOptions.isBuiltInComponent(node.tag)) {
              code += `,${shared4.camelize(node.tag)},${shared4.capitalize(shared4.camelize(node.tag))}`;
            }
            for (let i = 0; i < node.props.length; i++) {
              const prop = node.props[i];
              if (prop.type === 7) {
                if (!isBuiltInDir(prop.name)) {
                  code += `,v${shared4.capitalize(shared4.camelize(prop.name))}`;
                }
                if (prop.exp) {
                  code += `,${stripStrings(prop.exp.content)}`;
                }
              }
            }
          } else if (node.type === 5) {
            code += `,${stripStrings(node.content.content)}`;
          }
        }
      ]
    });
    code += ";";
    templateUsageCheckCache.set(content, code);
    return code;
  }
  function stripStrings(exp) {
    return exp.replace(/'[^']+'|"[^"]+"/g, "").replace(/`[^`]+`/g, stripTemplateString);
  }
  function stripTemplateString(str) {
    const interpMatch = str.match(/\${[^}]+}/g);
    if (interpMatch) {
      return interpMatch.map((m) => m.slice(2, -1)).join(",");
    }
    return "";
  }
  exports2.generateCodeFrame = compilerCore.generateCodeFrame;
  exports2.MagicString = MagicString__default;
  exports2.babelParse = parser.parse;
  exports2.walk = estreeWalker.walk;
  exports2.compileScript = compileScript;
  exports2.compileStyle = compileStyle;
  exports2.compileStyleAsync = compileStyleAsync;
  exports2.compileTemplate = compileTemplate;
  exports2.parse = parse2;
  exports2.rewriteDefault = rewriteDefault;
  exports2.walkIdentifiers = walkIdentifiers;
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  activate: () => activate9,
  deactivate: () => deactivate
});
var import_coc11 = __toModule(require("coc.nvim"));
var path3 = __toModule(require("path"));
var fs3 = __toModule(require("fs"));

// src/features/documentVersion.ts
var import_coc = __toModule(require("coc.nvim"));

// src/requestTypes.ts
var coc = __toModule(require("coc.nvim"));
var shared = __toModule(require_out());
var ShowReferencesNotificationType = new coc.NotificationType(shared.ShowReferencesNotification.type.method);
var GetDocumentVersionRequestType = new coc.RequestType(shared.GetDocumentVersionRequest.type.method);
var GetDocumentPrintWidthRequestType = new coc.RequestType(shared.GetDocumentPrintWidthRequest.type.method);
var GetTagCloseEditsRequestType = new coc.RequestType(shared.GetTagCloseEditsRequest.type.method);
var GetRefCompleteEditsRequestType = new coc.RequestType(shared.GetRefCompleteEditsRequest.type.method);
var VerifyAllScriptsNotificationType = new coc.NotificationType0(shared.VerifyAllScriptsNotification.type.method);

// src/features/documentVersion.ts
async function activate(context, languageClient) {
  await languageClient.onReady();
  languageClient.onRequest(GetDocumentVersionRequestType, (handler) => {
    const doc = import_coc.workspace.textDocuments.find((doc2) => doc2.uri.toString() === handler.uri);
    return doc == null ? void 0 : doc.version;
  });
}

// src/features/documentPrintWidth.ts
var import_coc2 = __toModule(require("coc.nvim"));
async function activate2(context, languageClient) {
  await languageClient.onReady();
  languageClient.onRequest(GetDocumentPrintWidthRequestType, (handler) => {
    const configs = import_coc2.workspace.getConfiguration("volar");
    return configs.get("formatting.printWidth");
  });
}

// src/features/showReferences.ts
var import_coc3 = __toModule(require("coc.nvim"));
async function activate3(context, languageClient) {
  await languageClient.onReady();
  languageClient.onNotification(ShowReferencesNotificationType, (handler) => {
    const uri = handler.textDocument.uri;
    const pos = handler.position;
    const refs = handler.references;
    import_coc3.commands.executeCommand("editor.action.showReferences", import_coc3.Uri.parse(uri), import_coc3.Position.create(pos.line, pos.character), refs.map((ref2) => import_coc3.Location.create(ref2.uri, import_coc3.Range.create(ref2.range.start.line, ref2.range.start.character, ref2.range.end.line, ref2.range.end.character))));
  });
}

// src/features/tagClosing.ts
var coc2 = __toModule(require("coc.nvim"));
var import_coc4 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol = __toModule(require_main4());
async function activate4(context, htmlClient2) {
  await htmlClient2.onReady();
  context.subscriptions.push(activateTagClosing((document2, position) => {
    const param = {
      textDocument: {uri: document2.uri},
      position
    };
    return htmlClient2.sendRequest(GetTagCloseEditsRequestType.method, param);
  }, {vue: true}, "volar.autoClosingTags"));
}
function activateTagClosing(tagProvider, supportedLanguages, configName) {
  let disposables = [];
  import_coc4.workspace.onDidChangeTextDocument((event) => {
    const editor = import_coc4.workspace.getDocument(event.textDocument.uri);
    if (editor) {
      onDidChangeTextDocument(editor.textDocument, event.contentChanges);
    }
  }, null, disposables);
  let isEnabled = false;
  updateEnabledState();
  disposables.push(import_coc4.workspace.registerAutocmd({
    event: ["BufEnter"],
    request: false,
    callback: updateEnabledState
  }));
  let timeout = void 0;
  async function updateEnabledState() {
    isEnabled = false;
    const doc = await import_coc4.workspace.document;
    if (!doc) {
      return;
    }
    const document2 = doc.textDocument;
    if (!supportedLanguages[document2.languageId]) {
      return;
    }
    if (!import_coc4.workspace.getConfiguration(void 0, document2.uri).get(configName)) {
      return;
    }
    isEnabled = true;
  }
  async function onDidChangeTextDocument(document2, changes) {
    if (!isEnabled) {
      return;
    }
    const doc = await import_coc4.workspace.document;
    if (!doc) {
      return;
    }
    const activeDocument = doc.textDocument;
    if (document2.uri !== activeDocument.uri || changes.length === 0) {
      return;
    }
    if (typeof timeout !== "undefined") {
      clearTimeout(timeout);
    }
    const lastChange = changes[changes.length - 1];
    if (!import_vscode_languageserver_protocol.Range.is(lastChange["range"]) || !lastChange.text) {
      return;
    }
    const lastCharacter = lastChange.text[lastChange.text.length - 1];
    if (lastCharacter !== ">" && lastCharacter !== "/") {
      return;
    }
    if (lastCharacter === void 0) {
      return;
    }
    if (lastChange.text.indexOf("\n") >= 0) {
      return;
    }
    const rangeStart = "range" in lastChange ? lastChange.range.start : coc2.Position.create(0, document2.getText().length);
    const version = document2.version;
    timeout = setTimeout(async () => {
      const position = import_vscode_languageserver_protocol.Position.create(rangeStart.line, rangeStart.character + lastChange.text.length);
      await tagProvider(document2, position).then(async (text) => {
        if (text && isEnabled) {
          const doc2 = await import_coc4.workspace.document;
          if (!doc2) {
            return;
          }
          const activeDocument2 = doc2.textDocument;
          if (document2.uri === activeDocument2.uri && activeDocument2.version === version) {
            if (text.startsWith("$")) {
              import_coc4.snippetManager.insertSnippet(text, false, import_vscode_languageserver_protocol.Range.create(position, position)).catch(() => {
              });
            }
          }
        }
      });
      timeout = void 0;
    }, 100);
  }
  return coc2.Disposable.create(() => {
    disposables.forEach((disposable) => {
      disposable.dispose();
    });
    disposables = [];
  });
}

// src/features/refComplete.ts
var coc3 = __toModule(require("coc.nvim"));
var import_coc5 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol2 = __toModule(require_main4());
async function activate5(context, tsClient) {
  await tsClient.onReady();
  context.subscriptions.push(activateTagClosing2((document2, position) => {
    const param = {
      textDocument: {uri: document2.uri},
      position
    };
    return tsClient.sendRequest(GetRefCompleteEditsRequestType.method, param);
  }, {
    vue: true,
    javascript: true,
    typescript: true,
    javascriptreact: true,
    typescriptreact: true
  }, "volar.autoCompleteRefs"));
}
function activateTagClosing2(tagProvider, supportedLanguages, configName) {
  let disposables = [];
  import_coc5.workspace.onDidChangeTextDocument((event) => {
    const editor = import_coc5.workspace.getDocument(event.textDocument.uri);
    if (editor) {
      onDidChangeTextDocument(editor.textDocument, event.contentChanges);
    }
  }, null, disposables);
  let isEnabled = false;
  updateEnabledState();
  disposables.push(import_coc5.workspace.registerAutocmd({
    event: ["BufEnter"],
    request: false,
    callback: updateEnabledState
  }));
  let timeout = void 0;
  async function updateEnabledState() {
    isEnabled = false;
    const doc = await import_coc5.workspace.document;
    if (!doc) {
      return;
    }
    const document2 = doc.textDocument;
    if (!supportedLanguages[document2.languageId]) {
      return;
    }
    if (!import_coc5.workspace.getConfiguration(void 0, document2.uri).get(configName)) {
      return;
    }
    isEnabled = true;
  }
  async function onDidChangeTextDocument(document2, changes) {
    if (!isEnabled) {
      return;
    }
    const doc = await import_coc5.workspace.document;
    if (!doc) {
      return;
    }
    const activeDocument = doc.textDocument;
    if (document2.uri !== activeDocument.uri || changes.length === 0) {
      return;
    }
    if (typeof timeout !== "undefined") {
      clearTimeout(timeout);
    }
    const lastChange = changes[changes.length - 1];
    if (!import_vscode_languageserver_protocol2.Range.is(lastChange["range"]) || !lastChange.text) {
      return;
    }
    const lastCharacter = lastChange.text[lastChange.text.length - 1];
    if (lastCharacter === void 0) {
      return;
    }
    if (lastChange.text.indexOf("\n") >= 0) {
      return;
    }
    const rangeStart = "range" in lastChange ? lastChange.range.start : coc3.Position.create(0, document2.getText().length);
    const version = document2.version;
    timeout = setTimeout(async () => {
      const position = import_vscode_languageserver_protocol2.Position.create(rangeStart.line, rangeStart.character + lastChange.text.length);
      await tagProvider(document2, position).then(async (text) => {
        if (text && isEnabled) {
          const doc2 = await import_coc5.workspace.document;
          if (!doc2) {
            return;
          }
          const activeDocument2 = doc2.textDocument;
          if (document2.uri === activeDocument2.uri && activeDocument2.version === version) {
            import_coc5.snippetManager.insertSnippet(text, true, import_vscode_languageserver_protocol2.Range.create(position, position)).catch(() => {
            });
          }
        }
      });
      timeout = void 0;
    }, 100);
  }
  return coc3.Disposable.create(() => {
    disposables.forEach((disposable) => {
      disposable.dispose();
    });
    disposables = [];
  });
}

// src/features/splitEditors.ts
var import_coc6 = __toModule(require("coc.nvim"));

// node_modules/sourcemap-codec/dist/sourcemap-codec.es.js
var charToInteger = {};
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
for (var i = 0; i < chars.length; i++) {
  charToInteger[chars.charCodeAt(i)] = i;
}
function encode(decoded) {
  var sourceFileIndex = 0;
  var sourceCodeLine = 0;
  var sourceCodeColumn = 0;
  var nameIndex = 0;
  var mappings = "";
  for (var i = 0; i < decoded.length; i++) {
    var line = decoded[i];
    if (i > 0)
      mappings += ";";
    if (line.length === 0)
      continue;
    var generatedCodeColumn = 0;
    var lineMappings = [];
    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
      var segment = line_1[_i];
      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
      generatedCodeColumn = segment[0];
      if (segment.length > 1) {
        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
        sourceFileIndex = segment[1];
        sourceCodeLine = segment[2];
        sourceCodeColumn = segment[3];
      }
      if (segment.length === 5) {
        segmentMappings += encodeInteger(segment[4] - nameIndex);
        nameIndex = segment[4];
      }
      lineMappings.push(segmentMappings);
    }
    mappings += lineMappings.join(",");
  }
  return mappings;
}
function encodeInteger(num) {
  var result = "";
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    var clamped = num & 31;
    num >>>= 5;
    if (num > 0) {
      clamped |= 32;
    }
    result += chars[clamped];
  } while (num > 0);
  return result;
}

// src/features/splitEditors.ts
var import_compiler_sfc = __toModule(require_compiler_sfc_cjs());

// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var import_shared = require_shared_esm_bundler();
var activeEffectScope;
function recordEffectScope(effect, scope) {
  scope = scope || activeEffectScope;
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
var createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
var newTracked = (dep) => (dep.n & trackOpBit) > 0;
var initDepMarkers = ({deps}) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
var finalizeDepMarkers = (effect) => {
  const {deps} = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
var targetMap = new WeakMap();
var effectTrackDepth = 0;
var trackOpBit = 1;
var maxMarkerBits = 30;
var effectStack = [];
var activeEffect;
var ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
var MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
var ReactiveEffect = class {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    if (!effectStack.includes(this)) {
      try {
        effectStack.push(activeEffect = this);
        enableTracking();
        trackOpBit = 1 << ++effectTrackDepth;
        if (effectTrackDepth <= maxMarkerBits) {
          initDepMarkers(this);
        } else {
          cleanupEffect(this);
        }
        return this.fn();
      } finally {
        if (effectTrackDepth <= maxMarkerBits) {
          finalizeDepMarkers(this);
        }
        trackOpBit = 1 << --effectTrackDepth;
        resetTracking();
        effectStack.pop();
        const n = effectStack.length;
        activeEffect = n > 0 ? effectStack[n - 1] : void 0;
      }
    }
  }
  stop() {
    if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
};
function cleanupEffect(effect) {
  const {deps} = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (!isTracking()) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, depsMap = new Map());
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, dep = createDep());
  }
  const eventInfo = process.env.NODE_ENV !== "production" ? {effect: activeEffect, target, type, key} : void 0;
  trackEffects(dep, eventInfo);
}
function isTracking() {
  return shouldTrack && activeEffect !== void 0;
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (process.env.NODE_ENV !== "production" && activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({
        effect: activeEffect
      }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && (0, import_shared.isArray)(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!(0, import_shared.isArray)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if ((0, import_shared.isMap)(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if ((0, import_shared.isIntegerKey)(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!(0, import_shared.isArray)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if ((0, import_shared.isMap)(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if ((0, import_shared.isMap)(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = process.env.NODE_ENV !== "production" ? {target, type, key, newValue, oldValue, oldTarget} : void 0;
  if (deps.length === 1) {
    if (deps[0]) {
      if (process.env.NODE_ENV !== "production") {
        triggerEffects(deps[0], eventInfo);
      } else {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    if (process.env.NODE_ENV !== "production") {
      triggerEffects(createDep(effects), eventInfo);
    } else {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect of (0, import_shared.isArray)(dep) ? dep : [...dep]) {
    if (effect !== activeEffect || effect.allowRecurse) {
      if (process.env.NODE_ENV !== "production" && effect.onTrigger) {
        effect.onTrigger((0, import_shared.extend)({effect}, debuggerEventExtraInfo));
      }
      if (effect.scheduler) {
        effect.scheduler();
      } else {
        effect.run();
      }
    }
  }
}
var isNonTrackableKeys = /* @__PURE__ */ (0, import_shared.makeMap)(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(import_shared.isSymbol));
var get = /* @__PURE__ */ createGetter();
var readonlyGet = /* @__PURE__ */ createGetter(true);
var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = (0, import_shared.isArray)(target);
    if (!isReadonly && targetIsArray && (0, import_shared.hasOwn)(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if ((0, import_shared.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !(0, import_shared.isIntegerKey)(key);
      return shouldUnwrap ? res.value : res;
    }
    if ((0, import_shared.isObject)(res)) {
      return isReadonly ? readonly(res) : reactive(res);
    }
    return res;
  };
}
var set = /* @__PURE__ */ createSetter();
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);
      if (!(0, import_shared.isArray)(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = (0, import_shared.isArray)(target) && (0, import_shared.isIntegerKey)(key) ? Number(key) < target.length : (0, import_shared.hasOwn)(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if ((0, import_shared.hasChanged)(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = (0, import_shared.hasOwn)(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!(0, import_shared.isSymbol)(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", (0, import_shared.isArray)(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
var toReactive = (value) => (0, import_shared.isObject)(value) ? reactive(value) : value;
var toReadonly = (value) => (0, import_shared.isObject)(value) ? readonly(value) : value;
var toShallow = (value) => value;
var getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get", key);
  }
  !isReadonly && track(rawTarget, "get", rawKey);
  const {has: has2} = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has", key);
  }
  !isReadonly && track(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
  target = target["__v_raw"];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const {has: has2, get: get2} = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (process.env.NODE_ENV !== "production") {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if ((0, import_shared.hasChanged)(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const {has: has2, get: get2} = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (process.env.NODE_ENV !== "production") {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = process.env.NODE_ENV !== "production" ? (0, import_shared.isMap)(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly, isShallow) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = (0, import_shared.isMap)(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const {value, done} = innerIterator.next();
        return done ? {value, done} : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (process.env.NODE_ENV !== "production") {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${(0, import_shared.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get((0, import_shared.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
var mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
var readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = (0, import_shared.toRawType)(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var reactiveMap = new WeakMap();
var shallowReactiveMap = new WeakMap();
var readonlyMap = new WeakMap();
var shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap((0, import_shared.toRawType)(value));
}
function reactive(target) {
  if (target && target["__v_isReadonly"]) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0, import_shared.isObject)(target)) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function trackRefValue(ref2) {
  if (isTracking()) {
    ref2 = toRaw(ref2);
    if (!ref2.dep) {
      ref2.dep = createDep();
    }
    if (process.env.NODE_ENV !== "production") {
      trackEffects(ref2.dep, {
        target: ref2,
        type: "get",
        key: "value"
      });
    } else {
      trackEffects(ref2.dep);
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    if (process.env.NODE_ENV !== "production") {
      triggerEffects(ref2.dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    } else {
      triggerEffects(ref2.dep);
    }
  }
}
var convert = (val) => (0, import_shared.isObject)(val) ? reactive(val) : val;
function isRef(r) {
  return Boolean(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value);
}
var RefImpl = class {
  constructor(value, _shallow = false) {
    this._shallow = _shallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = _shallow ? value : toRaw(value);
    this._value = _shallow ? value : convert(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this._shallow ? newVal : toRaw(newVal);
    if ((0, import_shared.hasChanged)(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this._shallow ? newVal : convert(newVal);
      triggerRefValue(this, newVal);
    }
  }
};
function createRef(rawValue, shallow = false) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
var ComputedRefImpl = class {
  constructor(getter, _setter, isReadonly) {
    this._setter = _setter;
    this.dep = void 0;
    this._dirty = true;
    this.__v_isRef = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this["__v_isReadonly"] = isReadonly;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
};
function computed(getterOrOptions, debugOptions) {
  let getter;
  let setter;
  if ((0, import_shared.isFunction)(getterOrOptions)) {
    getter = getterOrOptions;
    setter = process.env.NODE_ENV !== "production" ? () => {
      console.warn("Write operation failed: computed value is readonly");
    } : import_shared.NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, (0, import_shared.isFunction)(getterOrOptions) || !getterOrOptions.set);
  if (process.env.NODE_ENV !== "production" && debugOptions) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
var _a;
var tick = Promise.resolve();
_a = "__v_isReadonly";

// src/features/splitEditors.ts
var shared2 = __toModule(require_out());
function activate6(context) {
  context.subscriptions.push(import_coc6.commands.registerCommand("volar.action.splitEditors", onSplit));
  async function onSplit() {
    const getDocDescriptor = useDocDescriptor();
    const doc = await import_coc6.workspace.document;
    if (!doc) {
      return;
    }
    const descriptor = getDocDescriptor(doc.textDocument.getText());
    const blocksSet = [];
    const scriptBlocks = [];
    const templateBlocks = [];
    const styleBlocks = [];
    const customBlocks = [];
    if (descriptor.scriptSetup || descriptor.script) {
      blocksSet.push([descriptor.scriptSetup, descriptor.script].filter(shared2.notEmpty));
    }
    if (descriptor.template) {
      blocksSet.push([descriptor.template]);
    }
    if (descriptor.styles.length) {
      blocksSet.push(descriptor.styles);
    }
    if (descriptor.customBlocks.length) {
      blocksSet.push(descriptor.customBlocks);
    }
    for (let i = 0; i < blocksSet.length; i++) {
      for (const v of blocksSet[i]) {
        switch (v.type) {
          case "script":
            scriptBlocks.push({type: v.type, start: v.loc.start.line, end: v.loc.end.line});
            break;
          case "template":
            templateBlocks.push({type: v.type, start: v.loc.start.line, end: v.loc.end.line});
            break;
          case "style":
            styleBlocks.push({type: v.type, start: v.loc.start.line, end: v.loc.end.line});
            break;
          default:
            customBlocks.push({type: v.type, start: v.loc.start.line, end: v.loc.end.line});
            break;
        }
      }
    }
    let currentSplitCount = 0;
    if (scriptBlocks.length >= 1) {
      await import_coc6.workspace.jumpTo(doc.textDocument.uri, import_coc6.Position.create(scriptBlocks[0].start - 1, scriptBlocks[0].end - 1));
      if (templateBlocks.length >= 1)
        await foldingSFCBlock(templateBlocks);
      if (styleBlocks.length >= 1)
        await foldingSFCBlock(styleBlocks);
      if (customBlocks.length >= 1)
        await foldingSFCBlock(customBlocks);
      currentSplitCount++;
      await doSplitWindow(blocksSet.length, currentSplitCount);
    }
    if (templateBlocks.length >= 1) {
      await import_coc6.workspace.jumpTo(doc.textDocument.uri, import_coc6.Position.create(templateBlocks[0].start - 1, templateBlocks[0].end - 1));
      if (scriptBlocks.length >= 1)
        await foldingSFCBlock(scriptBlocks);
      if (styleBlocks.length >= 1)
        await foldingSFCBlock(styleBlocks);
      if (customBlocks.length >= 1)
        await foldingSFCBlock(customBlocks);
      currentSplitCount++;
      await doSplitWindow(blocksSet.length, currentSplitCount);
    }
    if (styleBlocks.length >= 1) {
      await import_coc6.workspace.jumpTo(doc.textDocument.uri, import_coc6.Position.create(styleBlocks[0].start - 1, styleBlocks[0].end - 1));
      if (scriptBlocks.length >= 1)
        await foldingSFCBlock(scriptBlocks);
      if (templateBlocks.length >= 1)
        await foldingSFCBlock(templateBlocks);
      if (customBlocks.length >= 1)
        await foldingSFCBlock(customBlocks);
      currentSplitCount++;
      await doSplitWindow(blocksSet.length, currentSplitCount);
    }
    if (customBlocks.length >= 1) {
      await import_coc6.workspace.jumpTo(doc.textDocument.uri, import_coc6.Position.create(customBlocks[0].start - 1, customBlocks[0].end - 1));
      if (scriptBlocks.length >= 1)
        await foldingSFCBlock(scriptBlocks);
      if (templateBlocks.length >= 1)
        await foldingSFCBlock(templateBlocks);
      if (styleBlocks.length >= 1)
        await foldingSFCBlock(styleBlocks);
      currentSplitCount++;
      await doSplitWindow(blocksSet.length, currentSplitCount);
    }
  }
}
function useDocDescriptor() {
  const splitDocText = ref("");
  const splitDocDescriptor = computed(() => (0, import_compiler_sfc.parse)(splitDocText.value, {sourceMap: false, ignoreEmpty: false}).descriptor);
  return getDescriptor;
  function getDescriptor(text) {
    splitDocText.value = text;
    return splitDocDescriptor.value;
  }
}
async function foldingSFCBlock(blockRanges) {
  for (const v of blockRanges) {
    await import_coc6.workspace.nvim.command(`${v.start},${v.end}fold`);
  }
}
async function doSplitWindow(maxSplitCount, currentSplitCount) {
  if (maxSplitCount > currentSplitCount) {
    if (currentSplitCount % 2 === 1) {
      await import_coc6.workspace.nvim.command("belowright vsplit || 1,$foldopen");
    }
    if (currentSplitCount % 2 === 0) {
      await import_coc6.workspace.nvim.command("belowright split || 1,$foldopen");
    }
  }
}

// src/features/tsVersion.ts
var import_coc7 = __toModule(require("coc.nvim"));
var shared3 = __toModule(require_out());
var import_path = __toModule(require("path"));
var import_fs = __toModule(require("fs"));
var defaultTsdk = "node_modules/typescript/lib";
function getCurrentTsPaths(context) {
  if (isUseWorkspaceTsdk()) {
    const workspaceTsPaths = getWorkspaceTsPaths(true);
    if (workspaceTsPaths) {
      return {...workspaceTsPaths, isWorkspacePath: true};
    }
  }
  const tsLocale = getTsLocale();
  const tsLocaleJsonPath = import_path.default.join(context.extensionPath, "node_modules", "typescript", "lib", tsLocale, "diagnosticMessages.generated.json");
  const localizedPath = import_fs.default.existsSync(tsLocaleJsonPath) ? tsLocaleJsonPath : void 0;
  const builtinTsPaths = {
    serverPath: import_path.default.join(context.extensionPath, "node_modules", "typescript", "lib", "typescript.js"),
    localizedPath
  };
  return {...builtinTsPaths, isWorkspacePath: false};
}
function getWorkspaceTsPaths(useDefault = false) {
  let tsdk = getTsdk();
  if (!tsdk && useDefault) {
    tsdk = defaultTsdk;
  }
  if (tsdk) {
    const tsPath = shared3.getWorkspaceTypescriptPath(tsdk, import_coc7.workspace.workspaceFolders.map((folder) => import_coc7.Uri.parse(folder.uri).fsPath));
    if (tsPath) {
      const tsLocale = getTsLocale();
      const tsLocaleJsonPath = import_path.default.join(import_path.default.dirname(tsPath), tsLocale, "diagnosticMessages.generated.json");
      const localizedPath = import_fs.default.existsSync(tsLocaleJsonPath) ? tsLocaleJsonPath : void 0;
      return {
        serverPath: tsPath,
        localizedPath
      };
    }
  }
}
function getTsdk() {
  const tsConfigs = import_coc7.workspace.getConfiguration("tsserver");
  const tsdk = tsConfigs.get("tsdk");
  return tsdk;
}
function isUseWorkspaceTsdk() {
  return import_coc7.workspace.getConfiguration("volar").get("useWorkspaceTsdk", false);
}
function getTsLocale() {
  return import_coc7.workspace.getConfiguration("volar").get("diagnostics.tsLocale", "en");
}

// src/features/verifyAll.ts
var import_coc8 = __toModule(require("coc.nvim"));
async function activate7(context, languageClient) {
  await languageClient.onReady();
  context.subscriptions.push(import_coc8.commands.registerCommand("volar.action.verifyAllScripts", () => {
    languageClient.sendNotification(VerifyAllScriptsNotificationType);
  }));
}

// src/features/vueTscVersion.ts
var import_coc9 = __toModule(require("coc.nvim"));
var path2 = __toModule(require("path"));
var fs2 = __toModule(require("fs"));
async function activate8(context, outputChannel2) {
  if (!import_coc9.workspace.getConfiguration("volar").get("checkVueTscVersion"))
    return;
  if (import_coc9.workspace.workspaceFolders) {
    for (const folder of import_coc9.workspace.workspaceFolders) {
      const depPath = path2.join(import_coc9.Uri.parse(folder.uri).fsPath, "node_modules", "vscode-vue-languageservice", "package.json");
      const extVueTscPackageJsonPath = path2.join(context.extensionPath, "node_modules", "vscode-vue-languageservice", "package.json");
      if (fs2.existsSync(depPath) && fs2.existsSync(extVueTscPackageJsonPath)) {
        try {
          const packageJsonText = fs2.readFileSync(depPath, "utf8");
          const packageJson = JSON.parse(packageJsonText);
          const depVersion = packageJson.version;
          const extVueTscPackageJsonText = fs2.readFileSync(extVueTscPackageJsonPath, "utf8");
          const extVueTscPackageJson = JSON.parse(extVueTscPackageJsonText);
          const extVueTscVersion = extVueTscPackageJson.version;
          outputChannel2.appendLine(`VueTsc(dep) Version | Path: ${depVersion} | ${packageJson}`);
          outputChannel2.appendLine(`VueTsc(ext) Version | Path: ${extVueTscVersion} | ${extVueTscPackageJson}`);
          if (depVersion && depVersion !== extVueTscVersion) {
            const message = `Your vue-tsc dependency is not same with Extension version (${depVersion} ~ ${extVueTscVersion}). It may cause inconsistent type check results between cli and IDE.`;
            const howTo = "How To Update?";
            const disable = "Disable Version Checking";
            const option = await import_coc9.window.showInformationMessage(message, howTo, disable);
            if (option === howTo) {
              import_coc9.commands.executeCommand("vscode.open", ["https://github.com/johnsoncodehk/volar/discussions/402"]);
            }
            if (option === disable) {
              await import_coc9.workspace.nvim.command(`CocRestart`, true);
              const config = import_coc9.workspace.getConfiguration("volar");
              config.update("checkVueTscVersion", false);
            }
          }
        } catch {
        }
      }
    }
  }
}

// src/action.ts
var import_coc10 = __toModule(require("coc.nvim"));
var VolarCodeActionProvider = class {
  async provideCodeActions(document2, range, context) {
    const doc = import_coc10.workspace.getDocument(document2.uri);
    const wholeRange = import_coc10.Range.create(0, 0, doc.lineCount, 0);
    let whole = false;
    if (range.start.line === wholeRange.start.line && range.start.character === wholeRange.start.character && range.end.line === wholeRange.end.line && range.end.character === wholeRange.end.character) {
      whole = true;
    }
    const codeActions = [];
    if (this.lineRange(range) && context.diagnostics.length > 0) {
      let existsVolarTsDiagnostics = false;
      context.diagnostics.forEach((d) => {
        console.log(d.source);
        if (d.source === "ts") {
          existsVolarTsDiagnostics = true;
        }
      });
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const suppressLineLength = thisLineFullLength - thisLineTrimLength;
      let suppressLineNewText = "// @ts-ignore\n";
      if (suppressLineLength > 0) {
        const addIndentSpace = " ".repeat(suppressLineLength);
        suppressLineNewText = "// @ts-ignore\n" + addIndentSpace;
      }
      let thisLineContent = doc.getline(range.start.line);
      thisLineContent = thisLineContent.trim();
      if (!thisLineContent.startsWith("//") && !thisLineContent.startsWith("/*") && !thisLineContent.startsWith("*") && existsVolarTsDiagnostics) {
        const edit = import_coc10.TextEdit.insert(import_coc10.Position.create(range.start.line, suppressLineLength), suppressLineNewText);
        codeActions.push({
          title: "Add @ts-ignore for this line",
          edit: {
            changes: {
              [doc.uri]: [edit]
            }
          }
        });
      }
    }
    return codeActions;
  }
  lineRange(r) {
    return r.start.line + 1 === r.end.line && r.start.character === 0 && r.end.character === 0 || r.start.line === r.end.line && r.start.character === 0;
  }
};

// src/index.ts
var apiClient;
var docClient;
var htmlClient;
var serverModule;
var outputChannel = import_coc11.window.createOutputChannel("volar-client");
var resolveCurrentTsPaths;
async function activate9(context) {
  const extensionConfig = import_coc11.workspace.getConfiguration("volar");
  const isEnable = extensionConfig.get("enable", true);
  if (!isEnable)
    return;
  outputChannel.appendLine(`${"#".repeat(10)} volar-client
`);
  const devVolarServerPath = extensionConfig.get("dev.serverPath", "");
  if (devVolarServerPath && devVolarServerPath !== "" && fs3.existsSync(devVolarServerPath)) {
    serverModule = devVolarServerPath;
  } else {
    serverModule = context.asAbsolutePath(path3.join("node_modules", "@volar", "server", "out", "index.js"));
  }
  apiClient = createLanguageService(context, "api", "volar-api", "Volar - API", 6009, "file");
  docClient = createLanguageService(context, "doc", "volar-document", "Volar - Document", 6010, "file");
  htmlClient = createLanguageService(context, "html", "volar-html", "Volar - HTML", 6011, void 0);
  const clients = [apiClient, docClient, htmlClient];
  registarRestartRequest();
  registarClientRequests();
  activate6(context);
  activate7(context, docClient);
  activate4(context, htmlClient);
  activate5(context, apiClient);
  activate8(context, outputChannel);
  async function registarRestartRequest() {
    await Promise.all(clients.map((client) => client.onReady()));
    context.subscriptions.push(import_coc11.commands.registerCommand("volar.action.restartServer", async () => {
      await Promise.all(clients.map((client) => client.stop()));
      await Promise.all(clients.map((client) => client.start()));
      registarClientRequests();
    }));
  }
  function registarClientRequests() {
    for (const client of clients) {
      activate3(context, client);
      activate(context, client);
      activate2(context, client);
    }
  }
  context.subscriptions.push(import_coc11.commands.registerCommand("volar.version", () => {
    const volarJSON = path3.join(context.extensionPath, "node_modules", "@volar", "server", "package.json");
    const volarPackageText = JSON.parse(fs3.readFileSync(volarJSON, "utf8"));
    const cocVolarJSON = path3.join(context.extensionPath, "package.json");
    const cocVolarPackageText = JSON.parse(fs3.readFileSync(cocVolarJSON, "utf8"));
    import_coc11.window.showMessage(`coc-volar(client) v${cocVolarPackageText.version} with volar(server) v${volarPackageText.version}`);
  }));
  const languageSelector = [{language: "vue", scheme: "file"}];
  const codeActionProvider = new VolarCodeActionProvider();
  context.subscriptions.push(import_coc11.languages.registerCodeActionProvider(languageSelector, codeActionProvider, "volar"));
}
function deactivate() {
  return (apiClient == null ? void 0 : apiClient.stop()) && (docClient == null ? void 0 : docClient.stop()) && (htmlClient == null ? void 0 : htmlClient.stop());
}
function createLanguageService(context, mode, id, name, port, scheme) {
  const debugOptions = {execArgv: ["--nolazy", "--inspect=" + port]};
  const serverOptions = {
    run: {module: serverModule, transport: import_coc11.TransportKind.ipc},
    debug: {
      module: serverModule,
      transport: import_coc11.TransportKind.ipc,
      options: debugOptions
    }
  };
  if (!resolveCurrentTsPaths) {
    resolveCurrentTsPaths = getCurrentTsPaths(context);
    outputChannel.appendLine(`currentTsPath: ${resolveCurrentTsPaths.serverPath}`);
    outputChannel.appendLine(`localizePath: ${resolveCurrentTsPaths.localizedPath}`);
    outputChannel.appendLine(`isWorkspacePath: ${resolveCurrentTsPaths.isWorkspacePath}`);
  }
  const serverInitOptions = {
    typescript: resolveCurrentTsPaths,
    languageFeatures: mode === "api" ? {
      references: true,
      definition: true,
      typeDefinition: true,
      callHierarchy: true,
      hover: true,
      rename: true,
      renameFileRefactoring: true,
      signatureHelp: true,
      codeAction: true,
      completion: {
        defaultTagNameCase: getConfigTagNameCase(),
        defaultAttrNameCase: getConfigAttrNameCase(),
        getDocumentNameCasesRequest: false,
        getDocumentSelectionRequest: false
      },
      schemaRequestService: true
    } : mode === "doc" ? {
      documentHighlight: true,
      documentLink: true,
      codeLens: {showReferencesNotification: true},
      semanticTokens: true,
      diagnostics: getConfigDiagnostics(),
      schemaRequestService: true
    } : void 0,
    documentFeatures: mode === "html" ? {
      selectionRange: true,
      foldingRange: true,
      linkedEditingRange: true,
      documentSymbol: true,
      documentColor: true,
      documentFormatting: getConfigDocumentFormatting()
    } : void 0
  };
  const clientOptions = {
    documentSelector: [
      {scheme, language: "vue"},
      {scheme, language: "javascript"},
      {scheme, language: "typescript"},
      {scheme, language: "javascriptreact"},
      {scheme, language: "typescriptreact"}
    ],
    initializationOptions: serverInitOptions
  };
  const client = new import_coc11.LanguageClient(id, name, serverOptions, clientOptions);
  context.subscriptions.push(client.start());
  return client;
}
function getConfigTagNameCase() {
  const tagNameCase = import_coc11.workspace.getConfiguration("volar").get("tagNameCase");
  switch (tagNameCase) {
    case "both":
      return "both";
    case "kebab":
      return "kebabCase";
    case "pascal":
      return "pascalCase";
  }
  return "both";
}
function getConfigAttrNameCase() {
  const tagNameCase = import_coc11.workspace.getConfiguration("volar").get("attrNameCase");
  switch (tagNameCase) {
    case "kebab":
      return "kebabCase";
    case "camel":
      return "camelCase";
  }
  return "kebabCase";
}
function getConfigDiagnostics() {
  const isDiagnosticsEnable = import_coc11.workspace.getConfiguration("volar").get("diagnostics.enable", true);
  if (isDiagnosticsEnable) {
    return {getDocumentVersionRequest: true};
  } else {
    return void 0;
  }
}
function getConfigDocumentFormatting() {
  const isFormattingEnable = import_coc11.workspace.getConfiguration("volar").get("formatting.enable", true);
  if (isFormattingEnable) {
    return {
      defaultPrintWidth: 100,
      getDocumentPrintWidthRequest: true
    };
  } else {
    return void 0;
  }
}
